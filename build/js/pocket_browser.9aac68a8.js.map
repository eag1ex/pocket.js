{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/x-utils-es/umd/index.js","webpack:///./libs/dispatcher.js","webpack:///./node_modules/simple-q/index.js","webpack:///./Pocket/versions/Pocket.browser.js","webpack:///./Pocket/Pocket.module.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/simple-q/simple-q.js","webpack:///./Pocket/Pocket.libs.js","webpack:///./Pocket/Probe.js","webpack:///./Pocket/Pocket.architect.js","webpack:///./Pocket/Pocket.selectors.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","factory","_Numberprototype","Number","_Stringprototype","String","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","disableLogging","window","xUtilsConfig","logging","err","global","resetLogging","loggerSetting","logType","logMode","includes","checkLoggerSetting","loggingON","logConstract","type","args","length","format","filter","concat","console","log","apply","_len6","arguments","Array","_key6","allData","isArray","stack","data","asArray","stackList","Error","JSON","stringify","split","splice","stackHead","replace","unshift","errorTrace","errHead","loop","size","cb","inx","this","entries","break","push","arr","__proto__","typeCheck","el","standard","ofType","asPrototype","Type","primitiveValue","Boolean","BigInt","Date","Function","keys","isNaN","isError","isFalsy","isPromise","isEmpty","head","flat","shift","last","timer","time","setTimeout","clearTimeout","interval","every","endTime","counter","setInterval","clearInterval","validID","id","toString","toLowerCase","isNumber","objectSize","obj","stringSize","str","defer","isObject","uniq","all","indexOf","isClass","selectiveArray","selectBy","item","nData","findNest","found","collective","hasPrototype","hasProto","isString","isFunction","copyBy","refs","reduce","parse","copy","delay","someKeyMatch","source","a","b","z","zz","exactKeyMatch","trueVal","itm","trueValDeep","map","typeIs","child","_ref","k","v","trueProp","assign","_ref2","val","resolver","fn","timeout","testEvery","max","called","self","_asyncToGenerator","anon","test","flatten","flattenDeep","acc","slice","chunks","from","Math","ceil","debug","_len2","_key2","_len","_key","warn","_len3","_key3","onerror","alert","_len4","_key4","attention","_len5","_key5","validDate","dt","isInstance","dupes","index","dups","parseInt","notify","logData","_uid","_debug","uid","plugin","getTime","cbQueue","dispatchInstance","initListener","Dispatch","next","message","isActive","del","subscribe","Pocket","require","PocketModule","sq","PocketLibs","newProbe","Probe","PocketModuleExt","opts","projectID","lastProjectID","deletePocketSet","async","returnAs","asAsync","undefined","payload","$payload","payloadID","allowsMultiple","disableWarnings","_payloadID","projectsCache","_ready_method_set","$projectSetAsync","ready","deleteWithDelay","dispatcher","probe","status","isUpdated","validProjectID","payloadData","_lastProjectID","initialProject","_lastFilterList","values","idRegexValid","probeID","pocket","timestamp","task","lastPocketTimestamp","distributor","setDefer","projectSetDispatcher","_projectSetAsync","promise","lastProbeID","getStatusAsync","dataFrom","mergeData","_setUpdate","tasks","_ready","updated","pos","probeProps","clearStoreTransfers","$transfer_lastID","_$cached_data","msg","pocketSet","output","pock","prop","userOutput","pl","setProbe","emitter","_emit","onChange","_onChange","completeOnNull","poc","_projectSetDispatcher","architectConfig","PocketArchitect","g","e","promises","__deferSet","_lastProbeID","_projectSet","_transferCached","cleared","forEach","element","fromProbeID","fromAverageTimeHasPast","sort","transferCachedCopy","coundCache","currentOffset","taskOrProbeID","updateLastProbeID","dynamicProbeID","newProbeID","validProbe","selectedData","dataProp","probeData","RegExp","props","_id","_error","_task","_status","_data","_campaign","_dataIndex","_statusIndex","_statusAsync","_onchangeDispatch","ref","campaign","_completeAsync","merge","watch","availableWatch","statIndex","onchangeDispatch","changedName","changed","pat","dispatchChange","open","set","complete","send","stat","statusStackOrder","onOpenStatus","setStatusAsync","onComplete","lastPromise","ArchitectModel","_architectVal","architect","configurable","archModel","architectMod","assetName","asCallback","lastProject","getArchitect","config","configProjectID","validConfig","project","asset","setArchitect","cached","selectByTask","selfType","$get","probeStatusAsync","_get","probeRef","_set","constructor","update","isNONE","probeList","projectProbeList","matchFound","lastFilter","_probe","list","storeTransfers","toProbeID","pointToThisProbe","maxDelay","lastValidTransfer","accessLastValidTransfer","trim","dataPropSelector","hasValue","watchProp"],"mappings":"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","file":"js/pocket_browser.9aac68a8.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/* tslint:disable */\n/* eslint-disable */\n/* eslint-disable no-proto */\n\n/**\n * @xtils\n * * Simple javascript, lodash alternative library\n * * Developed by Anon\n * * license: CC-BY-SA-4.0\n */\n\n(function(global,factory){if(\"function\"===typeof define&&define.amd)define(\"xutils\",[\"exports\"],factory);else if(\"undefined\"!==typeof exports)factory(exports);else{var mod={exports:{}};factory(mod.exports),global.xutils=mod.exports}})(this,function(exports){\"use strict\";var _Numberprototype=Number.prototype,_Stringprototype=String.prototype;function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise(function(resolve,reject){function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,\"next\",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,\"throw\",err)}var gen=fn.apply(self,args);_next(void 0)})}}Object.defineProperty(exports,\"__esModule\",{value:!0});var disableLogging=exports.disableLogging=()=>{try{if(window)return window.xUtilsConfig?window.xUtilsConfig.logging=\"off\":window.xUtilsConfig={logging:\"off\"},!0}catch(err){}try{return global.xUtilsConfig?global.xUtilsConfig.logging=\"off\":global.xUtilsConfig={logging:\"off\"},!0}catch(err){}return!1},resetLogging=exports.resetLogging=()=>{try{if(window)return window.xUtilsConfig?window.xUtilsConfig.logging=\"on\":window.xUtilsConfig={logging:\"on\"},!0}catch(err){}try{return global.xUtilsConfig?global.xUtilsConfig.logging=\"on\":global.xUtilsConfig={logging:\"on\"},!0}catch(err){}return!1},loggerSetting=exports.loggerSetting=function loggerSetting(logType,logMode){void 0===logType&&(logType=\"log\"),void 0===logMode&&(logMode=\"off\");if(![\"log\",\"warn\",\"onerror\",\"error\",\"alert\",\"attention\",\"debug\"].includes(logType)||!logType)return!1;if(![\"on\",\"off\"].includes(logMode)||!logMode)return!1;\"onerror\"===logType&&(logType=\"error\");try{if(window)return window.xUtilsConfig?window.xUtilsConfig[logType]=logMode:window.xUtilsConfig={[logType]:logMode},!0}catch(err){}try{return global.xUtilsConfig?global.xUtilsConfig[logType]=logMode:global.xUtilsConfig={[logType]:logMode},!0}catch(err){}return!1},checkLoggerSetting=logType=>{try{if(window)return window.xUtilsConfig?window.xUtilsConfig[logType]?window.xUtilsConfig[logType]:\"on\":\"on\"}catch(err){}try{return global.xUtilsConfig?global.xUtilsConfig[logType]?global.xUtilsConfig[logType]:\"on\":\"on\"}catch(err){}return\"on\"},loggingON=()=>{try{if(window)return\"on\"===(window.xUtilsConfig||{}).logging||(window.xUtilsConfig||{}).logging===void 0}catch(err){}try{return\"on\"===(global.xUtilsConfig||{}).logging||(global.xUtilsConfig||{}).logging===void 0}catch(err){}return!0},logConstract=function logConstract(type,args){void 0===type&&(type=\"\"),args.length||(args[0]=\"\");var allData=0===args.filter(n=>\"string\"===typeof n||n===void 0).length,format=allData?\"%o\":\"\";\"log\"===type&&(args=[].concat(\"\\x1B[90m[log]\\x1B[0m\\x1B[2m\"+format+\" \",args,\"\\x1B[0m\")),\"debug\"===type&&(args=[].concat(\"\\x1B[90m[debug]\\x1B[0m\\x1B[32m\"+format+\" \",args,\"\\x1B[0m\")),\"warn\"===type&&(args=[].concat(\"\\x1B[90m[warning]\\x1B[0m\\x1B[1m\"+format+\" \",args,\"\\x1B[0m\")),\"alert\"===type&&(args=[].concat(\"\\x1B[90m[alert]\\x1B[0m\\x1B[33m\"+format+\" \",args,\"\\x1B[0m\")),\"attention\"===type&&(args=[].concat(\"\\x1B[90m[attention]\\x1B[0m\\x1B[36m\"+format+\" \",args,\"\\x1B[0m\"));try{return void(window&&console.log.apply(null,args))}catch(err){}console.log.apply(null,args)},error=function error(){for(var _len6=arguments.length,args=Array(_len6),_key6=0;_key6<_len6;_key6++)args[_key6]=arguments[_key6];if(loggingON()&&\"off\"!==checkLoggerSetting(\"error\")&&\"off\"!==checkLoggerSetting(\"onerror\")){args.length||(args[0]=\"\");var allData=0===args.filter(n=>\"string\"===typeof n||void 0===n).length,format=allData?\"%o\":\"\";try{if(window)return args=[].concat(\"\\x1B[31m[error]\\x1B[0m\\x1B[31m\"+format+\" \",args,\"\\x1B[0m\"),void console.error.apply(null,args)}catch(err){}args=[].concat(\"\\x1B[41m[error]\\x1B[0m\\x1B[31m\"+format+\" \",args,\"\\x1B[0m\"),console.log.apply(null,args)}},stack=exports.stack=function stack(data,asArray){if(void 0===asArray&&(asArray=!1),!!loggingON()){var stackList=new Error(JSON.stringify(data)).stack.split(\"(\");stackList.splice(1,1);var stackHead=stackList[0].split(/\\n/)[0].replace(\"Error\",\"[STACK TRACE]\");return stackList.splice(0,1),stackList.unshift(stackHead),void(asArray?console.log(stackList):console.log.apply(null,stackList))}},errorTrace=exports.errorTrace=function errorTrace(data,asArray){if(void 0===asArray&&(asArray=!1),!!loggingON()){var stackList=new Error(JSON.stringify(data)).stack.split(\"(\");stackList.splice(1,1);var errHead=stackList[0].split(/\\n/)[0].replace(\"Error\",\"[ERROR]\");return stackList.splice(0,1),stackList.unshift(errHead),void(asArray?console.error(stackList):console.error.apply(null,stackList))}},loop=exports.loop=function loop(size,cb){void 0===size&&(size=0);var isNum=\"number\"===typeof size;if(!(\"function\"===typeof cb)||!isNum)return[];if(!size)return[];for(var r,d=[],inx=0;inx<Array(size).length;inx++){r=cb.apply(this,[inx]);try{if(r&&Object.entries(r).length&&r.break)break}catch(err){}d.push(r)}return d},isArray=arr=>!!arr&&Array.prototype===arr.__proto__,typeCheck=function typeCheck(el,standard){void 0===standard&&(standard=!0);var ofType=type=>standard?typeof el:type||typeof el,asPrototype=Type=>Type.prototype===el.prototype;try{return\"symbol\"===typeof el?{type:ofType(),value:0,primitiveValue:Symbol(\"\")}:void 0===el?{type:ofType(),value:0,primitiveValue:void 0}:\"boolean\"===typeof el?{type:ofType(),value:+el,primitiveValue:Boolean()}:\"bigint\"===typeof el&&\"object\"===typeof Object(el)?{type:ofType(),value:1,primitiveValue:BigInt(\"\")}:null===el?{type:ofType(\"null\"),value:0,primitiveValue:{}}:el.__proto__===Date.prototype||asPrototype(Date)?{type:ofType(\"date\"),value:1,primitiveValue:new Date}:_Stringprototype===el.__proto__?{type:ofType(),value:el.length,primitiveValue:String()}:Array.prototype===el.__proto__||asPrototype(Array)?{type:ofType(\"array\"),value:(el||[]).length,primitiveValue:[]}:Promise.prototype===(el||\"\").__proto__||asPrototype(Promise)?{type:ofType(\"promise\"),value:1,primitiveValue:Function()}:Function.prototype===el.__proto__||asPrototype(Function)?{type:ofType(),value:1,primitiveValue:Function()}:Object.prototype===el.__proto__||asPrototype(Object)?{type:ofType(),value:Object.keys(el).length,primitiveValue:{}}:Error.prototype===el.__proto__||asPrototype(Error)?{type:ofType(\"error\"),value:Object.keys(el).length,primitiveValue:Error()}:el.__proto__===_Numberprototype||asPrototype(Number)?isNaN(el)?{type:ofType(\"NaN\"),value:0,primitiveValue:Number()}:{type:ofType(),value:el,primitiveValue:Number()}:!1===0<=+el?{type:typeof el,value:+el,primitiveValue:void 0}:{type:typeof el,value:0,primitiveValue:void 0}}catch(err){return error(err),{}}},isError=el=>Error.prototype===(el||\"\").__proto__,isFalsy=function isFalsy(el){return void 0===el&&(el=null),void 0===el||!1===el&&\"boolean\"===typeof el||null===el||(_Stringprototype===el.__proto__?1>el.length:Array.prototype===el.__proto__?0===(el||[]).length:Promise.prototype!==(el||{}).__proto__&&\"function\"!==typeof el&&(Object.prototype===el.__proto__?0===Object.keys(el).length:Error.prototype!==el.__proto__&&(void 0!==el&&el.__proto__===_Numberprototype?!!isNaN(el)||0>=el:!1===0<+el||!el&&!1)))},isEmpty=exports.isEmpty=value=>!isError(value)&&!typeCheck(value).value,head=exports.head=function head(arr){return void 0===arr&&(arr=[]),Array.prototype===(arr||null).__proto__?arr.flat().shift():[]},last=exports.last=function last(arr){return void 0===arr&&(arr=[]),arr&&Array.prototype===arr.__proto__?arr[arr.length-1]:null},timer=exports.timer=function timer(cb,time){void 0===time&&(time=0);if(!(\"function\"===typeof cb))return null;time=\"number\"===typeof time&&0<=time?time:0;var s=setTimeout(()=>{cb(),clearTimeout(s)},time)},interval=exports.interval=function interval(cb,every,endTime){void 0===every&&(every=0),void 0===endTime&&(endTime=0);if(!(\"function\"===typeof cb))return null;every=\"number\"===typeof every&&0<=every?every:0,endTime=\"number\"===typeof endTime&&0<=endTime?endTime:0;var counter=0,c=setInterval(()=>{endTime<=counter?clearInterval(c):cb(),counter+=every},every)},validID=exports.validID=function validID(id){return void 0===id&&(id=\"\"),id||\"\"?(id||\"\").toString().toLowerCase().replace(/\\s/g,\"\"):\"\"},isNumber=exports.isNumber=n=>!(n===void 0||null===n||\"\"===n)&&n.__proto__===_Numberprototype,objectSize=exports.objectSize=function objectSize(obj){return void 0===obj&&(obj={}),obj&&isNaN(+obj)?Object.prototype===obj.__proto__||Error.prototype===obj.__proto__?Object.keys(obj).length:0:0},stringSize=exports.stringSize=function stringSize(str){return void 0===str&&(str=\"\"),void 0!==str&&null!==str?str.__proto__===_Stringprototype?str.length:0:0},isPromise=defer=>Promise.prototype===(defer||{}).__proto__,isObject=obj=>{if(\"function\"===typeof obj)return!1;if(!isNaN(+obj)||void 0===obj)return!1;if(obj.__proto__===[].__proto__)return!1;var a=Object.prototype===obj.__proto__||Error.prototype===obj.__proto__,ab=a&&obj instanceof Object;return!!ab||!!(void 0!==obj.__proto__&&void 0!==obj.__proto__.__proto__&&obj.__proto__.__proto__===Object.prototype&&obj instanceof Object)||!!obj.prototype},uniq=function uniq(arr){return void 0===arr&&(arr=[]),arr.filter((el,i,all)=>all.indexOf(el)===i)},selectiveArray=exports.selectiveArray=function selectiveArray(selectBy,data){if(void 0===selectBy&&(selectBy=[]),void 0===data&&(data=[{}]),!isArray(data))return[];if(!data.length)return[];if(!isArray(selectBy))return data;if(!selectBy.length)return data;selectBy=uniq(selectBy);for(var item,nData=[],findNest=function findNest(s,item,inx){void 0===inx&&(inx=0);var found,lastItem=null;if(s&&isArray(s)&&s.length){try{if(void 0!==item[s[inx]])return lastItem=item[s[inx]],found=lastItem,++inx,s[inx]?findNest(s,found,inx):found}catch(err){console.log(err.toString())}return found}},i=0;i<data.length;i++){if(item=data[i],!isObject(item)){nData.push([item]);continue}for(var sArr,found=void 0,collective=[],o=0;o<selectBy.length;o++)sArr=(selectBy[o]||\"\").split(\".\"),found=findNest(sArr,item,0),collective.push(found);if(selectBy.length===collective.length){var allUndef=collective.filter(n=>void 0===n);allUndef.length===selectBy.length&&(collective=collective.filter(n=>!!n))}collective.length?nData.push([].concat(collective)):void 0!==found&&nData.push(found)}return nData},isClass=obj=>!!obj&&void 0!==obj.prototype,hasPrototype=exports.hasPrototype=isClass,hasProto=exports.hasProto=el=>{try{return el.__proto__!==void 0}catch(err){return!1}},isString=exports.isString=str=>\"undefined\"!==typeof str&&(\"\"===str||_Stringprototype===str.__proto__),isFunction=exports.isFunction=el=>\"function\"===typeof el,copyBy=exports.copyBy=function copyBy(obj,refs){if(void 0===obj&&(obj={}),void 0===refs&&(refs=[]),!isObject(obj))return{};var d=[].concat(refs).reduce((n,el)=>(void 0!==obj[el]&&(n[el]=obj[el]),n),{});try{return JSON.parse(JSON.stringify(d))}catch(err){return{}}},copy=exports.copy=data=>{try{return JSON.parse(JSON.stringify(data))}catch(err){return typeCheck(data).primitiveValue}},delay=exports.delay=function delay(time){void 0===time&&(time=100);var isNum=\"number\"===typeof time&&0<=time;return isNum?new Promise(resolve=>{var t=setTimeout(()=>{clearTimeout(t),resolve(!0)},time)}):Promise.resolve(!0)},someKeyMatch=exports.someKeyMatch=function someKeyMatch(object,source){if(void 0===object&&(object={}),void 0===source&&(source={}),!object||Object.prototype!==object.__proto__)return!1;if(!source||Object.prototype!==source.__proto__)return!1;var a=Object.keys(object),b=Object.keys(source);return a.length>=b.length?0<a.filter(z=>b.filter(zz=>zz===z).length).length:0<b.filter(z=>a.filter(zz=>zz===z).length).length},exactKeyMatch=exports.exactKeyMatch=function exactKeyMatch(object,source){if(void 0===object&&(object={}),void 0===source&&(source={}),!object||Object.prototype!==object.__proto__)return!1;if(!source||Object.prototype!==source.__proto__)return!1;var a=Object.keys(object),b=Object.keys(source);return a.length>=b.length?a.filter(z=>b.filter(zz=>zz===z).length).length===a.length:b.filter(z=>a.filter(zz=>zz===z).length).length===b.length},trueVal=exports.trueVal=function trueVal(arr){return void 0===arr&&(arr=[]),arr&&Array.prototype===arr.__proto__?[].concat(arr).filter(itm=>!0!==isFalsy(itm)):[]},trueValDeep=exports.trueValDeep=function trueValDeep(arr){return void 0===arr&&(arr=[]),arr&&Array.prototype===arr.__proto__?[].concat(arr).map(itm=>{var typeIs=typeCheck(itm,!1);return\"array\"===typeIs.type&&0<typeIs.value?itm.map(child=>0<typeCheck(child,!1).value?child:null).filter(n=>!!n):\"object\"===typeIs.type&&typeIs.value?Object.entries(itm).reduce((n,_ref)=>{var[k,v]=_ref;return 0<typeCheck(k,!1).value&&(n[k]=v),n},{}):0<typeIs.value?itm:null}).filter(n=>!!n):[]},trueProp=exports.trueProp=function trueProp(obj){return void 0===obj&&(obj={}),obj&&Object.prototype===obj.__proto__?Object.assign({},Object.entries(obj).reduce((n,_ref2)=>{var[key,val]=_ref2;return isFalsy(val)||(n[key]=val),n},{})):0},resolver=exports.resolver=function resolver(fn,timeout,testEvery){void 0===timeout&&(timeout=5e3),void 0===testEvery&&(testEvery=50);return\"function\"===typeof fn?new Promise(resolve=>{var every=testEvery||50,max=timeout,inx=0,called=null,test=()=>{try{return called||(called=fn()),isPromise(called)?called:fn()}catch(error){return isError(error)?{error}:isObject(error)?error.error?error:{error:error}:{error:error.toString()}}},t=setInterval(_asyncToGenerator(function*(){if(inx>=max)return resolve(void 0),clearInterval(t);var anon=test();if(isPromise(anon))try{var d=yield anon;return resolve(d),clearInterval(t)}catch(error){return isError(error)&&resolve({error}),isObject(error)?error.error?resolve(error):resolve({error}):resolve({error:error.toString()}),clearInterval(t)}return void 0===anon?void(inx+=every):(resolve(anon),clearInterval(t))}),every)}):Promise.reject(\"fn() must be callable\")},flatten=exports.flatten=function flatten(arr){return void 0===arr&&(arr=[]),isArray(arr)?[].concat(...arr):[]},flattenDeep=exports.flattenDeep=function flattenDeep(arr){function test(arr,d){return void 0===d&&(d=1),0<d?arr.reduce((acc,val)=>acc.concat(Array.isArray(val)?test(val,d-1):val),[]):arr.slice()}return void 0===arr&&(arr=[]),isArray(arr)?test(arr,1/0):[]},chunks=exports.chunks=(arr,size)=>Array.from({length:Math.ceil(arr.length/size)},(v,i)=>arr.slice(i*size,i*size+size));exports.uniq=uniq,exports.isPromise=isPromise,exports.debug=function debug(){if(loggingON()&&\"off\"!==checkLoggerSetting(\"debug\")){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return logConstract(\"debug\",args)}},exports.log=function log(){if(loggingON()&&\"off\"!==checkLoggerSetting(\"log\")){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return logConstract(\"log\",args)}},exports.warn=function warn(){if(loggingON()&&\"off\"!==checkLoggerSetting(\"warn\")){for(var _len3=arguments.length,args=Array(_len3),_key3=0;_key3<_len3;_key3++)args[_key3]=arguments[_key3];return logConstract(\"warn\",args)}},exports.onerror=error,exports.error=error,exports.alert=function alert(){if(loggingON()&&\"off\"!==checkLoggerSetting(\"alert\")){for(var _len4=arguments.length,args=Array(_len4),_key4=0;_key4<_len4;_key4++)args[_key4]=arguments[_key4];return logConstract(\"alert\",args)}},exports.attention=function attention(){if(loggingON()&&\"off\"!==checkLoggerSetting(\"attention\")){for(var _len5=arguments.length,args=Array(_len5),_key5=0;_key5<_len5;_key5++)args[_key5]=arguments[_key5];return logConstract(\"attention\",args)}},exports.isObject=isObject,exports.isFalsy=isFalsy,exports.isError=isError,exports.typeCheck=typeCheck,exports.validDate=dt=>{try{return!(dt.__proto__!==Date.prototype||\"Invalid Date\"===dt.toString())}catch(err){return!1}},exports.isInstance=obj=>!!obj&&!isArray(obj)&&!!(obj.__proto__&&!isClass(obj)&&obj.__proto__.__proto__&&obj.__proto__.__proto__===Object.prototype&&obj instanceof Object),exports.isClass=isClass,exports.isArray=isArray,exports.dupes=(item,index)=>{for(var dups=[],n=parseInt(index);0<n;)n--,dups.push(item);return dups};exports.notify=function notify(logData,err){throw void 0===logData&&(logData=null),void 0===err&&(err=null),\"no notify support for x-utils-es, use: x-utils\"}});\n","\r\n/**\r\n * requirejs global event handler\r\n */\r\nmodule.exports = function (_uid, _debug = null) {\r\n    return (new function (uid, debug) {\r\n        const plugin = `[dispatcher]`\r\n        this.uid = (uid || '').toString() || new Date().getTime()\r\n        this.debug = debug\r\n        this.cbQueue = {}\r\n        this.dispatchInstance = {}\r\n\r\n        this.initListener = () => {\r\n            this.Dispatch()\r\n            return this\r\n        }\r\n        /**\r\n         * @next\r\n         * send next data to the `batchReady` callback\r\n         * @param {*} data # optional\r\n         */\r\n        this.next = (data = null) => {\r\n            if (this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid].next(data)\r\n            else {\r\n                if (this.debug) console.log({ message: `${plugin} for uid not available`, uid: this.uid })\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * @Dispatch\r\n         * master listener, sends all event callbacks to `batchReady`\r\n         */\r\n        this.Dispatch = () => {\r\n            if (this.dispatchInstance[this.uid]) return this\r\n            const self = this\r\n            const D = function () {\r\n                this.uid = self.uid\r\n                this.data = null\r\n\r\n                this.next = (data) => {\r\n                    if ((data || {}).type !== 'cb') this.data = data\r\n                    /**\r\n                         * @next\r\n                         * acts as a reverse callback, it sends back the `cb` from `batchReady`\r\n                         */\r\n                    if ((data || {}).type === 'cb') {\r\n                        if (typeof data.cb === 'function') {\r\n                            // when calling next before batchReady is initiated\r\n                            // collect cb from .next\r\n                            if (!self.cbQueue[self.uid]) self.cbQueue[self.uid] = data.cb\r\n                            if (this.data) data.cb.call(self, this.data, self.uid)\r\n                        }\r\n\r\n                        return\r\n                    }\r\n\r\n                    if (this.data) {\r\n                        if (typeof self.cbQueue[self.uid] === 'function') self.cbQueue[self.uid].call(self, this.data, self.uid)\r\n                    } else {\r\n                        if (this.debug) console.log(`${plugin} no callback data`)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid] = new D()\r\n            return this\r\n        }\r\n\r\n        this.isActive = () => {\r\n            return !!this.dispatchInstance[this.uid]\r\n        }\r\n\r\n        this.del = () => {\r\n            delete this.cbQueue[this.uid]\r\n            delete this.dispatchInstance[this.uid]\r\n\r\n            if (!this.cbQueue[this.uid] && !this.dispatchInstance[this.uid]) {\r\n                // if (this.debug) console.log(`cbQueue and dispatchInstance for uid ${this.uid} deleted`)\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n     * @subscribe\r\n     * wait for callbacks forwarded from Dispatch and returned in callback of this method\r\n     * - Dispatch must be set initially before you call `subscribe`\r\n     * @param {*} cb #required\r\n     */\r\n        this.subscribe = (cb) => {\r\n            const isFN = typeof cb === 'function'\r\n            if (!isFN) {\r\n                if (this.debug) console.log(`${plugin}[batchReady] cb must be set`)\r\n                return this\r\n            }\r\n            if (!this.dispatchInstance[this.uid]) {\r\n                // this means batchReady was executed prior to `Dispatch`, because it has forward with next\r\n                // it will get executed anyway\r\n                this.Dispatch()\r\n            }\r\n            if (this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid].next({ type: 'cb', cb })\r\n            return this\r\n        }\r\n    }(_uid, _debug))\r\n}\r\n","module.exports = require('./simple-q')","/* eslint-disable no-undef */\r\n// for es2015/ or below browser loading\r\nwindow.Pocket = () => require('../Pocket.module').PocketModule()\r\n","exports.PocketModule = () => {\r\n    // const messageCODE = require('./errors') // DISPLAY MESSAGES WITH CODE\r\n\r\n    const { objectSize, log, onerror, warn, isArray, isObject, isPromise, validID, isString } = require('x-utils-es/umd')\r\n    const sq = require('simple-q') // nice and simple promise/defer by `eaglex.net`\r\n    const PocketLibs = require('./Pocket.libs')()\r\n    const newProbe = require('./Probe').Probe\r\n\r\n    /**\r\n     * TODO ADD to $update `// action/[merge], action/+-*` using regEx\r\n     */\r\n\r\n    class PocketModule extends PocketLibs {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n            if (this.dispatcher) {\r\n                this.dispatcher.initListener().subscribe((z, id) => {\r\n                    const { probe, status } = z || {}\r\n\r\n                    if (status === 'error') {\r\n                        // NOTE dispatch data out\r\n                        if (this.debug) log('[pocket]', `[dispatcher] probe id:${probe.id} error`)\r\n                    }\r\n\r\n                    if (status === 'open') {\r\n                        if (this.debug) log('[pocket]'`[dispatcher] probe id:${probe.id} created`)\r\n                    }\r\n\r\n                    if (status === 'complete') {\r\n                        // NOTE dispatch data out\r\n                        if (this.debug) log('[pocket]', `[dispatcher] probe id:${probe.id} completed`)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        // \r\n        //   :::::: U S E R   A P P L I C A T I O N   C A L L I N G   M E T H O D S : :  :   :    : \r\n        // \r\n        //\r\n\r\n        /**\r\n         * @memberof $payload\r\n         */\r\n        payload(data = {}, async, type = 'new') {\r\n            this.d = null\r\n            let isUpdated = null\r\n\r\n            // validate payload format\r\n            if (!isObject(data)) return false\r\n\r\n            const keys = Object.keys(data)\r\n            // must match all keys\r\n            if (keys.every(el => ['id', 'tasks'].indexOf(el) === -1)) {\r\n                if (this.debug) onerror('[pocket]', `[$payload] id and tasks are required`)\r\n                return false\r\n            }\r\n            if (!isArray(data['tasks'])) {\r\n                if (this.debug) onerror('[pocket]', `[$payload] data.tasks must be an array`)\r\n                return false\r\n            }\r\n\r\n            data.id = this.validProjectID(data.id)\r\n\r\n            if (!data.id) {\r\n                if (this.debug) onerror('[pocket]', `[$payload] data.id invalid`)\r\n                return false\r\n            }\r\n\r\n            if (this.payloadData[data.id] && (!type || type === 'new')) {\r\n                this._lastProjectID = data.id\r\n                // if (this.debug) warn(`[$payload] this payload.id already exists`)\r\n                return true\r\n            }\r\n\r\n            let initialProject = this.payloadData[data.id] === undefined // because there is no data set as of yet\r\n\r\n            // NOTE on update/new of project we need to reset $filter values, in case \r\n            if ((this._lastFilterList[data.id] || []).length) this._lastFilterList[data.id] = []\r\n\r\n            // NOTE validate our pocket values before generating each `new Probe()`\r\n            for (let val of data['tasks'].values()) {\r\n                if (!val['task']) {\r\n                    if (this.debug) warn('[pocket]', '[$payload] task must be set for your tasks')\r\n                    continue\r\n                }\r\n                // validate task \r\n                if (!this.idRegexValid(val['task']) || val['task'].indexOf('::') !== -1) {\r\n                    if (this.debug) warn('[pocket]', '[$payload] invalid taskName, failed idRegexValid validation')\r\n                    continue\r\n                }\r\n                \r\n                const probeID = `${data.id}::${val['task']}`\r\n                if (type === 'update' && !initialProject && this.pocket[probeID]) {\r\n                    if (val['data']) this.pocket[probeID]['data'] = val['data']    \r\n                    if (val['status']) this.pocket[probeID]['status'] = val['status']    \r\n\r\n                    // NOTE in case we update status in case it wasnt provided but new data was assigned\r\n                    // status should only be changed after data is set\r\n                    if (!val['status'] && val['data'] && this.pocket[probeID]['status'] === 'open') {\r\n                        this.pocket[probeID]['status'] = 'updated'\r\n                    }\r\n                    if (val['ref']) this.pocket[probeID]['ref'] = val['ref']\r\n                    if (val['error']) this.pocket[probeID]['error'] = val['error']\r\n                    if (val['campaign']) this.pocket[probeID]['campaign'] = val['campaign']\r\n                    \r\n                    isUpdated = true\r\n                    this._lastProjectID = data.id\r\n                    // NOTE after update, payloadData will differ from new Probe{} data\r\n                    // NOTE do not update `payloadData` it is redundant if we donot need it for anything, only update Probes{}\r\n                    /// this.payloadData[data.id]['value']\r\n                    // an existing project do not everride\r\n\r\n                    continue\r\n                }\r\n\r\n                if (!this.payloadData[data.id]) this.payloadData[data.id] = { value: [], status: 'open', timestamp: new Date().getTime() }\r\n                const exists = this.payloadData[data.id]['value'].filter(z => z.task.indexOf(val.task) !== -1)\r\n                if (exists.length) {\r\n                    if (this.debug && !this.disableWarnings) warn('[pocket]', `the same task \"${val.task}\" already exists on the payload, you must choose uniq`)\r\n                    continue\r\n                }\r\n\r\n                this.payloadData[data.id]['value'].push(val)\r\n                this.lastPocketTimestamp = this.payloadData[data.id]['timestamp']\r\n            }\r\n\r\n            // only when updating existance of Probe{}\r\n            if (type === 'update' && this.payloadData[data.id] && !initialProject) {\r\n                this.projectsCache[data.id] = 'open'\r\n                return isUpdated\r\n            }\r\n\r\n            if (this.payloadData[data.id]) {\r\n                this.lastProjectID(data.id)\r\n                this.projectsCache[data.id] = 'open' // means created project\r\n                this.distributor()\r\n                    .setDefer(data.id)\r\n                // NOTE required in order for $projectSetAsync to retrun callback to resolve our promise\r\n                this.projectSetDispatcher(data.id).initListener().next({ projectID: data.id })\r\n                return true\r\n            } else return false\r\n        }\r\n\r\n        /**\r\n         * ### $projectSetAsync\r\n         * - usage: to call before `$project()/$payload()/$architect` were called\r\n         * - for example you have loaded same `Pocket` instance in another part of your code, now checking for it  in future before $project created. This method can `await $projectSetAsync(projectID)` and continue with already set `$project(...).$get(..).$update(..)` etc\r\n         * @param {*} projectID required, this is your `$project/$payload` id\r\n         */\r\n        $projectSetAsync(projectID = '') {\r\n            const self = this\r\n            projectID = this.lastProjectID(projectID, false, null)\r\n            if (this._projectSetAsync[projectID]) {\r\n                return this._projectSetAsync[projectID].promise()\r\n            }\r\n            /**\r\n             * will subscribe when called the first time and set our simple promise then resolve once the `$payload` is succesfull\r\n             */\r\n            this._projectSetAsync[projectID] = sq()\r\n            this.projectSetDispatcher(projectID).initListener().subscribe(function (z, id) {\r\n                self._projectSetAsync[id].resolve(z)\r\n                this.del() // deletes projectSetDispatcher of self \r\n            })\r\n            return this._projectSetAsync[projectID].promise()\r\n        }\r\n\r\n        /**\r\n         * @memberof probeStatusAsync\r\n         */\r\n        probeStatusAsync(probeID = '') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            probeID = this.lastProbeID(probeID)\r\n            if (!probeID) return returnAs(null)\r\n            return returnAs(this.pocket[probeID].getStatusAsync)\r\n        }\r\n\r\n        /**\r\n         * @memberof $update\r\n         */\r\n        update(dataFrom, mergeData = null, probeID = '') {\r\n            return this._setUpdate(dataFrom, mergeData, probeID, 'update')\r\n        }\r\n\r\n        /**\r\n         * @memberof $set\r\n         */\r\n        _set(dataFrom, probeID = '') {\r\n            return this._setUpdate(dataFrom, null, probeID, 'set')\r\n        }\r\n\r\n        /**\r\n         * - declated via $get\r\n         * @memberof $get\r\n         */\r\n        _get(probeID = '', self = false) {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return self ? this : this.d\r\n            }\r\n\r\n            this.d = null\r\n            probeID = this.lastProbeID(probeID)\r\n            if (!probeID) return returnAs(null)\r\n            else return returnAs(this.pocket[probeID])\r\n        }\r\n\r\n        /**\r\n         * ### $activeTasks\r\n         * - list any active tasks for assigned Probes\r\n         * @param {*} payloadID optional, when set will only filter thru given job id (NOT Probe{} ID!)\r\n         */\r\n        $activeTasks(payloadID = '') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            payloadID = this.lastProjectID(payloadID)\r\n            if (!objectSize(this.pocket)) return returnAs([])\r\n            let tasks = Object.entries(this.pocket).reduce((n, [probeID, probe]) => {\r\n                if (probeID.indexOf(payloadID || '') === 0 && payloadID && this.payloadData[payloadID]) n.push(probe['task'])\r\n                else if (!payloadID) n.push(probe['task'])\r\n                return n\r\n            }, [])\r\n            return returnAs(tasks)\r\n        }\r\n\r\n        /**\r\n         * @memberof $ready\r\n         */\r\n        ready(payloadID = '') {\r\n            this.d = null\r\n\r\n            if (!this._ready[payloadID]) throw (`ready[payloadID] is not set, maybe you called it before $payload()`)\r\n            return this._ready[payloadID].promise()\r\n        }\r\n\r\n        //\r\n        // \r\n        //   :::::: E N D : :  :   :    :     :        :          \r\n        //   \r\n\r\n        // extends  `$update` and `$set`\r\n        _setUpdate(dataFrom, mergeData = null, probeID = '', type = 'update') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            let id = this.lastProbeID(probeID)\r\n            if (!id) {\r\n                if (this.debug) onerror('[pocket]', `[$update] must specify id`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            if (!isObject(dataFrom)) {\r\n                if (this.debug) warn('[pocket]', `[$update] dataFrom must be an Object`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            if (!this.pocket[id]) {\r\n                if (this.debug) onerror('[pocket]', `[$update] this.pocket with id:${id} not found`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            let updated = false\r\n            this._lastProjectID = id\r\n            // reorder dataFrom, make sure if `status` exists, it is shifted to last position, so the Probe{} doent change state before other values got chance to do so, nice!\r\n\r\n            // we need to convert dataFrom{} to dataFrom[]>array to achieve this\r\n            dataFrom = Object.entries(dataFrom).reduce((n, [key, value]) => {\r\n                const pos = this.probeProps.indexOf(key) // new order\r\n                if (this.probeProps[pos] === key) n.push({ inx: pos, data: { [key]: value } })\r\n                return n\r\n            }, [])\r\n\r\n            for (let inx = 0; inx < dataFrom.length; inx++) {\r\n                if ((dataFrom[inx] || {})['data'] === undefined) continue\r\n                const [key, value] = Object.entries(dataFrom[inx]['data'])[0]\r\n                if (this.pocket[id][key] !== undefined) {\r\n                    if (key === 'data') {\r\n                        if (mergeData === true) this.pocket[id][key] = Object.assign({}, this.pocket[id][key], value)\r\n                        else this.pocket[id][key] = value\r\n                    } if (key === 'status' || key === 'ref' || key === 'error' || key === 'campaign') this.pocket[id][key] = value\r\n                    updated = true\r\n                    continue\r\n                } else {\r\n                    if (this.debug) warn('[pocket]', `[$update] not a valid prop/value: { ${key}:${this.pocket[id][key]} }`)\r\n                }\r\n            }\r\n            // when setting new data, using `$set()` we should clear any cached Probes and realated data\r\n            if (updated && type === 'set') {\r\n                this.clearStoreTransfers(id)\r\n                if (this.$transfer_lastID === id) this.$transfer_lastID = ''\r\n                if (this._$cached_data[id]) delete this._$cached_data[id]\r\n            }\r\n\r\n            // if(updated && type==='update') { }\r\n            return returnAs(updated)\r\n        }\r\n\r\n        /**\r\n         * - sets defer for `$ready()` initially after calling payload \r\n         * @param {*} id required\r\n         */\r\n        setDefer(id) {\r\n            id = validID(id)\r\n            if (!id) throw 'id must be set'\r\n\r\n            if (!this._ready[id]) this._ready[id] = sq()\r\n\r\n            if (!objectSize(this.pocket)) {\r\n                const msg = `[setDefer] probe is empty, so nothing set, id:${id}`\r\n                if (this.debug) onerror('[pocket]', msg)\r\n                this._ready[id].reject(msg)\r\n                return null\r\n            }\r\n\r\n            const pocketSet = Object.values(this.pocket).filter(z => z.id.indexOf(id) !== -1)\r\n            if (!pocketSet.length) {\r\n                const msg = `[setDefer] no pocketSet found for id:${id} `\r\n                if (this.debug) onerror('[pocket]', msg)\r\n                this._ready[id].reject(msg)\r\n                return null\r\n            }\r\n\r\n            try {\r\n                const userOutput = (pock) => {\r\n                    const output = {}\r\n                    if (!isObject(pock)) return null\r\n                    for (let i = 0; i < this.probeProps.length; i++) {\r\n                        const prop = this.probeProps[i]\r\n                        if (pock[prop] !== undefined && pock[prop] !== null) output[prop] = pock[prop]\r\n                    }\r\n                    return output\r\n                }\r\n                /**\r\n                 * IMPORTANT:\r\n                 * when our pocketSet for each this.pocket[id] is marked 'complete'\r\n                 * `Probe().resolve(...)` is called, and Promise.all is waiting for `pocketSet` to complete\r\n                 */\r\n                Promise.all(pocketSet.map(z => z.sq.promise())).then(z => {\r\n                    const output = z.map(p => userOutput(p.probe)).filter(n => !!n)\r\n                    this._ready[id].resolve(output)\r\n                }, err => {\r\n                    // should unlikely happen since we dont have any rejects set\r\n                    onerror('[pocket]', `[setDefer] Promise.all`, err)\r\n                })\r\n\r\n                return true\r\n            } catch (err) {\r\n                onerror('[pocket]', `[setDefer]`, err)\r\n            }\r\n\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * - distribute payloadData, each to `new Probe()`\r\n         */\r\n        distributor() {\r\n            for (let [key, el] of Object.entries(this.payloadData)) {\r\n                if (this.lastPocketTimestamp > el['timestamp']) continue // no new entries\r\n\r\n                // omit done\r\n                if (el.status === 'complete' || el.status === 'send' || el.status === 'error') continue\r\n\r\n                for (let value of el.value.values()) {\r\n                    const pl = { id: key, ...value }\r\n                    const pocketSet = this.setProbe(pl)\r\n                    if (!pocketSet) onerror('[pocket]', `probe for id:${key} already exists`)\r\n                }\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - every new probe `id` must be: format `id:::taskName`\r\n         * required: `{id,task}`\r\n         * optional: `{campaign}`\r\n         * @param {*} opts\r\n         */\r\n        setProbe(opts = {}) {\r\n            if (!opts.id || !opts.task) throw ('id and task both must be set')\r\n            if (!validID(opts.id)) throw ('opts.id not valid')\r\n\r\n            const uid = `${opts.id}::${opts.task}`\r\n            if (this.pocket[uid]) {\r\n                if (this.debug) log('[pocket]', `[setProbe] probe: ${uid} already set`)\r\n                return null\r\n            }\r\n            try {\r\n                opts.id = uid\r\n                const emitter = this.dispatcher !== null ? this._emit.bind(this) : null\r\n                const p = new this.Probe(opts, {\r\n                    disableWarnings: this.disableWarnings, // disable some less relevant warning messages\r\n                    onChange: this._onChange, \r\n                    emitter, \r\n                    completeOnNull: this.completeOnNull }, this.debug)\r\n                this.pocket[uid] = p\r\n            } catch (err) {\r\n                onerror('[pocket]', err)\r\n                return null\r\n            }\r\n            return this.pocket[uid]\r\n        }\r\n\r\n        /**\r\n         * set new probe model\r\n         * - every new task has a set of requirements. Once status is `complete` and data available, probe sends a dispatch with probe information `(if opts.dispatcher===true)`.\r\n         * methods:`{get,all}` props: `{id,data,task,status,campaign}`\r\n         * \r\n         *  @param {*} opts.id required\r\n         *  @param {*} opts.task required\r\n         *  @param {*} opts.campaign optional\r\n         * \r\n         * - `Probe` is resolved once `sq.resolve()` is called, sq => `Simple Q` our plugin\r\n         * @memberof Probe.js module\r\n         */\r\n        get Probe() {\r\n            return newProbe()\r\n        }\r\n\r\n        /**\r\n         * - emit extends with `Dispatcher` to be used by every new Probe{} as an emitter `(if opts.dispatcher===true)`\r\n         * @param {*} obj required\r\n         */\r\n        _emit(obj) {\r\n            if (!obj) return null\r\n            if (!this.dispatcher) return null\r\n            try {\r\n                this.dispatcher.initListener().next(obj)\r\n                return true\r\n            } catch (err) {\r\n                onerror('[pocket]', `[_emit] dispatcher did not emit`)\r\n                return null\r\n            }\r\n        }\r\n\r\n        /**\r\n         * - delete completed `pocketSet`\r\n         */\r\n        deletePocketSet(id) {\r\n            if (!id) return\r\n            if (Object.values(this.pocket).length) {\r\n                for (let poc of Object.values(this.pocket)) {\r\n                    if (this._$cached_data[poc.id]) delete this._$cached_data[poc.id]\r\n                    if (poc.id.includes(id)) delete this.pocket[poc.id]\r\n                }\r\n            }\r\n            if (this.payloadData[id]) delete this.payloadData[id]\r\n            if (this._ready[id]) delete this._ready[id]\r\n\r\n            // these  two are together\r\n            if (this._projectSetDispatcher[id] !== undefined) delete this._projectSetDispatcher[id]\r\n            if (this._projectSetAsync[id]) delete this._projectSetAsync[id]\r\n            if (this._lastFilterList[id]) delete this._lastFilterList[id]\r\n\r\n            // from PocketArchitect dynamicly assigned\r\n            try {\r\n                if (this.architectConfig[id]) delete this.architectConfig[id]\r\n            } catch (err) {\r\n                // blah\r\n            }\r\n\r\n            // empty self\r\n            this.clearStoreTransfers(id)\r\n        }\r\n    }\r\n\r\n    class PocketModuleExt extends PocketModule {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n        }\r\n\r\n        /**\r\n         * ### $removeProject\r\n         * - removes all Probes and references relating to `projectID`\r\n         * @param {*} projectID \r\n         */\r\n        $removeProject(projectID) {\r\n            projectID = !isString(projectID) ? '' : projectID\r\n            projectID = this.lastProjectID(projectID) // also updates last selector reference\r\n            this.deletePocketSet(projectID)\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - you can also use it on concurent payloads to existing `projectID`, once initial project is created overy other call will update each Probe{}.data/status, based on payloadData\r\n         * @param {*} data `required`\r\n         * @param {*} async `override current opts.sync for this payload`\r\n         * @param {*} type optional, new/update, `update`: if we call on an existing project we can update `data/status properties` of all assigned tasks at once\r\n         * \r\n         * - `initialize new payload, for as many tasks`\r\n         * - `sets a multi task with instructions:`\r\n         * - `data = {\r\n                id: '', // 1 id for all tasks\r\n                tasks: [{ taskName: '', data: '', campaign: '' }]\r\n            }`\r\n\r\n         * - `call distributor and setDefer`\r\n         * @extends payload\r\n         */\r\n        $payload(data, async, type) {\r\n\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n            const asAsync = async !== undefined ? async : this.async // override if set\r\n            if (asAsync && isPromise(data)) return returnAs(data.then(z => this.payload(z, false, type), err => err))\r\n            if (!asAsync && !isPromise(data)) return returnAs(this.payload(data, false, type))\r\n            else {\r\n                if (this.debug) onerror('[pocket]', `[payload] with opts.async=true, data must be a promise, or do not set async when not a promise`)\r\n                if (asAsync) return returnAs(Promise.reject())\r\n                else return returnAs(false)\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $project\r\n         * - `an alias on $payload(...), can use either`\r\n         * - refer to `$payload` for specifications :)\r\n         * @extends $payload\r\n         */\r\n        $project(...args) {\r\n            return this.$payload(...args)\r\n        }\r\n\r\n        /**\r\n          * - resolves currently active `$payload(...)`\r\n          * - `after completion of Pocket, instance data for all Probes is deleted`\r\n          * - can be called even before project was declared thanks to callback dispather `$projectSetAsync()`\r\n          * @param {*} payloadID ,required\r\n          * @param allowsMultiple optional, when set to true will allow multiple calls to resolved data\r\n          * @extends ready\r\n          */\r\n        $ready(payloadID, allowsMultiple = false) {\r\n\r\n            try {\r\n\r\n                const returnAs = (val) => {\r\n                    this.d = val\r\n                    if (this.d && !allowsMultiple) {\r\n                        \r\n                        this.d.catch((err) => {\r\n                            if (!this.disableWarnings) warn('[pocket]', err)\r\n                        })\r\n                    }\r\n                    return this\r\n                }\r\n\r\n                // sofl validation for non existant `payloadID` if called before declaration of a project\r\n                let _payloadID = this.lastProjectID(payloadID, false, null)\r\n                if (!payloadID && _payloadID) payloadID = _payloadID // grab last assigned id incase provided none\r\n\r\n                // in case it was called the second time, when already resolved!\r\n                if (this.projectsCache[payloadID] === 'complete' && !allowsMultiple) {\r\n                    return returnAs(Promise.reject(`[$ready] project: ${payloadID} already complete`))\r\n                }\r\n\r\n                if (this._ready_method_set[payloadID] !== undefined && !allowsMultiple) {\r\n                    if (this._ready_method_set[payloadID] === true) {\r\n                        return returnAs(Promise.reject(`[$ready] project: ${payloadID} already complete, cannot recall same $ready, ALLOW_MULTIPLE_FALSE`))\r\n                    }\r\n                    if (this._ready_method_set[payloadID] === false) {\r\n                        return returnAs(Promise.reject(`[$ready] project: ${payloadID} you already declared $ready somewhere else, this call is ignored, ALLOW_MULTIPLE_FALSE`))\r\n                    }\r\n                }\r\n\r\n                if (!_payloadID) throw (`payloadID must be set`)\r\n\r\n                // we wrap it if on ready project so it allows declaring `${$ready()}` even before $project was created, cool ha!\r\n                const p = this.$projectSetAsync(_payloadID).then(({ projectID }) => {\r\n                    return this.ready(projectID).then(z => {\r\n\r\n                        // NOTE to help problems with loops and using chaining with last selector\r\n                        // will gradualy delete project with specified timeout\r\n                        if (!this.deleteWithDelay) this.deletePocketSet(projectID)\r\n                        else {\r\n                            setTimeout(() => {\r\n                                this.deletePocketSet(projectID)\r\n                            }, this.deleteWithDelay)\r\n                        }\r\n\r\n                        this.projectsCache[projectID] = 'complete'\r\n                        this._ready_method_set[_payloadID] = true\r\n\r\n                        return z\r\n                    }, Promise.reject)\r\n                    \r\n                }, Promise.reject)\r\n\r\n                this._ready_method_set[_payloadID] = false\r\n                return returnAs(p)\r\n\r\n            } catch (error) {\r\n                if (!this.disableWarnings) onerror('[pocket]', error)\r\n                \r\n            }\r\n        }\r\n    }\r\n    const PocketArchitect = require('./Pocket.architect')(PocketModuleExt)\r\n    const PocketSelectors = require('./Pocket.selectors')(PocketArchitect)\r\n    return PocketSelectors\r\n}\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","`use strict`\r\n/**\r\n * SimpleQ\r\n * Developer: Eaglex ( http://eaglex.net ) \r\n * License: CC BY-SA ( https://creativecommons.org/licenses/by/4.0/legalcode )\r\n * - Simple Promise defer\r\n */\r\nfunction SimpleQ() {\r\n    \r\n    return new function() {\r\n        const promises = {}     \r\n        let __deferSet = null   \r\n        const defer =  new Promise((resolve, reject) => {\r\n            promises['resolve']= resolve      \r\n            promises['reject']= reject     \r\n        })\r\n\r\n        this.resolve = (data = null) => {\r\n            if (__deferSet) return this // already set\r\n            promises['resolve'](data)\r\n            __deferSet = true\r\n            return this\r\n        }\r\n\r\n        this.reject = (data = null) => {\r\n            if (__deferSet) return this // already set\r\n            promises['reject'](data)\r\n           __deferSet = true\r\n            return this\r\n        }\r\n\r\n        this.promise = () =>  defer     \r\n    }\r\n}\r\n\r\nmodule.exports = SimpleQ","/**\r\n * ### PocketLibs\r\n * - Top of the stack class of `PocketModule`, all `opt` initial `properties` are set here\r\n */\r\nmodule.exports = () => {\r\n    const { objectSize, warn, onerror, validID, copy, log, isString } = require('x-utils-es/umd')\r\n    return class PocketLibs {\r\n        /**\r\n         * @param {*} opts.async, when set, allow $payload(`data`) to be async object\r\n         * @param {*} opts.dispatcher, when set to true, loads external library `Dispatcher`\r\n         * @param {*} debug optional\r\n         */\r\n        constructor(opts = {}, debug) {\r\n            this.debug = debug || false\r\n            this.async = (opts || {}).async || null\r\n            this._onChange = (opts || {}).onChange || null // loads watch for changes Probe asset \r\n            this.completeOnNull = (opts || {}).completeOnNull || null // Allow Probe to complete even if data is null\r\n            this.disableWarnings = (opts || {}).disableWarnings // disable some less relevant warning messages\r\n\r\n            // when set enables dispatcher to communicate directly with `probe.js`\r\n            this.dispatcher = (opts || {}).dispatcher ? require('../libs/dispatcher')() : null\r\n            this.pocket = {} // example this.pocket[`abc::taskName`] returns Probe{} Instance\r\n            this.payloadData = {}// each payload by id\r\n            this.lastPocketTimestamp = 0\r\n            this._lastProjectID = null // last cached reference\r\n            this._lastProbeID = null // last cached reference\r\n            this._$cached_data = {/** id:{} */ }// stores last captured data when calling `$data(..)`\r\n            this.$transfer_lastID = '' // set when we call `$transfer()` and reset after `$to()`\r\n            this._ready = {} // collect all ready example: `{id:Promise}`\r\n            this._ready_method_set = {/** [id]:true */}// ignore subsequent calls to $ready method \r\n            this.d = undefined // NOTE user reference data, carefull when using selectors from previous target, always access last\r\n            this._projectSet = {/** projectID:promise */ }\r\n            this._transferCached = [ /** {timestamp,fromProbeID,data} */]\r\n            this._projectSetDispatcher = {/** id:dispatcher */ }\r\n            this._projectSetAsync = {/** id:SQ */ } // collect all $projectSetAsync promisses\r\n            this._lastFilterList = {/** id:[probe references only] */ }\r\n            this.projectsCache = {/** [id]:'open/complete' */}// keep reference of completed projects, this variable is never purged\r\n            this.deleteWithDelay = (opts || {}).deleteWithDelay || 1000// after project is completed and $ready(..) is resolved set delay to when it should be deleted\r\n            // this.createArchitect() // only when pocketInstance is set\r\n        }\r\n\r\n        // NOTE abolished functional class, doesnt work well with es6 class\r\n        // createArchitect() {\r\n        //     if (this.architect && !this[\"architect_set\"]) {\r\n        //         try {\r\n        //             const Architect = require('./Pocket.architect')()\r\n        //             Architect.prototype = Object.create(this)\r\n        //             Architect.prototype.constructor = Architect             \r\n        //             Object.assign(this, new Architect())\r\n        //         } catch (err) {\r\n        //             console.log(`[createArchitect] error`, err)\r\n        //         }\r\n\r\n        //         this[\"architect_set\"] = true\r\n        //     }\r\n        // }\r\n\r\n        /**\r\n         * - return latest Probe by reference from `this._lastFilterList[projectID]`\r\n         * @param {*} projectID \r\n         */\r\n        // getProbesByFilterRef(projectID) {\r\n        //     if (!projectID) return []\r\n        //     if (!this._lastFilterList[projectID]) return []\r\n        //     return this._lastFilterList[projectID].reduce((n, ref, inx) => {\r\n        //         if (ref.id && ref.isNONE === undefined && this.pocket[ref.id]) n.push(this.pocket[ref.id])\r\n        //         else if (this.pocket[ref.id]) n.push({ id: ref.id, isNONE: true })\r\n        //         return n\r\n        //     }, []).filter(z => !!z)\r\n        // }\r\n\r\n        /**\r\n         * ### projectSetDispatcher\r\n         * - create new dispather to act as a callback for setting new projects in future. NOTE once project is created and using $architect /$project/$payload to update will not recreate `projectSetDispatcher`\r\n         * - works with `$projectSetAsync`\r\n         * @param {*} projectID \r\n         */\r\n        projectSetDispatcher(projectID) {\r\n            if (!projectID) {\r\n                if (this.debug) onerror(`[projectSetDispatcher] projectID must be set`)\r\n                return null\r\n            }\r\n            if (this._projectSetDispatcher[projectID]) return this._projectSetDispatcher[projectID]\r\n            if (!this._projectSetDispatcher[projectID]) this._projectSetDispatcher[projectID] = require('../libs/dispatcher')(projectID)\r\n            return this._projectSetDispatcher[projectID]\r\n        }\r\n\r\n        /**\r\n         * @param {*} projectID\r\n         * @returns array [Probe{},...] of selected project\r\n         */\r\n        projectProbeList(projectID) {\r\n            if (!projectID) return []\r\n            return Object.entries(this.pocket).filter(([id]) => id.indexOf(projectID) === 0).map(([id, probe]) => probe)\r\n        }\r\n\r\n        /**\r\n         * ### clearStoreTransfers\r\n         * - clear any pending transfers\r\n         * @param {*} projectID required\r\n         */\r\n        clearStoreTransfers(projectID = '') {\r\n            if (!projectID) return\r\n            let cleared = false\r\n            if (this._transferCached.length) {\r\n                this._transferCached.forEach((element, i) => {\r\n                    const { fromProbeID } = element || {}\r\n                    if (!fromProbeID) return\r\n                    if (fromProbeID.indexOf(projectID) !== -1) {\r\n                        this._transferCached.splice(i, 1)\r\n                        cleared = true\r\n                        if (this.debug) log('[pocket]', `[clearStoreTransfers] transferCached for probeID: ${fromProbeID} has been removed`)\r\n                    }\r\n                })\r\n            }\r\n            return cleared\r\n        }\r\n        /**\r\n         * ### storeTransfers\r\n         * - caches pending transfers when using `$transfer` with `$to()`\r\n         * - access last data by timestamp\r\n         * @param {*} fromProbeID  required\r\n         * @param {*} data required\r\n         */\r\n        storeTransfers(fromProbeID, data) {\r\n            this._transferCached.push({ timestamp: new Date().getTime(), fromProbeID, data })\r\n            return this._transferCached\r\n        }\r\n\r\n        /**\r\n         * ### accessLastValidTransfer\r\n         * returns latest transfer that is inRange from `fromAverageTimeHasPast` in `ms` vs current Date.getTime\r\n         * - removes _transferCached that was found \r\n         */\r\n        accessLastValidTransfer(fromAverageTimeHasPast = 100) {\r\n            if (!this._transferCached.length) return {}\r\n\r\n            this._transferCached.sort((a, b) => a.timestamp - b.timestamp)\r\n            const transferCachedCopy = copy(this._transferCached)\r\n\r\n            const coundCache = transferCachedCopy.reduce((n, el, i) => {\r\n                const { timestamp } = el\r\n\r\n                // calculate max wait between transfers, so if we have timeout we can only wait as long as `fromAverageTimeHasPast` \r\n                const currentOffset = new Date().getTime() + fromAverageTimeHasPast\r\n                const diff = (currentOffset - timestamp) - fromAverageTimeHasPast\r\n                const timeInRange = (currentOffset > timestamp) && diff <= fromAverageTimeHasPast\r\n                if (timeInRange) {\r\n                    n = el\r\n                    // delete found cache\r\n                    this._transferCached.splice(i, 1)\r\n                }\r\n                return n\r\n            }, {})\r\n\r\n            if (!objectSize(coundCache)) return {}\r\n            else return coundCache\r\n        }\r\n\r\n        /**\r\n         * ### selectByTask\r\n         * - works with `PocketSelectors class`, when `::taskNames, taskName` are specified, extracts full probeID by matching previous pointer reference and updates `lastProbeID()`        \r\n         * - returns valid probeID or null\r\n         * @param {*} probeID {*} required, but optional\r\n         */\r\n        selectByTask(taskOrProbeID = '', updateLastProbeID = null) {\r\n            taskOrProbeID = !isString(taskOrProbeID) ? '' : taskOrProbeID\r\n            if (!this.idRegexValid(taskOrProbeID) && taskOrProbeID) return null\r\n            if (taskOrProbeID.indexOf(':') > 0 && !this.pocket[taskOrProbeID]) {\r\n                if (this.debug) warn('[pocket]', `[selectByTask] when using '::' prefix selector, it should come at 0 index`)\r\n                return null\r\n            }\r\n\r\n            if (taskOrProbeID.split(\":\").length > 3 || taskOrProbeID.split(\":\").length === 2) {\r\n                if (this.debug) warn('[pocket]', `[selectByTask] wrong taskName :${taskOrProbeID}, allowed prefix is '::taskName'`)\r\n                return null\r\n            }\r\n\r\n            if (updateLastProbeID) this.lastProbeID(taskOrProbeID, true) // if a match we receive below updated `_lastProbeID` \r\n            if (this.pocket[taskOrProbeID]) {\r\n                if (updateLastProbeID) this.lastProbeID(taskOrProbeID)\r\n                return taskOrProbeID // we have a valid ref so use that\r\n            }\r\n\r\n            /**\r\n             * - generate valid probeID `${projectID}::${probeTaskName}` //\r\n             */\r\n            const dynamicProbeID = (name) => {\r\n                const n = name.split(\"::\")[1] || name // in case we are using prefixed taskName, example \"::cocacola\"\r\n                const matchByProbeID = (this._lastProbeID || '').indexOf(n) > 0\r\n                if (matchByProbeID && n) return this._lastProbeID\r\n                else if (this._lastProjectID && n) return this._lastProjectID + `::` + n\r\n                return this._lastProbeID\r\n            }\r\n\r\n            const newProbeID = dynamicProbeID(taskOrProbeID)\r\n            if (!newProbeID) {\r\n                if (this.debug) warn('[pocket]', `[selectByTask] newProbeID was not found from taskOrProbeID: ${taskOrProbeID}`)\r\n            } else if (updateLastProbeID) this.lastProbeID(newProbeID)\r\n            return newProbeID\r\n        }\r\n\r\n        /**\r\n         * ### lastProjectID\r\n         * - every project is a job initiated by payload, so `payload.id === lastProjectID()`\r\n         * @param type strictly validate against scoped projecjID\r\n         */\r\n        lastProjectID(projectID = '', debug = null, type = 'strict') {\r\n            if (!projectID && this._lastProjectID) projectID = this._lastProjectID\r\n            if (projectID) projectID = this.validProjectID(projectID, debug)\r\n            if (projectID && this.payloadData[projectID]) this._lastProjectID = projectID\r\n            if (!this.payloadData[projectID] && type === 'strict') return null\r\n            if (!projectID) return null\r\n            if (projectID && !this._lastProjectID) this._lastProjectID = projectID\r\n            return projectID\r\n        }\r\n\r\n        /**\r\n         * ### lastProbeID\r\n         * - return last reference to probeID\r\n         * - cache with `_lastProbeID`\r\n         * @param {*} probeID \r\n         */\r\n        lastProbeID(probeID = '', debug = null) {\r\n            if (!probeID && this._lastProbeID) probeID = this._lastProbeID\r\n            if (probeID) probeID = this.validProbe(probeID, debug)\r\n            if (probeID && this.pocket[probeID]) this._lastProbeID = probeID\r\n            if (!probeID) return null\r\n            if (!this.pocket[probeID]) return null\r\n            return probeID\r\n        }\r\n\r\n        /**\r\n         * ### validProjectID\r\n         * - `test if projectID is valid`\r\n         * - return valid id\r\n         * @param {*} id required\r\n         */\r\n        validProjectID(id, debug = null) {\r\n            id = validID(id)\r\n            if (!id) return null\r\n            if ((id || '').split(' ').length > 1) return null\r\n            if (!this.idRegexValid(id)) return null\r\n            return id\r\n        }\r\n\r\n        /**\r\n         * ### validProbe\r\n         * - returns a valid probe\r\n         * @param {*} probeID required\r\n         */\r\n        validProbe(probeID, debug = null) {\r\n            probeID = validID(probeID)\r\n            if (!probeID) return null\r\n            if (!this.idRegexValid(probeID)) return\r\n            if (probeID.indexOf(`::`) === -1) return null\r\n            // if (!this.pocket[probeID]) {\r\n            //     if (this.debug && debug === null) warn('[pocket]',`[validProbe] did not find probe with probeID ${probeID}`)\r\n            //     return null\r\n            // }\r\n            return probeID\r\n        }\r\n\r\n        /**\r\n         * ### dataPropSelector\r\n         * - works with `$data()` and `$cached()` user selectors \r\n         * - refer to `PocketSelectors` module\r\n         * @param {*} probeID required\r\n         * @param {*} dataProp optional\r\n         * @param {*} self optional\r\n         * @param {*} probeData{} required our referencing probeData{}\r\n         */\r\n        dataPropSelector(type = 'data()', probeID = '', dataProp = {}, self = false, probeData = {}) {\r\n            let selectedData\r\n            /**\r\n             * NOTE if calling via `$cached()`,  `probeData` already comes as `this._$cached_data` so dont need to cache  it again!\r\n             */\r\n            try {\r\n                /**\r\n                  * NOTE IMPORTANT\r\n                  * assembly order: `dataProp < probeData > selectedData`\r\n                  * if are asking for multiple, example `selectedData:{a,b,value:1111}`, will return those available \r\n                  * as an Object{}. But if asking for only 1 `selectedData:{value:1111}`, will return the value `11111`, only because we know what we asked for initially\r\n                  */\r\n                selectedData = Object.entries(dataProp).reduce((n, [k, val], i) => {\r\n                    if (probeData[k] !== undefined) n[k] = probeData[k]\r\n                    return n\r\n                }, {})\r\n\r\n                if (!objectSize(selectedData)) selectedData = undefined\r\n\r\n                // selct only value if `dataProp` === `selectedData` is size ( 1 + 1 === 2 )\r\n                if (objectSize(selectedData) + objectSize(dataProp) === 2) selectedData = Object.values(selectedData).shift()\r\n\r\n                // if coming from `$data()` we cache our data \r\n                if (type === 'data()') this._$cached_data[probeID] = selectedData\r\n                return self ? this : selectedData\r\n            } catch (err) {\r\n                if (this.debug) warn('[pocket]', `[$data] no dataProp found on probeID: ${probeID}`)\r\n                if (type === 'data()') this._$cached_data[probeID] = selectedData\r\n                return self ? this : selectedData\r\n            }\r\n        }\r\n\r\n        idRegexValid(str) {\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(str)) {\r\n                // NOT ALWAYS NEEDED TO DISPLAY THE ERROR\r\n                // if (this.debug) onerror(`your id is invalid, allowed chars: ${pat}`)\r\n                return null\r\n            }\r\n            return true\r\n        }\r\n\r\n        /**\r\n         * ### probeProps\r\n         * - `each probe props that can be available and send on ready`\r\n         * - `order is important, keep 'status' last`\r\n         * - only updatable props are: `'campaign', 'data', 'error', 'ref', 'status'(limited)`\r\n         */\r\n        get probeProps() {\r\n            return ['campaign', 'data', 'task', 'ref', 'error', 'id', 'status']\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Set new probe model\r\n * - every new task has a set of requirements controlled by `statusStackOrder` in status setter. Once status is `complete` and data available, information is send and probe is blocked.\r\n * methods:`{get,all}` props: `{id,data,tasks,status}`\r\n */\r\nexports.Probe = () => {\r\n    // const messageCODE = require('./errors') // DISPLAY MESSAGES WITH CODE\r\n    const { isString, isArray, warn, log, isNumber, onerror, last, copy, isObject, isFunction } = require('x-utils-es/umd')\r\n    const sq = require('simple-q') // nice and simple promise/defer by `eaglex.net`\r\n    return class Probe {\r\n        /**\r\n         * @param {*} props.id required, case sensitive, all will be toLowerCase() \r\n         * @param {*} props.task once set cannot be changed\r\n         * @param {*} props.campaign optional, once set cannot be changed\r\n         * @param {*} props.data optional any value except undefind, cannot be change once status set to `complete` or send\r\n         * @param {*} props.status required to control Probe actions\r\n         * @param {*} opts.emitter optional, dispatcher/emmiter available if not null\r\n         * @param {*} opts.completeOnNull override complete setting even if data was never set\r\n         * @param {*} debug \r\n         */\r\n        constructor(props = {}, opts = {}, debug) {\r\n            this.debug = debug || false\r\n            if (isNumber(props.id) || props.id) props.id = props.id.toString()\r\n            if (!props.task || !isString(props.task)) throw ('task as string is required')\r\n            this._id = null\r\n            this._error = []\r\n            this._ref = null\r\n            this._task = null\r\n            this._status = null\r\n            this._data = null\r\n            this._campaign = null\r\n            this._dataIndex = 0\r\n            this._statusIndex = 0\r\n            this._statusAsync = [/** {timestamp:promise} */] // dynamic promise changer\r\n            this.task = props.task\r\n            this.id = props.id\r\n            this.status = 'open'\r\n            this._onChange = opts.onChange || null\r\n            this._onchangeDispatch = null // loads dispatcher when `opts.onChange=true` is set\r\n            this.emitter = opts.emitter || null\r\n            this.completeOnNull = opts.completeOnNull || null // when true allows completion on data still at initial null state\r\n            this.disableWarnings = (opts || {}).disableWarnings // disable some less relevant warning messages\r\n\r\n            // assign initial data if differs from default\r\n            if (props.ref !== this._ref) this.ref = props.ref\r\n            if (props.data !== this._data) this.data = props.data\r\n            if (props.campaign) this.campaign = props.campaign\r\n\r\n            this._completeAsync = sq()\r\n        }\r\n\r\n        /**\r\n         * nice and easy, save some coding, and added security\r\n         */\r\n        get sq() {\r\n            if (this[`_sq`]) return this[`_sq`]\r\n            this[`_sq`] = sq()\r\n            return this[`_sq`]\r\n        }\r\n\r\n        set id(v) {\r\n            if (this._id) {\r\n                if (this.debug) warn('[pocket]', `cannot update already set id: ${this._id}`)\r\n                return\r\n            }\r\n            if (!v) throw ('id is required')\r\n            if (v.split(' ').length > 1) throw ('each id cannot have spaces')\r\n            if (v.indexOf(`::`) === -1) throw ('each id must be of format id::taskName')\r\n            if (v.indexOf(`:::`) !== -1) throw ('each id must be of format id::taskName')\r\n\r\n            // validate chars\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(v)) throw (`your id is invalid, allowed chars: ${pat}`)\r\n\r\n            v = v.replace(/ /gi, '_').toLowerCase()\r\n\r\n            if (v.indexOf(this._task) === -1) {\r\n                throw (`wrong id setup, your id should make up the taks name, example: id='cocacola::drink'`)\r\n            }\r\n\r\n            this._id = v\r\n        }\r\n\r\n        get id() {\r\n            return this._id\r\n        }\r\n\r\n        /**\r\n         * - collect all errors in to an array\r\n         * - no empty error values will be set\r\n         */\r\n        set error(v) {\r\n            if (!v) return\r\n            if (!(v || []).length && isArray(v)) return\r\n\r\n            // in case data is in its initial status state = 'open' we need to update it to change `_dataIndex`\r\n            //  if (this.data === null) this.data = false\r\n            // NOTE  we now use `this.completeOnNull` so can ignore above logic\r\n            this._error.push(v)\r\n            this._error = this._error.filter(z => !!z)\r\n            this.dispatchChange('error')\r\n        }\r\n\r\n        /**\r\n         * @returns an arrays of errors or null\r\n         */\r\n        get error() {\r\n            if (!this._error.length) return null\r\n            return this._error\r\n        }\r\n\r\n        get ref() {\r\n            return this._ref\r\n        }\r\n\r\n        /**\r\n         * - acceps string, can only be set when status isnt complete\r\n         * - can be used to find your Pocket by particular `ref`\r\n         */\r\n        set ref(v) {\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                warn('[pocket]', `[ref] must be a string`)\r\n                return\r\n            }\r\n            if (this.status === 'complete' || this.status === 'send') return\r\n\r\n            this._ref = v\r\n            this.dispatchChange('ref')\r\n        }\r\n\r\n        get campaign() {\r\n            return this._campaign\r\n        }\r\n\r\n        set campaign(v) {\r\n            if (v === undefined) return\r\n            if (this._campaign) {\r\n                if (this.debug && !this.disableWarnings) warn('[pocket]', `cannot update already set campaign ${this._campaign}`)\r\n                return\r\n            }\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                if (this.debug) warn('[pocket]', `campaign must be a string`, v)\r\n                return\r\n            }\r\n\r\n            this._campaign = v\r\n            this.dispatchChange('campaign')\r\n        }\r\n\r\n        set task(v) {\r\n            if (v === undefined) return\r\n            if (this._task) {\r\n                if (this.debug && !this.disableWarnings) warn('[pocket]', `cannot update already set task`)\r\n                return\r\n            }\r\n\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                if (this.debug) warn('[pocket]', `task must be a string`)\r\n                return\r\n            }\r\n            if (v.indexOf(\"::\") !== -1) throw ('task seperator :: is restricted')\r\n            if (v.split(' ').length > 1) throw ('task cannot have spaces, use seperators: _+')\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(v)) throw (`your task is invalid, allowed chars: ${pat}`)\r\n\r\n            this._task = v.replace(/ /gi, '_').toLowerCase()// every task must be valid with required \r\n           \r\n        }\r\n\r\n        get task() {\r\n            return this._task\r\n        }\r\n\r\n        set data(v) {\r\n            if (v === undefined) return\r\n            /**\r\n            * cannot be updated uppon status is send || complete\r\n            */\r\n            const complete = this.status === 'complete' || this.status === 'send'\r\n            if (complete) {\r\n                // NOTE this can also happen if you are using $transfer().$to from `PocketModule` that is a delayed\r\n                if (this.debug && !this.disableWarnings) warn('[pocket]', `you cannot update data once the status is complete or send`)\r\n                return null\r\n            }\r\n\r\n            this._dataIndex++\r\n            if (this.status === 'open' && this._data !== null && this._dataIndex > 1) this.status = 'updated'\r\n            this._data = v\r\n            this.dispatchChange('data')\r\n        }\r\n\r\n        get data() {\r\n            return this._data\r\n        }\r\n\r\n        /**\r\n         * ### update\r\n         * - update data of current Probe{}.data\r\n         * @param {*} data:any, required\r\n         * @param {*} merge:Boolean, optional for merging object to this.data\r\n         */\r\n        update(data, merge = null) {\r\n            if (this.status === 'complete' || this.status === 'send') {\r\n                if (this.debug && !this.disableWarnings) warn(`[Probe][update] cannot update data on complete status`)\r\n                return this\r\n            }\r\n            if (!isObject(data) && merge) {\r\n                if (this.debug) warn('[pocket]', `[Probe][update] cannot update none object 'data' with option 'merge=true' set`)\r\n                return this\r\n            }\r\n            if (isObject(data) && merge) this.data = Object.assign({}, this.data, data)\r\n            else if (data !== undefined) this.data = data\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * forward motion `status` update is allowed\r\n         * `value`: importance que\r\n         * `set`: if status already set\r\n         */\r\n        get statusStackOrder() {\r\n            return {\r\n                open: { value: 1, set: false },\r\n                updated: { value: 2, set: false },\r\n                complete: { value: 3, set: false },\r\n                send: { value: 4, set: false },\r\n                error: { value: 5, set: false }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * allow status: open | updated | complete | send | error\r\n         * `open`: status is set when pocked is initialized\r\n         * `updated`: status is set when data is updated\r\n         * `complete`: status is set when you want to complete and discard probe\r\n         * `send`: once the status was set `complete` data is resolved first then status is set as `send`.\r\n         * and Probe is locked, cannot be interacted with. Follow the strategic order set by `statusStackOrder`\r\n         * `error` acts like complete, it will resolve() last available data and block the Probe\r\n         */\r\n        get status() {\r\n            return this._status\r\n        }\r\n\r\n        set status(v) {\r\n            // order of status and allowed values\r\n            ((stat) => {\r\n                try {\r\n                    // meaning do not allow any status changes beond `updated`\r\n                    if (this.statusStackOrder[stat].value > 2 && this.statusStackOrder[stat].set === true) return false\r\n                } catch (err) {\r\n                    onerror('statusStackOrder invalid status')\r\n                }\r\n\r\n                // if (this._status === 'send' && (stat === 'complete' || stat ==='send')) {\r\n                //     if (this.debug) warn(`cannot update status if already complete, id:${this.id}`)\r\n                //     return false\r\n                // }\r\n\r\n                switch (stat) {\r\n                    case 'open':\r\n                        if (this._status === 'updated') {\r\n                            if (this.debug) warn('[pocket]', `cannot set status back to open once set to updated`)\r\n                            break\r\n                        }\r\n                        this._status = stat\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.onOpenStatus(v) // emit probe when status opens\r\n                        this.setStatusAsync = stat\r\n                        this.dispatchChange('status')\r\n                        break\r\n\r\n                    case 'updated':\r\n                        if (this._status === 'complete') {\r\n                            if (this.debug) warn('[pocket]', `cannot update status to 'updated' then previously set to 'complete'`)\r\n                            break\r\n                        }\r\n\r\n                        if (this._dataIndex > 0) {\r\n                            this._status = stat\r\n                            this.statusStackOrder[stat].set = true\r\n                            this.setStatusAsync = stat\r\n                            this.dispatchChange('status')\r\n                            if (this.debug) log(`id:${this.id}, data updated`)\r\n                        }\r\n\r\n                        break\r\n\r\n                    case 'complete':\r\n                        if (this.data === null && this.completeOnNull !== true) {\r\n                            if (this.debug) warn('[pocket]', `[status] cannot complete status because data is null, to complete you set data prop to false`)\r\n                            break\r\n                        }\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        // setTimeout(()=>{\r\n                        this._status = stat\r\n                        this.dispatchChange('status')\r\n                        this.onComplete(v) // resolve probe when status complete\r\n                        //  })\r\n                       \r\n                        break\r\n\r\n                    case 'send':\r\n                        if (this._status !== 'complete') {\r\n                            if (this.debug) warn('[pocket]', `cannot update status to 'send' then previously not set to 'complete'`)\r\n                            break\r\n                        }\r\n                        this._status = stat\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        this._completeAsync.resolve({ status: this._status, id: this.id })\r\n                        this.dispatchChange('status')\r\n                        break\r\n\r\n                    case 'error':\r\n                        if (this._status === 'complete') return\r\n                        // when we have error we need to inform what happen, and close the Probe\r\n\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        this.dispatchChange('status')\r\n                        this.onComplete(v) // resolve probe when status complete                     \r\n                        break\r\n\r\n                    default:\r\n                        if (this.debug) warn('[pocket]', `id:${this.id},  you set invalid status: ${stat}, nothing changed`)\r\n                }\r\n            })(v)\r\n        }\r\n\r\n        /**\r\n         * - works with `statusAsync`\r\n         * - (1.) setter creates our new sq() promise every time, and allows use or resolve \r\n         * - to use example: setStatusAsync.resolve()\r\n         */\r\n        set setStatusAsync(v) {\r\n            // 'v'  set to anything to initiate setter\r\n            const timestamp = new Date().getTime()\r\n            const p = { timestamp, p: sq() }\r\n            this._statusAsync.push(p)\r\n        }\r\n\r\n        get setStatusAsync() {\r\n            const lastPromise = last(this._statusAsync.sort((a, b) => a.timestamp - b.timestamp).map(z => z['p']))\r\n            lastPromise.resolve(copy(this.status)) // << we are unly returning\r\n            return lastPromise\r\n        }\r\n\r\n        /**\r\n         * ### statusAsync\r\n         * - dynamic promise resolver with `Simple Q` from `eaglex.net`\r\n         * - works with `setStatusAsync` setter/getter\r\n         * - return last 'resolve' status from last `timestamp` setting\r\n         */\r\n        get getStatusAsync() {\r\n            return this.setStatusAsync.promise()\r\n        }\r\n\r\n        /**\r\n         * - when status is set to complete or send, the promise will then be resolved\r\n         * @returns {status, id}\r\n         */\r\n        get completeAsync() {\r\n            return this._completeAsync.promise()\r\n        }\r\n\r\n        /**\r\n         * - alias of `getStatusAsync`\r\n         * @readonly\r\n         */\r\n        get statusAsync() {\r\n            return this.getStatusAsync\r\n        }\r\n\r\n        all() {\r\n            return { error: this.error, ref: this.ref, campaign: this.campaign, data: this.data, id: this.id, task: this.task, status: this.status }\r\n        }\r\n\r\n        /**\r\n         * - can be used when `opts.onChange=true` is set\r\n         * - changes are observed for `[ data,status,ref,error,campaign,status:complete]`\r\n         * @param {*} cb(data,id) callback returns updated value in real time\r\n         * @returns self\r\n         */\r\n        onChange(cb, watch = 'all') {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn('[pocket]', `[onChange] to use need to set opts.onChange=true`)\r\n                return this\r\n            }\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) warn(`[onChange] cb must be a function`)\r\n                return this\r\n            }\r\n            let availableWatch = ['all', 'data', 'status', 'ref', 'error', 'campaign']\r\n\r\n            // allo lookout for status complete event only when selected to watch\r\n            availableWatch = [].concat(availableWatch,['status:complete'])\r\n\r\n            if (!availableWatch.includes(watch)) {\r\n                if (this.debug) warn('[pocket]', `[onChange] no watch available for ${watch}`)\r\n                return this\r\n            }\r\n\r\n            let statIndex = availableWatch.indexOf('status:complete')\r\n            availableWatch.splice(statIndex,1)\r\n\r\n            const self = this\r\n\r\n            if (!this.onchangeDispatch) {\r\n                if (this.debug) warn('[pocket]', `[onChange] onchangeDispatch no longer active`)\r\n                return this\r\n            }\r\n\r\n            this.onchangeDispatch.initListener().subscribe(function (data, id) {\r\n                // NOTE data['changed'] // returned in dispatch only provided name of asset changed\r\n                // no point to carry data if we can access it direct\r\n                if (data['changed'] && watch === 'all') {\r\n                    cb.bind(self)(copy(self.all()), id)\r\n                    return\r\n                }\r\n\r\n                /** \r\n                 * on status complete return all data copy in callback\r\n                */\r\n                if(watch==='status:complete'){\r\n\r\n                    if (data['changed'] === 'status' && self['status'] ==='send') {\r\n                        cb.bind(self)(copy(self.all()), id)\r\n                    }  \r\n                    return this\r\n                }\r\n                 \r\n\r\n                if (data['changed'] === watch && self[watch] !== undefined) {\r\n                    cb.bind(self)(copy(self[watch]), id)\r\n                    \r\n                }          \r\n            })\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - works with onchangeDispatch, onChange \r\n         * - emmits next value to `onchangeDispatch` listener\r\n         * @param {*} changedName required, provide name of Probe prop to alert dispatcher what has changed\r\n         * @returns self\r\n         */\r\n        dispatchChange(changedName) {\r\n            if (!this._onChange) {\r\n                return null\r\n            }\r\n            if (!this.onchangeDispatch) {\r\n                return null\r\n            }\r\n            this.onchangeDispatch.initListener().next({ changed: changedName })\r\n            return true\r\n        }\r\n\r\n        /**\r\n         * initiates dispatcher to handle on change value of [data,status,ref,error,campaign]\r\n         * @returns dispatcher instance\r\n         */\r\n        get onchangeDispatch() {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn('[pocket]', `[onchangeDispatch] to use need to set opts.onChange=true`)\r\n                return null\r\n            }\r\n\r\n            if (this._onchangeDispatch) {\r\n                return this._onchangeDispatch\r\n            }\r\n\r\n            this._onchangeDispatch = require('../libs/dispatcher')(this.id)\r\n            return this._onchangeDispatch\r\n        }\r\n\r\n        /**\r\n         * status watch, when current status changes execute send\r\n         * @param {*} status\r\n         */\r\n        onComplete(status) {\r\n            if ((status === 'complete' || status === 'error') && this._status !== 'send' && (this._dataIndex > 0 || this.completeOnNull === true)) {\r\n\r\n                if (this.emitter) {\r\n                    setTimeout(() => {\r\n                        this.emitter({ probe: this, status })\r\n                    })\r\n                }\r\n                this._status = 'send'\r\n                this.sq.resolve({ probe: this.all() })  \r\n\r\n                setTimeout(() => {\r\n                // in case delete listener when data complete     \r\n                    if (this.onchangeDispatch) this.onchangeDispatch.del()\r\n                })\r\n            }\r\n        }\r\n\r\n        /**\r\n         * do something on open task, this means we start request for data\r\n         * @param {*} status\r\n         */\r\n        onOpenStatus(status) {\r\n            if (status === 'open') {\r\n                // return this probe and update it when its complete\r\n                if (this.emitter) {\r\n                    setTimeout(() => {\r\n                        this.emitter({ probe: this, status: 'open' })\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","\r\n/** \r\n    * ### Architect\r\n    * a more in depth project architecture setup, allowing more robust configuration, munipulation and data flows\r\n*/\r\nmodule.exports = (Pocket) => {\r\n\r\n    const { objectSize, isFunction, onerror, warn, log, isString } = require('x-utils-es/umd')\r\n    // work with \r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\r\n\r\n    /**\r\n     * protected prototype exluded from `Architect`\r\n     */\r\n    function ArchitectModel() {\r\n        this._architectVal = null\r\n        this.architect = Object.create(ArchitectModel.prototype, {\r\n            value: {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => {\r\n                    return this._architectVal\r\n                },\r\n                set: (v) => {\r\n                    if (!objectSize(v)) return\r\n                    this._architectVal = v\r\n                    log('[pocket]', `[architect] updated`)\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return class Architect extends Pocket {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n\r\n            this.architectConfig = {}\r\n            const archModel = new ArchitectModel()\r\n            this.architectMod = archModel.architect\r\n        }\r\n\r\n        setArchitect(projectID, val) {\r\n            if (this.architectConfig[projectID] === undefined) this.architectConfig[projectID] = this.architectMod\r\n            this.architectConfig[projectID]['value'] = Object.assign({}, this.architectConfig[projectID]['value'], val)\r\n            return this\r\n        }\r\n\r\n        getArchitect(projectID) {\r\n            return (this.architectConfig[projectID] || {})['value']\r\n        }\r\n\r\n        /** \r\n       * @param assetName string, specify the name you chose in your `$architect(...)` declaration,\r\n       * @param asCallback when exists, return asset as callback\r\n       * @param projectID optional, update selector and return desired asset\r\n       * @returns if callback is returned the same value is returned\r\n      */\r\n        asset(assetName, asCallback, projectID) {\r\n            if (!isFunction(asCallback)) {\r\n                if (this.debug) warn('[pocket]', `[$asset] asCallback must be a function`)\r\n                return null\r\n            }\r\n            // reserved names\r\n            if (assetName === 'project' || assetName === 'cache') {\r\n                if (this.debug) warn('[pocket]', `[$asset] 'project, cache' are  restricted`)\r\n                return undefined\r\n            }\r\n            const lastProject = this.lastProjectID(projectID) // in case we are calling `$architect` on existing project\r\n            projectID = this.validProjectID(lastProject || projectID)\r\n\r\n            if (this.getArchitect(projectID)) {\r\n                if (this.getArchitect(projectID)[assetName] !== undefined) {\r\n                    return asCallback.call(this, this.getArchitect(projectID)[assetName])\r\n                } else {\r\n                    if (this.debug) warn('[pocket]', `[$asset] assetName for architect doesnt exist`)\r\n                    return null\r\n                }\r\n            } else {\r\n                if (this.debug) warn('[pocket]', `[$asset] architectConfig for assetName doesnt exist`)\r\n                return null\r\n            }\r\n        }\r\n\r\n        /** \r\n          * - can be used as a project setter same as `$payload` or `$project`, but with additional configuration\r\n          * \r\n          * @param cb required, must return project settings: `{project:{payloadData}, asset:{value, name}, cache:{project, asset}}\r\n          * @param projectID optional\r\n          * @returns self\r\n         */\r\n        architect(cb, projectID) {\r\n\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) onerror('[pocket]', `[$architect] callback must be set`)\r\n                return this\r\n            }\r\n\r\n            const config = cb.call(this/** ,?? */)\r\n\r\n            if (!objectSize(config)) {\r\n                if (this.debug) onerror('[pocket]', `[architect] must return a valid object settings {project, asset}, at least 1 is required`)\r\n                return this\r\n            }\r\n\r\n            const configProjectID = (config['project'] || {}).id\r\n            const lastProject = this.lastProjectID(projectID) // in case we are calling `$architect` on existing project\r\n            projectID = this.validProjectID(lastProject || projectID || configProjectID)\r\n\r\n            if (!projectID) {\r\n                if (this.debug) onerror('[pocket]', `[$architect] if this is a new project, you must specify projectID`)\r\n                return this\r\n            }\r\n            const validConfig = Object.entries(config).reduce((n, [k, value]) => {\r\n                if (['project', 'asset', 'cache'].indexOf(k) !== -1) n[k] = value\r\n                return n\r\n            }, {})\r\n\r\n            // default setting for `architect.cache` if getArchitect not stored\r\n            if (!(this.getArchitect(projectID) || {})['cache']) {\r\n                const defaults = { project: false, asset: false }\r\n                if (!validConfig['cache']) validConfig['cache'] = defaults\r\n\r\n                this.setArchitect(projectID, {\r\n                    'cache': validConfig['cache']\r\n                })\r\n\r\n            } else validConfig['cache'] = this.getArchitect(projectID)['cache']\r\n\r\n            for (let k in validConfig) {\r\n                const item = validConfig[k]\r\n                // get last cache overide\r\n                const cached = validConfig['cache'][k] === true && (k === 'project' || k === 'asset')\r\n\r\n                if (k === 'project') {\r\n                    // item['async'] item['type'] .. can include `async` and `type` \r\n                    try {\r\n                        if (cached && this.getArchitect(projectID)[k]) continue\r\n                    } catch (err) {\r\n                        // \r\n                    }\r\n\r\n                    this.setArchitect(projectID,\r\n                        { project: this.$payload(item, item['async'], item['type']).d }\r\n                    )\r\n                }\r\n\r\n                if (k === 'asset') {\r\n                    if (!isString(item['name']) || item['value'] === undefined) {\r\n                        if (this.debug) warn('[pocket]', `[$architect] asset must include {value, name}`)\r\n                        return this\r\n                    }\r\n                    if (item['name'] === 'project' || item['name'] === 'cache') {\r\n                        if (this.debug) warn('[pocket]', `[$architect] asset props, \"project, cache\" are reserved`)\r\n                        return this\r\n                    }\r\n                    try {\r\n                        if (cached && this.getArchitect(projectID)[item['name']]) continue\r\n                    } catch (err) {\r\n                        // \r\n                    }\r\n\r\n                    // if already exists, same assets will be overriten and new will be created\r\n                    this.setArchitect(projectID, {\r\n                        [item['name']]: item['value']\r\n                    })\r\n                }\r\n            }\r\n            return this\r\n        }\r\n\r\n    }\r\n}\r\n","\r\n/**\r\n * ### PocketSelectors\r\n * - Extends PocketModule using selectors for better access to Probes\r\n * - allow selecttion to refference by, example:  `taskName`, `::taskName` and `${projectID}::taskName`, thanks to `selectByTask()` method\r\n */\r\nmodule.exports = (PocketModule) => {\r\n    const { copy, warn, isArray, onerror, objectSize, isString, uniq, isFunction } = require('x-utils-es/umd')\r\n    return class PocketSelectors extends PocketModule {\r\n\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n        }\r\n\r\n        /** \r\n         * - can be used as a project setter same as `$payload` or `$project`, but with additional configuration\r\n         * @extends Architect\r\n         * @param cb required, must return project settings: `{project:{payloadData}, asset:{value, name}}\r\n         * @param projectID optional\r\n         * @returns self\r\n        */\r\n        $architect(...args) {     \r\n            return this.architect(...args)\r\n        }\r\n\r\n        /** \r\n         * @param assetName string, specify the name you chose in your `$architect(...)` declaration\r\n         * @param projectID optional, update selector and return desired asset\r\n         * @returns asset by name or null\r\n         * @extends Architect\r\n        */\r\n        $asset(...args) {\r\n            return this.asset(...args)\r\n        }\r\n\r\n        /**\r\n         * - check is probe exists on PocketModule\r\n         * @param {*} probeID required, can specify `::taskName` or full id `{projectID}::{probeID}`\r\n         * @returns boolean\r\n         */\r\n        $exists(probeID) {\r\n            return !!this.selectByTask(probeID)\r\n        }\r\n\r\n        /**\r\n         * @param projectID required\r\n         * @returns boolean `true/false/null`, determined by project completion\r\n         */\r\n        $projectComplete(projectID) {\r\n            if (!this.projectsCache[projectID]) return null\r\n            return this.projectsCache[projectID] === 'complete'\r\n        }\r\n\r\n        /**\r\n         * ### $projectSet\r\n         * - use it to check if project already available, it is similar to `$projectSetAsync` but not a promise, returns current status, not in future\r\n         * @param {*} projectID required\r\n         */\r\n        $projectSet(projectID = '') {\r\n            projectID = this.validProjectID(projectID)\r\n            if (this.payloadData[projectID]) return true\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * - run conditional statement within callback, so we can keep chaining in the same block\r\n         * @param cb required, inside callback access to self for PocketModule, or for Probe{}, depending on `projectID/probeID` id specified\r\n         * @param `projectID/probeID` optional, specify either `projectID` or `probeID`, defaults to last `projectID`\r\n         * @returns by default eturns Pocket/self, or any true value passed inside callback\r\n         */\r\n        $condition(cb, id) {\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) warn('[pocket]', `[$condition] must provide callback`)\r\n                return this\r\n            }\r\n            id = !isString(id) ? '' : id\r\n            let selfType = 'PocketSelf'// `ProbeSelf`\r\n            let self = null\r\n            if (id.indexOf(`::`) === 0) { // if specified id is `probeID`\r\n                id = this.selectByTask(id, true)\r\n                id = this.lastProbeID(id)\r\n                selfType = `ProbeSelf`\r\n                if (!id) {\r\n                    if (this.debug) warn('[pocket]', `[$condition] probeID not found`)\r\n                    return this\r\n                }\r\n                // also updates last selector reference\r\n            } else if (this.lastProjectID(id)) selfType = 'PocketSelf' // if specified id is `projectID`\r\n            else {\r\n                if (this.debug) warn('[pocket]', `[$condition] projectID not found`)\r\n                return this \r\n            }\r\n\r\n            if (selfType === 'PocketSelf') self = this\r\n            if (selfType === 'ProbeSelf') self = this.$get(id)\r\n\r\n            if (!self) {\r\n                if (this.debug) warn('[pocket]', `[$condition] no valid self value`)\r\n                return this\r\n            }\r\n            \r\n            const cbDATA = cb.call(self, self) // when using arrow function pass `(self)=>` in callback as well\r\n            if (cbDATA) return cbDATA // if callback has any true data return it, \r\n            else return this // else return self\r\n        }\r\n\r\n        /**\r\n         * @returns last selected projectID\r\n         */\r\n        get $projectID() {\r\n            return this._lastProjectID\r\n        }\r\n\r\n        /**\r\n         * - return last probe status, this is a dynamic Promise, creates new promise every time status is changed, so then it needs to bu called again to get latest update\r\n         * @param {*} probeID \r\n         * @extends probeStatusAsync\r\n         */\r\n        $probeStatusAsync(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this.probeStatusAsync(lastProbeID)\r\n        }\r\n        \r\n        /**\r\n         * ### $get\r\n          * - `get probe by 'id::taskName'`\r\n          * - `returns instance`\r\n          *  methods:`{get,all}` props: `{id,data,tasks,status}`\r\n          * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n          * @param {*} self = false optional, in case you want to chain, and access `Probe{}` through `...).d`\r\n          * @extends _get\r\n         */\r\n        $get(probeID, self) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this._get(lastProbeID, self)\r\n        }\r\n\r\n        /**\r\n         * - return array of Probes matched by ref\r\n         * @param {*} probeRef, required\r\n         * @returns [Probe{},...] array\r\n         */\r\n        $getByRef(probeRef = '') {\r\n            return Object.assign(this.pocket).filter(([id, probe], inx) => probe.ref === probeRef)\r\n        }\r\n       \r\n        /**\r\n         * - as name suggest sets up new new data for Probe/task, it derives from `$update` \r\n         * @param {*} dataFrom required, must specify what to set on Probe{}, example: `dataFrom:{data:'coke',status:'complete',campaign:'cocacola'}`\r\n         * - we should only use `$set` for initialization, this action also calls `clearStoreTransfers`\r\n         * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n         * @extends _set\r\n         */\r\n        $set(dataFrom, probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this._set(dataFrom, lastProbeID)\r\n        }\r\n\r\n        /**\r\n         * ### $probe\r\n         * - return me as Probe{}, similar as $get(...), although does additional check for instanceOf Probe{}\r\n         * @param {*} probeID \r\n         */\r\n        $probe(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            if (!this.pocket[lastProbeID]) {\r\n                if (this.debug) warn('[pocket]', `[$probe] not found for probeID: ${probeID}`)\r\n                return undefined\r\n            }\r\n\r\n            if (this.pocket[lastProbeID].constructor.name !== 'Probe') {\r\n                if (this.debug) onerror('[pocket]', `[$probe] probeID: ${probeID} is not an instance of Probe{}`)\r\n                return undefined\r\n            }\r\n\r\n            return this.pocket[lastProbeID]\r\n        } \r\n        \r\n        /**\r\n         * update Probe/task, for convenience, so we dont have do this, example: `pc.$get('abc123::grab').status='complete'`\r\n         * @param {*} dataFrom required, must specify what to update on Probe{}, example: `dataFrom:{data:'coke',status:'complete',campaign:'cocacola'}`\r\n         * @param {*} mergeData optional if `true` will merge: `Object.assing({},probe[id].data,mergeData['data'])`\r\n         * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n         * @extends update\r\n         */\r\n        $update(dataFrom, mergeData, probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this.update(dataFrom, mergeData, lastProbeID)\r\n        }\r\n\r\n        /**\r\n         * ### $select\r\n         * - select current payloadID/project/job by id you are working on\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         */\r\n        $select(projectID = '') {\r\n            projectID = !isString(projectID) ? '' : projectID\r\n            this.lastProjectID(projectID) // also updates last selector reference\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $filter\r\n         * - filter works together with `$compute` or standalone when specified `.d` to return filtered `list`\r\n         * @param {*} cb \r\n         * @param {*} projectID \r\n         */\r\n        $filter(cb, projectID) {\r\n            projectID = this.lastProjectID(projectID) // also updates last selector reference\r\n            const returnAs = (val) => {\r\n                this.d = (val || []).filter(z => z.isNONE === undefined)\r\n                return this\r\n            }\r\n\r\n            if (!isFunction(cb)) return returnAs([])\r\n\r\n            if (!this.payloadData[projectID]) {\r\n                if (this.debug) warn('[pocket]', `[$filter] no projectID found`)\r\n                return returnAs(null)\r\n            }\r\n            // when narrowing down $filter.$filter process, lets remember last action\r\n            let probeList = []\r\n            if ((this._lastFilterList[projectID] || []).length) probeList = this._lastFilterList[projectID]\r\n            else {\r\n                this._lastFilterList[projectID] = []\r\n                probeList = this.projectProbeList(projectID)\r\n            }\r\n            probeList.forEach((probe, inx) => {\r\n                if (probe.isNONE) {\r\n                    return\r\n                }\r\n                const matchFound = cb.call(probe, probe)\r\n                if (!matchFound) {\r\n                    this._lastFilterList[projectID] = this._lastFilterList[projectID].filter(z => z.id !== probe.id)\r\n                    this._lastFilterList[projectID].push({ id: probe.id, isNONE: true })\r\n                    return\r\n                }\r\n\r\n                if (matchFound !== undefined && (matchFound === true || matchFound === 1)) {\r\n                    // dont re-add same probe\r\n                    const isNew = this._lastFilterList[projectID].filter((z, i) => (z || {}).id === probe.id).length\r\n\r\n                    if (!isNew) this._lastFilterList[projectID].push(probe)\r\n                    \r\n                } else this._lastFilterList[projectID].push({ id: probe.id, isNONE: true })\r\n            })\r\n            return returnAs(this._lastFilterList[projectID])\r\n        }\r\n\r\n        /**\r\n         * ### $compute\r\n         * - iterate thru each Probe{}/ instance in a callback, and make changes to it\r\n         * - note: you can only compute thru items that are not `complete`\r\n         * @param {*} cb((probe, probeID)=>this/self.data) required\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         */\r\n        $compute(cb, projectID = '') {\r\n            projectID = this.lastProjectID(projectID)\r\n            const returnAs = (val) => {\r\n                // delete last filtered list after it was consumed\r\n                if (val) delete this._lastFilterList[projectID]\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) warn('[pocket]', `[$compute] cb must be a function`)\r\n                return returnAs(null)\r\n            }\r\n\r\n            if (!this.payloadData[projectID]) {\r\n                if (this.debug) warn('[pocket]', `[$compute] no project found fo your/last id projectID:${projectID}`)\r\n                return returnAs(null)\r\n            }\r\n\r\n            let lastFilter = (this._lastFilterList[projectID] || [])\r\n            if (lastFilter.length) {\r\n\r\n                // uniq\r\n                this._lastFilterList[projectID] = lastFilter = lastFilter.filter(z => z.isNONE === undefined)\r\n                    .filter(({ id }, i, all) => {\r\n                        return all.filter(_probe => id === _probe.id).length === 1\r\n                    })\r\n                lastFilter.forEach(probe => {\r\n                    // compute method is designed to allow access to each Probe, but we do not want to allow looping thru assets that are already complete           \r\n                    if (probe.status !== 'complete' && probe.status !== 'send') cb.call(probe, probe)\r\n                })\r\n                // finally only return not none list on probes, then clear _lastFilterList\r\n                return returnAs(this._lastFilterList[projectID])\r\n            } else {\r\n              \r\n                this.projectProbeList(projectID).forEach(probe => {\r\n                    // compute method is designed to allow access to each Probe, but we do not want to allow looping thru assets that are already complete           \r\n                    \r\n                    if (probe.status !== 'complete' && probe.status !== 'send') cb.call(probe, probe)\r\n                })\r\n                return returnAs(this.projectProbeList(projectID))\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $list\r\n         * - list active Probes{} by project id, should return all assigned probe/tasks regardless of status\r\n         * - returns array[] of active Probe{}/tasks or []\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         * @param {*} cb((probe, probeID)=>) optional, when set will loop thru each Probe{} in callback\r\n         * @param {*} type optional, set to `list`, will return latest Probes, that includes if initiated cb and made a few changes\r\n         */\r\n        $list(projectID = '', cb = null, type = 'self') {\r\n            projectID = this.lastProjectID(projectID)\r\n            if (!this.payloadData[projectID]) return []\r\n            const list = () => {\r\n                return Object.entries(this.pocket).reduce((n, [key, val], inx) => {\r\n                    if (val.id.includes(projectID)) n.push(val)\r\n                    return n\r\n                }, [])\r\n            }\r\n            if (isFunction(cb)) {\r\n                this.projectProbeList(projectID).forEach(probe => {\r\n                    cb(probe.all()) // no access to Probe/instance only copy\r\n                })\r\n                if (type === 'self' || !type) {\r\n                    return this\r\n                }\r\n                if (type === 'list') return list()\r\n            } else {\r\n                return list()\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $transfer\r\n         * - select data from `fromProbeID` and hold it in `_transferCache`, until `$to(probeID)` is called\r\n         * - warning, action removes `Probe[fromProbeID].data` and overrides it on Probe[probeID].data, only when `$to(probeID)` is called, simple as that!\r\n         * @param {*} fromProbeID optional/sensitive, selects new point of reference.\r\n         */\r\n        $transfer(fromProbeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            fromProbeID = this.selectByTask(fromProbeID, true)\r\n            fromProbeID = this.lastProbeID(fromProbeID)\r\n            if (!this.pocket[fromProbeID]) {\r\n                if (this.debug) warn('[pocket]', `[$transfer] no Probe{} found for this id fromProbeID:${fromProbeID}`)\r\n                return this\r\n            }\r\n            this.storeTransfers(fromProbeID, copy(this.pocket[fromProbeID]['data']))\r\n            // NOTE needed for extra security to make sure it was called before we can update `$to()`\r\n            this.$transfer_lastID = fromProbeID\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $to\r\n         * - works together with `$transfer`, will transfer `data` from one Probe{} to another\r\n         * if `_transferCache` is set, the cache is cleared.\r\n         * @param {*} toProbeID optional/sensitive, points to Probe{} `data` will be packed, it is not previous reference pointer, but the next.\r\n         * - will only work if `toProbeID` is not yet complete\r\n         * @param {*} pointToThisProbe to stay on the current pointer reference\r\n         * @param {*} maxDelay, keep at minimum! Time between transaction can take place, relates to `fromAverageTimeHasPast` found in `accessLastValidTransfer()`\r\n         */\r\n        $to(toProbeID = '', pointToThisProbe = true, maxDelay = 100) {\r\n\r\n            // allow use of short ref names example: `::cocalola`\r\n            toProbeID = this.selectByTask(toProbeID, pointToThisProbe)\r\n            // if (!keepLastPointerReference) toProbeID = this.lastProbeID(toProbeID)\r\n            if (pointToThisProbe) toProbeID = this.validProbe(toProbeID)\r\n            if (!toProbeID) {\r\n                if (this.debug) warn('[pocket]', `[$to] toProbeID is invalid`)\r\n                return this\r\n            }\r\n            if (!this.pocket[toProbeID]) {\r\n                if (this.debug) warn('[pocket]', `[$to] no Probe{} found for this id toProbeID:${toProbeID}`)\r\n                return this\r\n            }\r\n            if (this.$transfer_lastID) {\r\n                // please note because this can be a delayed transaction, if you send `status=complete`\r\n                // the data will not be updated\r\n                const lastValidTransfer = this.accessLastValidTransfer(maxDelay)\r\n                if (objectSize(lastValidTransfer)) {\r\n                    const { fromProbeID, data } = lastValidTransfer\r\n                    if (this.$transfer_lastID === fromProbeID) {\r\n                        if (this.pocket[toProbeID].status === 'complete' || this.pocket[toProbeID].status === 'send') {\r\n                            if (this.debug) warn('[pocket]', `[$to] cannot transfer since toProbeID: ${toProbeID} is already complete`)\r\n                            this.$transfer_lastID = ''\r\n                            return this\r\n                        }\r\n                        this.pocket[fromProbeID]['data'] = null // from $transfer \r\n                        this.pocket[toProbeID]['data'] = data // $to \r\n                    }\r\n                } else {\r\n                    if (this.debug) warn('[pocket]', `[$to] no last valid transfer found`)\r\n                }\r\n                this.$transfer_lastID = ''\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $of\r\n         * - points to Probe{} be reference\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $of(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            this.selectByTask(probeID, true)\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $data\r\n         * - returns Object copy of `Probe['data']`\r\n         * @param {*} dataProp optional, if you know what you are asking for example: `{assets:true}`,or `array['assets]`, it has catch error exception, so you wont receive any errors just `null`\r\n         * will return all available matched within our `Probe{}['data]`. Multiples of `dataProp{}/([])/(',')` will return an object, if only one specified, only value will be retured\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         * @param {*} self optional,if you want to $cached() last data enquiry and return `self` to keep chaining, nice!\r\n         */\r\n        $data(dataProp = null/** {}||[] */, probeID = '', self = false) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return self ? this : undefined\r\n\r\n            // NOTE can provide as an array\r\n            if (isArray(dataProp) && (dataProp || []).length) {\r\n                dataProp = uniq(dataProp).reduce((n, el) => {\r\n                    if (el !== undefined) n[el.trim()] = true\r\n                    return n\r\n                }, {})\r\n            }\r\n\r\n            if (!dataProp || !objectSize(dataProp)) {\r\n                this._$cached_data[probeID] = copy(this.pocket[probeID]['data'])\r\n                return self ? this : this._$cached_data[probeID]\r\n            }\r\n            return this.dataPropSelector(\"data()\", probeID, dataProp, self, copy(this.pocket[probeID]['data']))\r\n        }\r\n\r\n        /**\r\n         * ### cached\r\n         * - grabs last cached `$data(...)` from Probe{}\r\n         * @param {*} dataProp{}/String optional, know what you are asking for example: ` {assets:true}/ or > 'assets,values,somethingElse'`, it has catch error exception, so you wont receive any errors just `null`\r\n         * will return all available matched within our `_$cached_data[probeID]`. Multiples of `dataProp{}/([])/(',')` will return an object, if only one specified, only value will be retured\r\n         * @param {*} probeID \r\n         */\r\n        $cached(dataProp = {}, probeID = '') {\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return undefined\r\n            const hasValue = this._$cached_data[probeID] !== undefined && this._$cached_data[probeID] !== null\r\n            if (!hasValue) return undefined\r\n            // if you provided a string make it an object\r\n            if (isString(dataProp) && (dataProp || '').length) {\r\n                dataProp = uniq(dataProp.trim().replace(/ /gi, '').split(',')).reduce((n, el) => {\r\n                    if (el !== undefined) n[el] = true\r\n                    return n\r\n                }, {})\r\n            }\r\n            // return cached data if its not an object, or undefined\r\n            if (!objectSize(this._$cached_data[probeID]) && hasValue) {\r\n                if (objectSize(dataProp)) return undefined // our cache not an object, but we are asking for dataProp reference, so should return undefined\r\n                else return this._$cached_data[probeID]\r\n            }\r\n            // no selection at all, so just return whats available\r\n            if (!dataProp || !objectSize(dataProp)) {\r\n                return this._$cached_data[probeID] === undefined ? undefined : this._$cached_data[probeID]\r\n            } else return this.dataPropSelector(\"cached()\", probeID, dataProp, false, this._$cached_data[probeID])\r\n        }\r\n\r\n        /**\r\n         * ### $campaign\r\n         * - returns Object copy of `Probe['campaign']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $campaign(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['campaign'])\r\n        }\r\n\r\n        /**\r\n         * ### $ref\r\n         * - returns Probe{}.ref\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $ref(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['ref'])\r\n        }\r\n\r\n        /**\r\n        * ### $status\r\n        * - returns Object copy of `Probe['status']` \r\n        * @param {*} probeID optional/sensitive, select new point of reference\r\n        */\r\n        $status(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['status'])\r\n        }\r\n\r\n        /**\r\n         * ### $task\r\n         * - returns Object copy of `Probe['task']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $task(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['task'])\r\n        }\r\n\r\n        /**\r\n         * ### $task\r\n         * - returns Object copy of `Probe['task']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $error(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['error'])\r\n        }\r\n\r\n        /**\r\n         * ### $all\r\n         * - return Object copy of all setters: `{id,status,campaign,task,data}` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $all(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID].all())\r\n        }\r\n\r\n        /**\r\n         * - changes are observed for `[data,status,ref,error,campaign, status:complete]`\r\n         * - when watchProp `status:complete` is selected all copy data is returned in callback\r\n         * @param watchProp specify what property to watch, defaults to `all`, except for `status:complete`\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         * @extends Probe.onChange\r\n         */\r\n        $onChange(cb, watchProp, probeID) {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn('[pocket]', `[$onChange] opts.onChange=true must be enabled to use this feature`)\r\n                return this\r\n            }\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            this.pocket[probeID].onChange(cb, watchProp)\r\n            return this\r\n        }\r\n\r\n        /** \r\n         * callback initialted of any probe that was completed, unless specificly selected `probeID`\r\n         * @param {Function} `cb((allData,id))=>`\r\n         * @param {*} probeID optional if you only want to listen for changes to specific probe add the id\r\n        */\r\n        $onProbeComplete(cb, probeID) {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn('[pocket]', `[$onChange] opts.onChange=true must be enabled to use this feature`)\r\n                return this\r\n            }\r\n            // only run available onChange for selected probe by id\r\n            if (probeID) {\r\n                probeID = this.selectByTask(probeID, true)\r\n                if (!this.pocket[probeID]) return null\r\n                this.pocket[probeID].onChange(cb, watchProp)\r\n                return this\r\n            }\r\n            else{\r\n                \r\n                let projectID = this.lastProjectID()           \r\n                let probeList =  this.projectProbeList(projectID)\r\n\r\n                /** \r\n                 * callback any probe that completed due process\r\n                */\r\n                probeList.forEach(probe=>{\r\n                    probe.onChange(cb, 'status:complete')\r\n                })\r\n\r\n                return this\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n}\r\n"],"sourceRoot":""}