{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./Pocket/utils.js","webpack:///./libs/dispatcher.js","webpack:///./node_modules/simple-q/index.js","webpack:///./Pocket/versions/Pocket.browser.js","webpack:///./Pocket/Pocket.module.js","webpack:///./node_modules/simple-q/simple-q.js","webpack:///./Pocket/Pocket.libs.js","webpack:///./Pocket/Probe.js","webpack:///./Pocket/Pocket.architect.js","webpack:///./Pocket/Pocket.selectors.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","objectSize","obj","__proto__","entries","length","last","arr","Array","copyBy","refs","reduce","el","undefined","validID","id","toString","toLowerCase","isNumber","Number","isPromise","defer","Promise","uniq","filter","all","indexOf","isObject","isArray","isString","str","String","isFunction","copy","data","JSON","parse","stringify","err","errorMessages","messages","msgs","k","v","message","code","log","args","concat","console","apply","warn","onerror","error","_uid","_debug","uid","debug","plugin","this","Date","getTime","cbQueue","dispatchInstance","initListener","Dispatch","next","self","type","cb","isActive","del","subscribe","window","Pocket","require","PocketModule","sq","PocketLibs","newProbe","Probe","PocketModuleExt","opts","projectID","lastProjectID","deletePocketSet","async","returnAs","val","asAsync","then","z","payload","reject","$payload","payloadID","allowsMultiple","_payloadID","projectsCache","_ready_method_set","$projectSetAsync","ready","deleteWithDelay","setTimeout","disableWarnings","dispatcher","probe","status","isUpdated","keys","every","validProjectID","payloadData","_lastProjectID","initialProject","_lastFilterList","values","idRegexValid","probeID","pocket","timestamp","task","push","lastPocketTimestamp","distributor","setDefer","projectSetDispatcher","_projectSetAsync","resolve","promise","lastProbeID","getStatusAsync","dataFrom","mergeData","_setUpdate","tasks","_ready","updated","pos","probeProps","inx","assign","clearStoreTransfers","$transfer_lastID","_$cached_data","msg","pocketSet","map","output","pock","prop","userOutput","pl","setProbe","emitter","_emit","onChange","_onChange","completeOnNull","poc","includes","_projectSetDispatcher","architectConfig","PocketArchitect","promises","__deferSet","_lastProbeID","_projectSet","_transferCached","cleared","forEach","element","fromProbeID","splice","fromAverageTimeHasPast","sort","a","b","transferCachedCopy","coundCache","currentOffset","taskOrProbeID","updateLastProbeID","split","dynamicProbeID","newProbeID","validProbe","selectedData","dataProp","probeData","shift","RegExp","test","props","_id","_error","_ref","_task","_status","_data","_campaign","_dataIndex","_statusIndex","_statusAsync","_onchangeDispatch","ref","campaign","_completeAsync","merge","watch","availableWatch","onchangeDispatch","changedName","changed","pat","replace","dispatchChange","open","set","complete","send","stat","statusStackOrder","onOpenStatus","setStatusAsync","onComplete","lastPromise","ArchitectModel","_architectVal","architect","configurable","archModel","architectMod","assetName","asCallback","lastProject","getArchitect","config","configProjectID","validConfig","project","asset","setArchitect","item","cached","selectByTask","selfType","$get","probeStatusAsync","_get","probeRef","_set","constructor","update","isNONE","probeList","projectProbeList","matchFound","lastFilter","_probe","list","storeTransfers","toProbeID","pointToThisProbe","maxDelay","lastValidTransfer","accessLastValidTransfer","trim","dataPropSelector","hasValue","watchProp"],"mappings":"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","file":"js/pocket_browser.6cfcfd0a.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/* eslint-disable no-proto */\r\n// node.js/browser detection\r\n\r\n/**\r\n * @Utils\r\n * my own lodash/like `Utils`\r\n */\r\n\r\nexports.objectSize = (obj) => (obj && (Object.prototype === (obj).__proto__)) ? Object.entries(obj).length : 0\r\nexports.last = (arr) => (arr && Array.prototype === (arr).__proto__) ? arr[arr.length - 1] : null\r\nexports.copyBy = (obj, refs) => refs.reduce((n, el, i) => {\r\n    if (obj[el] !== undefined) n[el] = obj[el]\r\n    return n\r\n}, {})\r\nexports.validID = (id) => !(id || '') ? null : (id || '').toString().toLowerCase()\r\nexports.isNumber = (n) => n !== undefined ? (n).__proto__ === Number.prototype : false\r\nexports.isPromise = (defer) => Promise.prototype === (defer || {}).__proto__\r\nexports.uniq = (arr) => arr.filter((el, i, all) => all.indexOf(el) === i)\r\nexports.isObject = (obj) => !obj ? false : (Object.prototype === (obj).__proto__ || (obj) instanceof Object)\r\nexports.isArray = (arr) => !arr ? false : Array.prototype === (arr).__proto__\r\nexports.isString = (str) => !str ? false : String.prototype === (str).__proto__\r\nexports.isFunction = (el) => typeof el === 'function'\r\n\r\nexports.copy = (data) => {\r\n    if (!data) return data\r\n    try {\r\n        return JSON.parse(JSON.stringify(data))\r\n    } catch (err) {\r\n        return err.toString()\r\n    }\r\n}\r\n\r\n/**\r\n* - accepting object of messages, example: `{'001':['my message',001],...}`\r\n* - returns : {'001':{message,code},...}\r\n*/\r\nexports.errorMessages = (messages) => {\r\n    const msgs = {}\r\n    for (let [k, v] of Object.entries(messages)) {\r\n        msgs[k] = { message: v[0], code: k }\r\n    }\r\n    return msgs\r\n}\r\n// NOTE for compilation we have `es2015` set\r\nif (process.env.NODE_ENV === \"production\" || process.env.NODE_ENV === 'development') {\r\n\r\n    exports.log = function (...args) {\r\n        args = [].concat('[Pocket]', args)\r\n        console.log.apply(null, args)\r\n    }\r\n    exports.warn = function (...args) {\r\n        args = [].concat('[warning]', args)\r\n        console.warn.apply(null, args)\r\n    }\r\n    exports.onerror = function (...args) {\r\n        args = [].concat('[error]', args)\r\n        console.log('  ')\r\n        console.error.apply(null, args)\r\n        console.log('  ')\r\n    }\r\n} else {\r\n    // when executing normally with node\r\n    const util = require('util')\r\n    const color = require('bash-color')\r\n\r\n    exports.log = function (...args) {\r\n        args = [].concat('[Pocket]', args)\r\n        args = args.map(z => util.inspect(z, false, 3, true))\r\n        console.log.apply(null, args)\r\n    }\r\n    exports.warn = function (...args) {\r\n        args = [].concat('[warning]', args)\r\n        args = args.map(z => color.cyan(util.inspect(z, false, 2, false), true))\r\n        console.warn.apply(null, args)\r\n    }\r\n    exports.onerror = function (...args) {\r\n        args = [].concat('[error]', args)\r\n        args = args.map(z => color.red(util.inspect(z, false, 2, false), true))\r\n        console.log('  ')\r\n        console.error.apply(null, args)\r\n        console.log('  ')\r\n    }\r\n}\r\n","\r\n/**\r\n * requirejs global event handler\r\n */\r\nmodule.exports = function (_uid, _debug = null) {\r\n    return (new function (uid, debug) {\r\n        const plugin = `[dispatcher]`\r\n        this.uid = (uid || '').toString() || new Date().getTime()\r\n        this.debug = debug\r\n        this.cbQueue = {}\r\n        this.dispatchInstance = {}\r\n\r\n        this.initListener = () => {\r\n            this.Dispatch()\r\n            return this\r\n        }\r\n        /**\r\n         * @next\r\n         * send next data to the `batchReady` callback\r\n         * @param {*} data # optional\r\n         */\r\n        this.next = (data = null) => {\r\n            if (this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid].next(data)\r\n            else {\r\n                if (this.debug) console.log({ message: `${plugin} for uid not available`, uid: this.uid })\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * @Dispatch\r\n         * master listener, sends all event callbacks to `batchReady`\r\n         */\r\n        this.Dispatch = () => {\r\n            if (this.dispatchInstance[this.uid]) return this\r\n            const self = this\r\n            const D = function () {\r\n                this.uid = self.uid\r\n                this.data = null\r\n\r\n                this.next = (data) => {\r\n                    if ((data || {}).type !== 'cb') this.data = data\r\n                    /**\r\n                         * @next\r\n                         * acts as a reverse callback, it sends back the `cb` from `batchReady`\r\n                         */\r\n                    if ((data || {}).type === 'cb') {\r\n                        if (typeof data.cb === 'function') {\r\n                            // when calling next before batchReady is initiated\r\n                            // collect cb from .next\r\n                            if (!self.cbQueue[self.uid]) self.cbQueue[self.uid] = data.cb\r\n                            if (this.data) data.cb.call(self, this.data, self.uid)\r\n                        }\r\n\r\n                        return\r\n                    }\r\n\r\n                    if (this.data) {\r\n                        if (typeof self.cbQueue[self.uid] === 'function') self.cbQueue[self.uid].call(self, this.data, self.uid)\r\n                    } else {\r\n                        if (this.debug) console.log(`${plugin} no callback data`)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid] = new D()\r\n            return this\r\n        }\r\n\r\n        this.isActive = () => {\r\n            return !!this.dispatchInstance[this.uid]\r\n        }\r\n\r\n        this.del = () => {\r\n            delete this.cbQueue[this.uid]\r\n            delete this.dispatchInstance[this.uid]\r\n\r\n            if (!this.cbQueue[this.uid] && !this.dispatchInstance[this.uid]) {\r\n                // if (this.debug) console.log(`cbQueue and dispatchInstance for uid ${this.uid} deleted`)\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n     * @subscribe\r\n     * wait for callbacks forwarded from Dispatch and returned in callback of this method\r\n     * - Dispatch must be set initially before you call `subscribe`\r\n     * @param {*} cb #required\r\n     */\r\n        this.subscribe = (cb) => {\r\n            const isFN = typeof cb === 'function'\r\n            if (!isFN) {\r\n                if (this.debug) console.log(`${plugin}[batchReady] cb must be set`)\r\n                return this\r\n            }\r\n            if (!this.dispatchInstance[this.uid]) {\r\n                // this means batchReady was executed prior to `Dispatch`, because it has forward with next\r\n                // it will get executed anyway\r\n                this.Dispatch()\r\n            }\r\n            if (this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid].next({ type: 'cb', cb })\r\n            return this\r\n        }\r\n    }(_uid, _debug))\r\n}\r\n","module.exports = require('./simple-q')","/* eslint-disable no-undef */\r\n// for es2015/ or below browser loading\r\nwindow.Pocket = () => require('../Pocket.module').PocketModule()\r\n","exports.PocketModule = () => {\r\n    // const messageCODE = require('./errors') // DISPLAY MESSAGES WITH CODE\r\n    const { objectSize, log, onerror, warn, isArray, isObject, isPromise, validID, isString } = require('./utils')\r\n    const sq = require('simple-q') // nice and simple promise/defer by `eaglex.net`\r\n    const PocketLibs = require('./Pocket.libs')()\r\n    const newProbe = require('./Probe').Probe\r\n\r\n    /**\r\n     * TODO ADD to $update `// action/[merge], action/+-*` using regEx\r\n     */\r\n\r\n    class PocketModule extends PocketLibs {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n            if (this.dispatcher) {\r\n                this.dispatcher.initListener().subscribe((z, id) => {\r\n                    const { probe, status } = z || {}\r\n\r\n                    if (status === 'error') {\r\n                        // NOTE dispatch data out\r\n                        if (this.debug) log(`[dispatcher] probe id:${probe.id} error`)\r\n                    }\r\n\r\n                    if (status === 'open') {\r\n                        if (this.debug) log(`[dispatcher] probe id:${probe.id} created`)\r\n                    }\r\n\r\n                    if (status === 'complete') {\r\n                        // NOTE dispatch data out\r\n                        if (this.debug) log(`[dispatcher] probe id:${probe.id} completed`)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        // \r\n        //   :::::: U S E R   A P P L I C A T I O N   C A L L I N G   M E T H O D S : :  :   :    : \r\n        // \r\n        //\r\n\r\n        /**\r\n         * @memberof $payload\r\n         */\r\n        payload(data = {}, async, type = 'new') {\r\n            this.d = null\r\n            let isUpdated = null\r\n\r\n            // validate payload format\r\n            if (!isObject(data)) return false\r\n\r\n            const keys = Object.keys(data)\r\n            // must match all keys\r\n            if (keys.every(el => ['id', 'tasks'].indexOf(el) === -1)) {\r\n                if (this.debug) onerror(`[$payload] id and tasks are required`)\r\n                return false\r\n            }\r\n            if (!isArray(data['tasks'])) {\r\n                if (this.debug) onerror(`[$payload] data.tasks must be an array`)\r\n                return false\r\n            }\r\n\r\n            data.id = this.validProjectID(data.id)\r\n\r\n            if (!data.id) {\r\n                if (this.debug) onerror(`[$payload] data.id invalid`)\r\n                return false\r\n            }\r\n\r\n            if (this.payloadData[data.id] && (!type || type === 'new')) {\r\n                this._lastProjectID = data.id\r\n                // if (this.debug) warn(`[$payload] this payload.id already exists`)\r\n                return true\r\n            }\r\n\r\n            let initialProject = this.payloadData[data.id] === undefined // because there is no data set as of yet\r\n\r\n            // NOTE on update/new of project we need to reset $filter values, in case \r\n            if ((this._lastFilterList[data.id] || []).length) this._lastFilterList[data.id] = []\r\n\r\n            // NOTE validate our pocket values before generating each `new Probe()`\r\n            for (let val of data['tasks'].values()) {\r\n                if (!val['task']) {\r\n                    if (this.debug) warn('[$payload] task must be set for your tasks')\r\n                    continue\r\n                }\r\n                // validate task \r\n                if (!this.idRegexValid(val['task']) || val['task'].indexOf('::') !== -1) {\r\n                    if (this.debug) warn('[$payload] invalid taskName, failed idRegexValid validation')\r\n                    continue\r\n                }\r\n                \r\n                const probeID = `${data.id}::${val['task']}`\r\n                if (type === 'update' && !initialProject && this.pocket[probeID]) {\r\n                    if (val['data']) this.pocket[probeID]['data'] = val['data']    \r\n                    if (val['status']) this.pocket[probeID]['status'] = val['status']    \r\n\r\n                    // NOTE in case we update status in case it wasnt provided but new data was assigned\r\n                    // status should only be changed after data is set\r\n                    if (!val['status'] && val['data'] && this.pocket[probeID]['status'] === 'open') {\r\n                        this.pocket[probeID]['status'] = 'updated'\r\n                    }\r\n                    if (val['ref']) this.pocket[probeID]['ref'] = val['ref']\r\n                    if (val['error']) this.pocket[probeID]['error'] = val['error']\r\n                    if (val['campaign']) this.pocket[probeID]['campaign'] = val['campaign']\r\n                    \r\n                    isUpdated = true\r\n                    this._lastProjectID = data.id\r\n                    // NOTE after update, payloadData will differ from new Probe{} data\r\n                    // NOTE do not update `payloadData` it is redundant if we donot need it for anything, only update Probes{}\r\n                    /// this.payloadData[data.id]['value']\r\n                    // an existing project do not everride\r\n\r\n                    continue\r\n                }\r\n\r\n                if (!this.payloadData[data.id]) this.payloadData[data.id] = { value: [], status: 'open', timestamp: new Date().getTime() }\r\n                const exists = this.payloadData[data.id]['value'].filter(z => z.task.indexOf(val.task) !== -1)\r\n                if (exists.length) {\r\n                    if (this.debug && !this.disableWarnings) warn(`the same task \"${val.task}\" already exists on the payload, you must choose uniq`)\r\n                    continue\r\n                }\r\n\r\n                this.payloadData[data.id]['value'].push(val)\r\n                this.lastPocketTimestamp = this.payloadData[data.id]['timestamp']\r\n            }\r\n\r\n            // only when updating existance of Probe{}\r\n            if (type === 'update' && this.payloadData[data.id] && !initialProject) {\r\n                this.projectsCache[data.id] = 'open'\r\n                return isUpdated\r\n            }\r\n\r\n            if (this.payloadData[data.id]) {\r\n                this.lastProjectID(data.id)\r\n                this.projectsCache[data.id] = 'open' // means created project\r\n                this.distributor()\r\n                    .setDefer(data.id)\r\n                // NOTE required in order for $projectSetAsync to retrun callback to resolve our promise\r\n                this.projectSetDispatcher(data.id).initListener().next({ projectID: data.id })\r\n                return true\r\n            } else return false\r\n        }\r\n\r\n        /**\r\n         * ### $projectSetAsync\r\n         * - usage: to call before `$project()/$payload()/$architect` were called\r\n         * - for example you have loaded same `Pocket` instance in another part of your code, now checking for it  in future before $project created. This method can `await $projectSetAsync(projectID)` and continue with already set `$project(...).$get(..).$update(..)` etc\r\n         * @param {*} projectID required, this is your `$project/$payload` id\r\n         */\r\n        $projectSetAsync(projectID = '') {\r\n            const self = this\r\n            projectID = this.lastProjectID(projectID, false, null)\r\n            if (this._projectSetAsync[projectID]) {\r\n                return this._projectSetAsync[projectID].promise()\r\n            }\r\n            /**\r\n             * will subscribe when called the first time and set our simple promise then resolve once the `$payload` is succesfull\r\n             */\r\n            this._projectSetAsync[projectID] = sq()\r\n            this.projectSetDispatcher(projectID).initListener().subscribe(function (z, id) {\r\n                self._projectSetAsync[id].resolve(z)\r\n                this.del() // deletes projectSetDispatcher of self \r\n            })\r\n            return this._projectSetAsync[projectID].promise()\r\n        }\r\n\r\n        /**\r\n         * @memberof probeStatusAsync\r\n         */\r\n        probeStatusAsync(probeID = '') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            probeID = this.lastProbeID(probeID)\r\n            if (!probeID) return returnAs(null)\r\n            return returnAs(this.pocket[probeID].getStatusAsync)\r\n        }\r\n\r\n        /**\r\n         * @memberof $update\r\n         */\r\n        update(dataFrom, mergeData = null, probeID = '') {\r\n            return this._setUpdate(dataFrom, mergeData, probeID, 'update')\r\n        }\r\n\r\n        /**\r\n         * @memberof $set\r\n         */\r\n        _set(dataFrom, probeID = '') {\r\n            return this._setUpdate(dataFrom, null, probeID, 'set')\r\n        }\r\n\r\n        /**\r\n         * - declated via $get\r\n         * @memberof $get\r\n         */\r\n        _get(probeID = '', self = false) {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return self ? this : this.d\r\n            }\r\n\r\n            this.d = null\r\n            probeID = this.lastProbeID(probeID)\r\n            if (!probeID) return returnAs(null)\r\n            else return returnAs(this.pocket[probeID])\r\n        }\r\n\r\n        /**\r\n         * ### $activeTasks\r\n         * - list any active tasks for assigned Probes\r\n         * @param {*} payloadID optional, when set will only filter thru given job id (NOT Probe{} ID!)\r\n         */\r\n        $activeTasks(payloadID = '') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            payloadID = this.lastProjectID(payloadID)\r\n            if (!objectSize(this.pocket)) return returnAs([])\r\n            let tasks = Object.entries(this.pocket).reduce((n, [probeID, probe]) => {\r\n                if (probeID.indexOf(payloadID || '') === 0 && payloadID && this.payloadData[payloadID]) n.push(probe['task'])\r\n                else if (!payloadID) n.push(probe['task'])\r\n                return n\r\n            }, [])\r\n            return returnAs(tasks)\r\n        }\r\n\r\n        /**\r\n         * @memberof $ready\r\n         */\r\n        ready(payloadID = '') {\r\n            this.d = null\r\n\r\n            if (!this._ready[payloadID]) throw (`ready[payloadID] is not set, maybe you called it before $payload()`)\r\n            return this._ready[payloadID].promise()\r\n        }\r\n\r\n        //\r\n        // \r\n        //   :::::: E N D : :  :   :    :     :        :          \r\n        //   \r\n\r\n        // extends  `$update` and `$set`\r\n        _setUpdate(dataFrom, mergeData = null, probeID = '', type = 'update') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            let id = this.lastProbeID(probeID)\r\n            if (!id) {\r\n                if (this.debug) onerror(`[$update] must specify id`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            if (!isObject(dataFrom)) {\r\n                if (this.debug) warn(`[$update] dataFrom must be an Object`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            if (!this.pocket[id]) {\r\n                if (this.debug) onerror(`[$update] this.pocket with id:${id} not found`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            let updated = false\r\n            this._lastProjectID = id\r\n            // reorder dataFrom, make sure if `status` exists, it is shifted to last position, so the Probe{} doent change state before other values got chance to do so, nice!\r\n\r\n            // we need to convert dataFrom{} to dataFrom[]>array to achieve this\r\n            dataFrom = Object.entries(dataFrom).reduce((n, [key, value]) => {\r\n                const pos = this.probeProps.indexOf(key) // new order\r\n                if (this.probeProps[pos] === key) n.push({ inx: pos, data: { [key]: value } })\r\n                return n\r\n            }, [])\r\n\r\n            for (let inx = 0; inx < dataFrom.length; inx++) {\r\n                if ((dataFrom[inx] || {})['data'] === undefined) continue\r\n                const [key, value] = Object.entries(dataFrom[inx]['data'])[0]\r\n                if (this.pocket[id][key] !== undefined) {\r\n                    if (key === 'data') {\r\n                        if (mergeData === true) this.pocket[id][key] = Object.assign({}, this.pocket[id][key], value)\r\n                        else this.pocket[id][key] = value\r\n                    } if (key === 'status' || key === 'ref' || key === 'error' || key === 'campaign') this.pocket[id][key] = value\r\n                    updated = true\r\n                    continue\r\n                } else {\r\n                    if (this.debug) warn(`[$update] not a valid prop/value: { ${key}:${this.pocket[id][key]} }`)\r\n                }\r\n            }\r\n            // when setting new data, using `$set()` we should clear any cached Probes and realated data\r\n            if (updated && type === 'set') {\r\n                this.clearStoreTransfers(id)\r\n                if (this.$transfer_lastID === id) this.$transfer_lastID = ''\r\n                if (this._$cached_data[id]) delete this._$cached_data[id]\r\n            }\r\n\r\n            // if(updated && type==='update') { }\r\n            return returnAs(updated)\r\n        }\r\n\r\n        /**\r\n         * - sets defer for `$ready()` initially after calling payload \r\n         * @param {*} id required\r\n         */\r\n        setDefer(id) {\r\n            id = validID(id)\r\n            if (!id) throw 'id must be set'\r\n\r\n            if (!this._ready[id]) this._ready[id] = sq()\r\n\r\n            if (!objectSize(this.pocket)) {\r\n                const msg = `[setDefer] probe is empty, so nothing set, id:${id}`\r\n                if (this.debug) onerror(msg)\r\n                this._ready[id].reject(msg)\r\n                return null\r\n            }\r\n\r\n            const pocketSet = Object.values(this.pocket).filter(z => z.id.indexOf(id) !== -1)\r\n            if (!pocketSet.length) {\r\n                const msg = `[setDefer] no pocketSet found for id:${id} `\r\n                if (this.debug) onerror(msg)\r\n                this._ready[id].reject(msg)\r\n                return null\r\n            }\r\n\r\n            try {\r\n                const userOutput = (pock) => {\r\n                    const output = {}\r\n                    if (!isObject(pock)) return null\r\n                    for (let i = 0; i < this.probeProps.length; i++) {\r\n                        const prop = this.probeProps[i]\r\n                        if (pock[prop] !== undefined && pock[prop] !== null) output[prop] = pock[prop]\r\n                    }\r\n                    return output\r\n                }\r\n                /**\r\n                 * IMPORTANT:\r\n                 * when our pocketSet for each this.pocket[id] is marked 'complete'\r\n                 * `Probe().resolve(...)` is called, and Promise.all is waiting for `pocketSet` to complete\r\n                 */\r\n                Promise.all(pocketSet.map(z => z.sq.promise())).then(z => {\r\n                    const output = z.map(p => userOutput(p.probe)).filter(n => !!n)\r\n                    this._ready[id].resolve(output)\r\n                }, err => {\r\n                    // should unlikely happen since we dont have any rejects set\r\n                    onerror(`[setDefer] Promise.all`, err)\r\n                })\r\n\r\n                return true\r\n            } catch (err) {\r\n                onerror(`[setDefer]`, err)\r\n            }\r\n\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * - distribute payloadData, each to `new Probe()`\r\n         */\r\n        distributor() {\r\n            for (let [key, el] of Object.entries(this.payloadData)) {\r\n                if (this.lastPocketTimestamp > el['timestamp']) continue // no new entries\r\n\r\n                // omit done\r\n                if (el.status === 'complete' || el.status === 'send' || el.status === 'error') continue\r\n\r\n                for (let value of el.value.values()) {\r\n                    const pl = { id: key, ...value }\r\n                    const pocketSet = this.setProbe(pl)\r\n                    if (!pocketSet) onerror(`probe for id:${key} already exists`)\r\n                }\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - every new probe `id` must be: format `id:::taskName`\r\n         * required: `{id,task}`\r\n         * optional: `{campaign}`\r\n         * @param {*} opts\r\n         */\r\n        setProbe(opts = {}) {\r\n            if (!opts.id || !opts.task) throw ('id and task both must be set')\r\n            if (!validID(opts.id)) throw ('opts.id not valid')\r\n\r\n            const uid = `${opts.id}::${opts.task}`\r\n            if (this.pocket[uid]) {\r\n                if (this.debug) log(`[setProbe] probe: ${uid} already set`)\r\n                return null\r\n            }\r\n            try {\r\n                opts.id = uid\r\n                const emitter = this.dispatcher !== null ? this._emit.bind(this) : null\r\n                const p = new this.Probe(opts, {\r\n                    disableWarnings: this.disableWarnings, // disable some less relevant warning messages\r\n                    onChange: this._onChange, \r\n                    emitter, \r\n                    completeOnNull: this.completeOnNull }, this.debug)\r\n                this.pocket[uid] = p\r\n            } catch (err) {\r\n                onerror(err)\r\n                return null\r\n            }\r\n            return this.pocket[uid]\r\n        }\r\n\r\n        /**\r\n         * set new probe model\r\n         * - every new task has a set of requirements. Once status is `complete` and data available, probe sends a dispatch with probe information `(if opts.dispatcher===true)`.\r\n         * methods:`{get,all}` props: `{id,data,task,status,campaign}`\r\n         * \r\n         *  @param {*} opts.id required\r\n         *  @param {*} opts.task required\r\n         *  @param {*} opts.campaign optional\r\n         * \r\n         * - `Probe` is resolved once `sq.resolve()` is called, sq => `Simple Q` our plugin\r\n         * @memberof Probe.js module\r\n         */\r\n        get Probe() {\r\n            return newProbe()\r\n        }\r\n\r\n        /**\r\n         * - emit extends with `Dispatcher` to be used by every new Probe{} as an emitter `(if opts.dispatcher===true)`\r\n         * @param {*} obj required\r\n         */\r\n        _emit(obj) {\r\n            if (!obj) return null\r\n            if (!this.dispatcher) return null\r\n            try {\r\n                this.dispatcher.initListener().next(obj)\r\n                return true\r\n            } catch (err) {\r\n                onerror(`[_emit] dispatcher did not emit`)\r\n                return null\r\n            }\r\n        }\r\n\r\n        /**\r\n         * - delete completed `pocketSet`\r\n         */\r\n        deletePocketSet(id) {\r\n            if (!id) return\r\n            if (Object.values(this.pocket).length) {\r\n                for (let poc of Object.values(this.pocket)) {\r\n                    if (this._$cached_data[poc.id]) delete this._$cached_data[poc.id]\r\n                    if (poc.id.includes(id)) delete this.pocket[poc.id]\r\n                }\r\n            }\r\n            if (this.payloadData[id]) delete this.payloadData[id]\r\n            if (this._ready[id]) delete this._ready[id]\r\n\r\n            // these  two are together\r\n            if (this._projectSetDispatcher[id] !== undefined) delete this._projectSetDispatcher[id]\r\n            if (this._projectSetAsync[id]) delete this._projectSetAsync[id]\r\n            if (this._lastFilterList[id]) delete this._lastFilterList[id]\r\n\r\n            // from PocketArchitect dynamicly assigned\r\n            try {\r\n                if (this.architectConfig[id]) delete this.architectConfig[id]\r\n            } catch (err) {\r\n                // blah\r\n            }\r\n\r\n            // empty self\r\n            this.clearStoreTransfers(id)\r\n        }\r\n    }\r\n\r\n    class PocketModuleExt extends PocketModule {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n        }\r\n\r\n        /**\r\n         * ### $removeProject\r\n         * - removes all Probes and references relating to `projectID`\r\n         * @param {*} projectID \r\n         */\r\n        $removeProject(projectID) {\r\n            projectID = !isString(projectID) ? '' : projectID\r\n            projectID = this.lastProjectID(projectID) // also updates last selector reference\r\n            this.deletePocketSet(projectID)\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - you can also use it on concurent payloads to existing `projectID`, once initial project is created overy other call will update each Probe{}.data/status, based on payloadData\r\n         * @param {*} data `required`\r\n         * @param {*} async `override current opts.sync for this payload`\r\n         * @param {*} type optional, new/update, `update`: if we call on an existing project we can update `data/status properties` of all assigned tasks at once\r\n         * \r\n         * - `initialize new payload, for as many tasks`\r\n         * - `sets a multi task with instructions:`\r\n         * - `data = {\r\n                id: '', // 1 id for all tasks\r\n                tasks: [{ taskName: '', data: '', campaign: '' }]\r\n            }`\r\n\r\n         * - `call distributor and setDefer`\r\n         * @extends payload\r\n         */\r\n        $payload(data, async, type) {\r\n\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n            const asAsync = async !== undefined ? async : this.async // override if set\r\n            if (asAsync && isPromise(data)) return returnAs(data.then(z => this.payload(z, false, type), err => err))\r\n            if (!asAsync && !isPromise(data)) return returnAs(this.payload(data, false, type))\r\n            else {\r\n                if (this.debug) onerror(`[payload] with opts.async=true, data must be a promise, or do not set async when not a promise`)\r\n                if (asAsync) return returnAs(Promise.reject())\r\n                else return returnAs(false)\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $project\r\n         * - `an alias on $payload(...), can use either`\r\n         * - refer to `$payload` for specifications :)\r\n         * @extends $payload\r\n         */\r\n        $project(...args) {\r\n            return this.$payload(...args)\r\n        }\r\n\r\n        /**\r\n          * - resolves currently active `$payload(...)`\r\n          * - `after completion of Pocket, instance data for all Probes is deleted`\r\n          * - can be called even before project was declared thanks to callback dispather `$projectSetAsync()`\r\n          * @param {*} payloadID ,required\r\n          * @param allowsMultiple optional, when set to true will allow multiple calls to resolved data\r\n          * @extends ready\r\n          */\r\n        $ready(payloadID, allowsMultiple = false) {\r\n\r\n            try {\r\n\r\n                const returnAs = (val) => {\r\n                    this.d = val\r\n                    if (this.d && !allowsMultiple) this.d.catch(warn)\r\n                    return this\r\n                }\r\n\r\n                // sofl validation for non existant `payloadID` if called before declaration of a project\r\n                let _payloadID = this.lastProjectID(payloadID, false, null)\r\n                if (!payloadID && _payloadID) payloadID = _payloadID // grab last assigned id incase provided none\r\n\r\n                // in case it was called the second time, when already resolved!\r\n                if (this.projectsCache[payloadID] === 'complete' && !allowsMultiple) {\r\n                    return returnAs(Promise.reject(`[$ready] project: ${payloadID} already complete`))\r\n                }\r\n\r\n                if (this._ready_method_set[payloadID] !== undefined && !allowsMultiple) {\r\n                    if (this._ready_method_set[payloadID] === true) {\r\n                        return returnAs(Promise.reject(`[$ready] project: ${payloadID} already complete, cannot recall same $ready`))\r\n                    }\r\n                    if (this._ready_method_set[payloadID] === false) {\r\n                        return returnAs(Promise.reject(`[$ready] project: ${payloadID} you already declared $ready somewhere else, this call is ignored`))\r\n                    }\r\n                }\r\n\r\n                if (!_payloadID) throw (`payloadID must be set`)\r\n\r\n                // we wrap it if on ready project so it allows declaring `${$ready()}` even before $project was created, cool ha!\r\n                const p = this.$projectSetAsync(_payloadID).then(({ projectID }) => {\r\n                    return this.ready(projectID).then(z => {\r\n\r\n                        // NOTE to help problems with loops and using chaining with last selector\r\n                        // will gradualy delete project with specified timeout\r\n                        if (!this.deleteWithDelay) this.deletePocketSet(projectID)\r\n                        else {\r\n                            setTimeout(() => {\r\n                                this.deletePocketSet(projectID)\r\n                            }, this.deleteWithDelay)\r\n                        }\r\n\r\n                        this.projectsCache[projectID] = 'complete'\r\n                        this._ready_method_set[_payloadID] = true\r\n\r\n                        return z\r\n                    }, Promise.reject)\r\n                    \r\n                }, Promise.reject)\r\n\r\n                this._ready_method_set[_payloadID] = false\r\n                return returnAs(p)\r\n\r\n            } catch (error) {\r\n                if (!this.disableWarnings) onerror(error)\r\n                \r\n            }\r\n        }\r\n    }\r\n    const PocketArchitect = require('./Pocket.architect')(PocketModuleExt)\r\n    const PocketSelectors = require('./Pocket.selectors')(PocketArchitect)\r\n    return PocketSelectors\r\n}\r\n","`use strict`\r\n/**\r\n * SimpleQ\r\n * Developer: Eaglex ( http://eaglex.net ) \r\n * License: CC BY-SA ( https://creativecommons.org/licenses/by/4.0/legalcode )\r\n * - Simple Promise defer\r\n */\r\nfunction SimpleQ() {\r\n    \r\n    return new function() {\r\n        const promises = {}     \r\n        let __deferSet = null   \r\n        const defer =  new Promise((resolve, reject) => {\r\n            promises['resolve']= resolve      \r\n            promises['reject']= reject     \r\n        })\r\n\r\n        this.resolve = (data = null) => {\r\n            if (__deferSet) return this // already set\r\n            promises['resolve'](data)\r\n            __deferSet = true\r\n            return this\r\n        }\r\n\r\n        this.reject = (data = null) => {\r\n            if (__deferSet) return this // already set\r\n            promises['reject'](data)\r\n           __deferSet = true\r\n            return this\r\n        }\r\n\r\n        this.promise = () =>  defer     \r\n    }\r\n}\r\n\r\nmodule.exports = SimpleQ","/**\r\n * ### PocketLibs\r\n * - Top of the stack class of `PocketModule`, all `opt` initial `properties` are set here\r\n */\r\nmodule.exports = () => {\r\n    const { objectSize, warn, onerror, validID, copy, log, isString } = require('./utils')\r\n    return class PocketLibs {\r\n        /**\r\n         * @param {*} opts.async, when set, allow $payload(`data`) to be async object\r\n         * @param {*} opts.dispatcher, when set to true, loads external library `Dispatcher`\r\n         * @param {*} debug optional\r\n         */\r\n        constructor(opts = {}, debug) {\r\n            this.debug = debug || false\r\n            this.async = (opts || {}).async || null\r\n            this._onChange = (opts || {}).onChange || null // loads watch for changes Probe asset \r\n            this.completeOnNull = (opts || {}).completeOnNull || null // Allow Probe to complete even if data is null\r\n            this.disableWarnings = (opts || {}).disableWarnings // disable some less relevant warning messages\r\n\r\n            // when set enables dispatcher to communicate directly with `probe.js`\r\n            this.dispatcher = (opts || {}).dispatcher ? require('../libs/dispatcher')() : null\r\n            this.pocket = {} // example this.pocket[`abc::taskName`] returns Probe{} Instance\r\n            this.payloadData = {}// each payload by id\r\n            this.lastPocketTimestamp = 0\r\n            this._lastProjectID = null // last cached reference\r\n            this._lastProbeID = null // last cached reference\r\n            this._$cached_data = {/** id:{} */ }// stores last captured data when calling `$data(..)`\r\n            this.$transfer_lastID = '' // set when we call `$transfer()` and reset after `$to()`\r\n            this._ready = {} // collect all ready example: `{id:Promise}`\r\n            this._ready_method_set = {/** [id]:true */}// ignore subsequent calls to $ready method \r\n            this.d = undefined // NOTE user reference data, carefull when using selectors from previous target, always access last\r\n            this._projectSet = {/** projectID:promise */ }\r\n            this._transferCached = [ /** {timestamp,fromProbeID,data} */]\r\n            this._projectSetDispatcher = {/** id:dispatcher */ }\r\n            this._projectSetAsync = {/** id:SQ */ } // collect all $projectSetAsync promisses\r\n            this._lastFilterList = {/** id:[probe references only] */ }\r\n            this.projectsCache = {/** [id]:'open/complete' */}// keep reference of completed projects, this variable is never purged\r\n            this.deleteWithDelay = (opts || {}).deleteWithDelay || 1000// after project is completed and $ready(..) is resolved set delay to when it should be deleted\r\n            // this.createArchitect() // only when pocketInstance is set\r\n        }\r\n\r\n        // NOTE abolished functional class, doesnt work well with es6 class\r\n        // createArchitect() {\r\n        //     if (this.architect && !this[\"architect_set\"]) {\r\n        //         try {\r\n        //             const Architect = require('./Pocket.architect')()\r\n        //             Architect.prototype = Object.create(this)\r\n        //             Architect.prototype.constructor = Architect             \r\n        //             Object.assign(this, new Architect())\r\n        //         } catch (err) {\r\n        //             console.log(`[createArchitect] error`, err)\r\n        //         }\r\n\r\n        //         this[\"architect_set\"] = true\r\n        //     }\r\n        // }\r\n\r\n        /**\r\n         * - return latest Probe by reference from `this._lastFilterList[projectID]`\r\n         * @param {*} projectID \r\n         */\r\n        // getProbesByFilterRef(projectID) {\r\n        //     if (!projectID) return []\r\n        //     if (!this._lastFilterList[projectID]) return []\r\n        //     return this._lastFilterList[projectID].reduce((n, ref, inx) => {\r\n        //         if (ref.id && ref.isNONE === undefined && this.pocket[ref.id]) n.push(this.pocket[ref.id])\r\n        //         else if (this.pocket[ref.id]) n.push({ id: ref.id, isNONE: true })\r\n        //         return n\r\n        //     }, []).filter(z => !!z)\r\n        // }\r\n\r\n        /**\r\n         * ### projectSetDispatcher\r\n         * - create new dispather to act as a callback for setting new projects in future. NOTE once project is created and using $architect /$project/$payload to update will not recreate `projectSetDispatcher`\r\n         * - works with `$projectSetAsync`\r\n         * @param {*} projectID \r\n         */\r\n        projectSetDispatcher(projectID) {\r\n            if (!projectID) {\r\n                if (this.debug) onerror(`[projectSetDispatcher] projectID must be set`)\r\n                return null\r\n            }\r\n            if (this._projectSetDispatcher[projectID]) return this._projectSetDispatcher[projectID]\r\n            if (!this._projectSetDispatcher[projectID]) this._projectSetDispatcher[projectID] = require('../libs/dispatcher')(projectID)\r\n            return this._projectSetDispatcher[projectID]\r\n        }\r\n\r\n        /**\r\n         * @param {*} projectID\r\n         * @returns array [Probe{},...] of selected project\r\n         */\r\n        projectProbeList(projectID) {\r\n            if (!projectID) return []\r\n            return Object.entries(this.pocket).filter(([id]) => id.indexOf(projectID) === 0).map(([id, probe]) => probe)\r\n        }\r\n\r\n        /**\r\n         * ### clearStoreTransfers\r\n         * - clear any pending transfers\r\n         * @param {*} projectID required\r\n         */\r\n        clearStoreTransfers(projectID = '') {\r\n            if (!projectID) return\r\n            let cleared = false\r\n            if (this._transferCached.length) {\r\n                this._transferCached.forEach((element, i) => {\r\n                    const { fromProbeID } = element || {}\r\n                    if (!fromProbeID) return\r\n                    if (fromProbeID.indexOf(projectID) !== -1) {\r\n                        this._transferCached.splice(i, 1)\r\n                        cleared = true\r\n                        if (this.debug) log(`[clearStoreTransfers] transferCached for probeID: ${fromProbeID} has been removed`)\r\n                    }\r\n                })\r\n            }\r\n            return cleared\r\n        }\r\n        /**\r\n         * ### storeTransfers\r\n         * - caches pending transfers when using `$transfer` with `$to()`\r\n         * - access last data by timestamp\r\n         * @param {*} fromProbeID  required\r\n         * @param {*} data required\r\n         */\r\n        storeTransfers(fromProbeID, data) {\r\n            this._transferCached.push({ timestamp: new Date().getTime(), fromProbeID, data })\r\n            return this._transferCached\r\n        }\r\n\r\n        /**\r\n         * ### accessLastValidTransfer\r\n         * returns latest transfer that is inRange from `fromAverageTimeHasPast` in `ms` vs current Date.getTime\r\n         * - removes _transferCached that was found \r\n         */\r\n        accessLastValidTransfer(fromAverageTimeHasPast = 100) {\r\n            if (!this._transferCached.length) return {}\r\n\r\n            this._transferCached.sort((a, b) => a.timestamp - b.timestamp)\r\n            const transferCachedCopy = copy(this._transferCached)\r\n\r\n            const coundCache = transferCachedCopy.reduce((n, el, i) => {\r\n                const { timestamp } = el\r\n\r\n                // calculate max wait between transfers, so if we have timeout we can only wait as long as `fromAverageTimeHasPast` \r\n                const currentOffset = new Date().getTime() + fromAverageTimeHasPast\r\n                const diff = (currentOffset - timestamp) - fromAverageTimeHasPast\r\n                const timeInRange = (currentOffset > timestamp) && diff <= fromAverageTimeHasPast\r\n                if (timeInRange) {\r\n                    n = el\r\n                    // delete found cache\r\n                    this._transferCached.splice(i, 1)\r\n                }\r\n                return n\r\n            }, {})\r\n\r\n            if (!objectSize(coundCache)) return {}\r\n            else return coundCache\r\n        }\r\n\r\n        /**\r\n         * ### selectByTask\r\n         * - works with `PocketSelectors class`, when `::taskNames, taskName` are specified, extracts full probeID by matching previous pointer reference and updates `lastProbeID()`        \r\n         * - returns valid probeID or null\r\n         * @param {*} probeID {*} required, but optional\r\n         */\r\n        selectByTask(taskOrProbeID = '', updateLastProbeID = null) {\r\n            taskOrProbeID = !isString(taskOrProbeID) ? '' : taskOrProbeID\r\n            if (!this.idRegexValid(taskOrProbeID) && taskOrProbeID) return null\r\n            if (taskOrProbeID.indexOf(':') > 0 && !this.pocket[taskOrProbeID]) {\r\n                if (this.debug) warn(`[selectByTask] when using '::' prefix selector, it should come at 0 index`)\r\n                return null\r\n            }\r\n\r\n            if (taskOrProbeID.split(\":\").length > 3 || taskOrProbeID.split(\":\").length === 2) {\r\n                if (this.debug) warn(`[selectByTask] wrong taskName :${taskOrProbeID}, allowed prefix is '::taskName'`)\r\n                return null\r\n            }\r\n\r\n            if (updateLastProbeID) this.lastProbeID(taskOrProbeID, true) // if a match we receive below updated `_lastProbeID` \r\n            if (this.pocket[taskOrProbeID]) {\r\n                if (updateLastProbeID) this.lastProbeID(taskOrProbeID)\r\n                return taskOrProbeID // we have a valid ref so use that\r\n            }\r\n\r\n            /**\r\n             * - generate valid probeID `${projectID}::${probeTaskName}` //\r\n             */\r\n            const dynamicProbeID = (name) => {\r\n                const n = name.split(\"::\")[1] || name // in case we are using prefixed taskName, example \"::cocacola\"\r\n                const matchByProbeID = (this._lastProbeID || '').indexOf(n) > 0\r\n                if (matchByProbeID && n) return this._lastProbeID\r\n                else if (this._lastProjectID && n) return this._lastProjectID + `::` + n\r\n                return this._lastProbeID\r\n            }\r\n\r\n            const newProbeID = dynamicProbeID(taskOrProbeID)\r\n            if (!newProbeID) {\r\n                if (this.debug) warn(`[selectByTask] newProbeID was not found from taskOrProbeID: ${taskOrProbeID}`)\r\n            } else if (updateLastProbeID) this.lastProbeID(newProbeID)\r\n            return newProbeID\r\n        }\r\n\r\n        /**\r\n         * ### lastProjectID\r\n         * - every project is a job initiated by payload, so `payload.id === lastProjectID()`\r\n         * @param type strictly validate against scoped projecjID\r\n         */\r\n        lastProjectID(projectID = '', debug = null, type = 'strict') {\r\n            if (!projectID && this._lastProjectID) projectID = this._lastProjectID\r\n            if (projectID) projectID = this.validProjectID(projectID, debug)\r\n            if (projectID && this.payloadData[projectID]) this._lastProjectID = projectID\r\n            if (!this.payloadData[projectID] && type === 'strict') return null\r\n            if (!projectID) return null\r\n            if (projectID && !this._lastProjectID) this._lastProjectID = projectID\r\n            return projectID\r\n        }\r\n\r\n        /**\r\n         * ### lastProbeID\r\n         * - return last reference to probeID\r\n         * - cache with `_lastProbeID`\r\n         * @param {*} probeID \r\n         */\r\n        lastProbeID(probeID = '', debug = null) {\r\n            if (!probeID && this._lastProbeID) probeID = this._lastProbeID\r\n            if (probeID) probeID = this.validProbe(probeID, debug)\r\n            if (probeID && this.pocket[probeID]) this._lastProbeID = probeID\r\n            if (!probeID) return null\r\n            if (!this.pocket[probeID]) return null\r\n            return probeID\r\n        }\r\n\r\n        /**\r\n         * ### validProjectID\r\n         * - `test if projectID is valid`\r\n         * - return valid id\r\n         * @param {*} id required\r\n         */\r\n        validProjectID(id, debug = null) {\r\n            id = validID(id)\r\n            if (!id) return null\r\n            if ((id || '').split(' ').length > 1) return null\r\n            if (!this.idRegexValid(id)) return null\r\n            return id\r\n        }\r\n\r\n        /**\r\n         * ### validProbe\r\n         * - returns a valid probe\r\n         * @param {*} probeID required\r\n         */\r\n        validProbe(probeID, debug = null) {\r\n            probeID = validID(probeID)\r\n            if (!probeID) return null\r\n            if (!this.idRegexValid(probeID)) return\r\n            if (probeID.indexOf(`::`) === -1) return null\r\n            // if (!this.pocket[probeID]) {\r\n            //     if (this.debug && debug === null) warn(`[validProbe] did not find probe with probeID ${probeID}`)\r\n            //     return null\r\n            // }\r\n            return probeID\r\n        }\r\n\r\n        /**\r\n         * ### dataPropSelector\r\n         * - works with `$data()` and `$cached()` user selectors \r\n         * - refer to `PocketSelectors` module\r\n         * @param {*} probeID required\r\n         * @param {*} dataProp optional\r\n         * @param {*} self optional\r\n         * @param {*} probeData{} required our referencing probeData{}\r\n         */\r\n        dataPropSelector(type = 'data()', probeID = '', dataProp = {}, self = false, probeData = {}) {\r\n            let selectedData\r\n            /**\r\n             * NOTE if calling via `$cached()`,  `probeData` already comes as `this._$cached_data` so dont need to cache  it again!\r\n             */\r\n            try {\r\n                /**\r\n                  * NOTE IMPORTANT\r\n                  * assembly order: `dataProp < probeData > selectedData`\r\n                  * if are asking for multiple, example `selectedData:{a,b,value:1111}`, will return those available \r\n                  * as an Object{}. But if asking for only 1 `selectedData:{value:1111}`, will return the value `11111`, only because we know what we asked for initially\r\n                  */\r\n                selectedData = Object.entries(dataProp).reduce((n, [k, val], i) => {\r\n                    if (probeData[k] !== undefined) n[k] = probeData[k]\r\n                    return n\r\n                }, {})\r\n\r\n                if (!objectSize(selectedData)) selectedData = undefined\r\n\r\n                // selct only value if `dataProp` === `selectedData` is size ( 1 + 1 === 2 )\r\n                if (objectSize(selectedData) + objectSize(dataProp) === 2) selectedData = Object.values(selectedData).shift()\r\n\r\n                // if coming from `$data()` we cache our data \r\n                if (type === 'data()') this._$cached_data[probeID] = selectedData\r\n                return self ? this : selectedData\r\n            } catch (err) {\r\n                if (this.debug) warn(`[$data] no dataProp found on probeID: ${probeID}`)\r\n                if (type === 'data()') this._$cached_data[probeID] = selectedData\r\n                return self ? this : selectedData\r\n            }\r\n        }\r\n\r\n        idRegexValid(str) {\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(str)) {\r\n                // NOT ALWAYS NEEDED TO DISPLAY THE ERROR\r\n                // if (this.debug) onerror(`your id is invalid, allowed chars: ${pat}`)\r\n                return null\r\n            }\r\n            return true\r\n        }\r\n\r\n        /**\r\n         * ### probeProps\r\n         * - `each probe props that can be available and send on ready`\r\n         * - `order is important, keep 'status' last`\r\n         * - only updatable props are: `'campaign', 'data', 'error', 'ref', 'status'(limited)`\r\n         */\r\n        get probeProps() {\r\n            return ['campaign', 'data', 'task', 'ref', 'error', 'id', 'status']\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Set new probe model\r\n * - every new task has a set of requirements controlled by `statusStackOrder` in status setter. Once status is `complete` and data available, information is send and probe is blocked.\r\n * methods:`{get,all}` props: `{id,data,tasks,status}`\r\n */\r\nexports.Probe = () => {\r\n    // const messageCODE = require('./errors') // DISPLAY MESSAGES WITH CODE\r\n    const { isString, isArray, warn, log, isNumber, onerror, last, copy, isObject, isFunction } = require('./utils')\r\n    const sq = require('simple-q') // nice and simple promise/defer by `eaglex.net`\r\n    return class Probe {\r\n        /**\r\n         * @param {*} props.id required, case sensitive, all will be toLowerCase() \r\n         * @param {*} props.task once set cannot be changed\r\n         * @param {*} props.campaign optional, once set cannot be changed\r\n         * @param {*} props.data optional any value except undefind, cannot be change once status set to `complete` or send\r\n         * @param {*} props.status required to control Probe actions\r\n         * @param {*} opts.emitter optional, dispatcher/emmiter available if not null\r\n         * @param {*} opts.completeOnNull override complete setting even if data was never set\r\n         * @param {*} debug \r\n         */\r\n        constructor(props = {}, opts = {}, debug) {\r\n            this.debug = debug || false\r\n            if (isNumber(props.id) || props.id) props.id = props.id.toString()\r\n            if (!props.task || !isString(props.task)) throw ('task as string is required')\r\n            this._id = null\r\n            this._error = []\r\n            this._ref = null\r\n            this._task = null\r\n            this._status = null\r\n            this._data = null\r\n            this._campaign = null\r\n            this._dataIndex = 0\r\n            this._statusIndex = 0\r\n            this._statusAsync = [/** {timestamp:promise} */] // dynamic promise changer\r\n            this.task = props.task\r\n            this.id = props.id\r\n            this.status = 'open'\r\n            this._onChange = opts.onChange || null\r\n            this._onchangeDispatch = null // loads dispatcher when `opts.onChange=true` is set\r\n            this.emitter = opts.emitter || null\r\n            this.completeOnNull = opts.completeOnNull || null // when true allows completion on data still at initial null state\r\n            this.disableWarnings = (opts || {}).disableWarnings // disable some less relevant warning messages\r\n\r\n            // assign initial data if differs from default\r\n            if (props.ref !== this._ref) this.ref = props.ref\r\n            if (props.data !== this._data) this.data = props.data\r\n            if (props.campaign) this.campaign = props.campaign\r\n\r\n            this._completeAsync = sq()\r\n        }\r\n\r\n        /**\r\n         * nice and easy, save some coding, and added security\r\n         */\r\n        get sq() {\r\n            if (this[`_sq`]) return this[`_sq`]\r\n            this[`_sq`] = sq()\r\n            return this[`_sq`]\r\n        }\r\n\r\n        set id(v) {\r\n            if (this._id) {\r\n                if (this.debug) warn(`cannot update already set id: ${this._id}`)\r\n                return\r\n            }\r\n            if (!v) throw ('id is required')\r\n            if (v.split(' ').length > 1) throw ('each id cannot have spaces')\r\n            if (v.indexOf(`::`) === -1) throw ('each id must be of format id::taskName')\r\n            if (v.indexOf(`:::`) !== -1) throw ('each id must be of format id::taskName')\r\n\r\n            // validate chars\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(v)) throw (`your id is invalid, allowed chars: ${pat}`)\r\n\r\n            v = v.replace(/ /gi, '_').toLowerCase()\r\n\r\n            if (v.indexOf(this._task) === -1) {\r\n                throw (`wrong id setup, your id should make up the taks name, example: id='cocacola::drink'`)\r\n            }\r\n\r\n            this._id = v\r\n        }\r\n\r\n        get id() {\r\n            return this._id\r\n        }\r\n\r\n        /**\r\n         * - collect all errors in to an array\r\n         * - no empty error values will be set\r\n         */\r\n        set error(v) {\r\n            if (!v) return\r\n            if (!(v || []).length && isArray(v)) return\r\n\r\n            // in case data is in its initial status state = 'open' we need to update it to change `_dataIndex`\r\n            //  if (this.data === null) this.data = false\r\n            // NOTE  we now use `this.completeOnNull` so can ignore above logic\r\n            this._error.push(v)\r\n            this._error = this._error.filter(z => !!z)\r\n            this.dispatchChange('error')\r\n        }\r\n\r\n        /**\r\n         * @returns an arrays of errors or null\r\n         */\r\n        get error() {\r\n            if (!this._error.length) return null\r\n            return this._error\r\n        }\r\n\r\n        get ref() {\r\n            return this._ref\r\n        }\r\n\r\n        /**\r\n         * - acceps string, can only be set when status isnt complete\r\n         * - can be used to find your Pocket by particular `ref`\r\n         */\r\n        set ref(v) {\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                warn(`[ref] must be a string`)\r\n                return\r\n            }\r\n            if (this.status === 'complete' || this._campaign.status === 'send') return\r\n            this._ref = v\r\n            this.dispatchChange('ref')\r\n        }\r\n\r\n        get campaign() {\r\n            return this._campaign\r\n        }\r\n\r\n        set campaign(v) {\r\n            if (v === undefined) return\r\n            if (this._campaign) {\r\n                if (this.debug && !this.disableWarnings) warn(`cannot update already set campaign ${this._campaign}`)\r\n                return\r\n            }\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                if (this.debug) warn(`campaign must be a string`, v)\r\n                return\r\n            }\r\n\r\n            this._campaign = v\r\n            this.dispatchChange('campaign')\r\n        }\r\n\r\n        set task(v) {\r\n            if (v === undefined) return\r\n            if (this._task) {\r\n                if (this.debug && !this.disableWarnings) warn(`cannot update already set task`)\r\n                return\r\n            }\r\n\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                if (this.debug) warn(`task must be a string`)\r\n                return\r\n            }\r\n            if (v.indexOf(\"::\") !== -1) throw ('task seperator :: is restricted')\r\n            if (v.split(' ').length > 1) throw ('task cannot have spaces, use seperators: _+')\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(v)) throw (`your task is invalid, allowed chars: ${pat}`)\r\n\r\n            this._task = v.replace(/ /gi, '_').toLowerCase()// every task must be valid with required \r\n           \r\n        }\r\n\r\n        get task() {\r\n            return this._task\r\n        }\r\n\r\n        set data(v) {\r\n            if (v === undefined) return\r\n            /**\r\n            * cannot be updated uppon status is send || complete\r\n            */\r\n            const complete = this.status === 'complete' || this.status === 'send'\r\n            if (complete) {\r\n                // NOTE this can also happen if you are using $transfer().$to from `PocketModule` that is a delayed\r\n                if (this.debug && !this.disableWarnings) warn(`you cannot update data once the status is complete or send`)\r\n                return null\r\n            }\r\n\r\n            this._dataIndex++\r\n            if (this.status === 'open' && this._data !== null && this._dataIndex > 1) this.status = 'updated'\r\n            this._data = v\r\n            this.dispatchChange('data')\r\n        }\r\n\r\n        get data() {\r\n            return this._data\r\n        }\r\n\r\n        /**\r\n         * ### update\r\n         * - update data of current Probe{}.data\r\n         * @param {*} data:any, required\r\n         * @param {*} merge:Boolean, optional for merging object to this.data\r\n         */\r\n        update(data, merge = null) {\r\n            if (this.status === 'complete' || this.status === 'send') {\r\n                if (this.debug && !this.disableWarnings) warn(`[Probe][update] cannot update data on complete status`)\r\n                return this\r\n            }\r\n            if (!isObject(data) && merge) {\r\n                if (this.debug) warn(`[Probe][update] cannot update none object 'data' with option 'merge=true' set`)\r\n                return this\r\n            }\r\n            if (isObject(data) && merge) this.data = Object.assign({}, this.data, data)\r\n            else if (data !== undefined) this.data = data\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * forward motion `status` update is allowed\r\n         * `value`: importance que\r\n         * `set`: if status already set\r\n         */\r\n        get statusStackOrder() {\r\n            return {\r\n                open: { value: 1, set: false },\r\n                updated: { value: 2, set: false },\r\n                complete: { value: 3, set: false },\r\n                send: { value: 4, set: false },\r\n                error: { value: 5, set: false }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * allow status: open | updated | complete | send | error\r\n         * `open`: status is set when pocked is initialized\r\n         * `updated`: status is set when data is updated\r\n         * `complete`: status is set when you want to complete and discard probe\r\n         * `send`: once the status was set `complete` data is resolved first then status is set as `send`.\r\n         * and Probe is locked, cannot be interacted with. Follow the strategic order set by `statusStackOrder`\r\n         * `error` acts like complete, it will resolve() last available data and block the Probe\r\n         */\r\n        get status() {\r\n            return this._status\r\n        }\r\n\r\n        set status(v) {\r\n            // order of status and allowed values\r\n            ((stat) => {\r\n                try {\r\n                    // meaning do not allow any status changes beond `updated`\r\n                    if (this.statusStackOrder[stat].value > 2 && this.statusStackOrder[stat].set === true) return false\r\n                } catch (err) {\r\n                    onerror('statusStackOrder invalid status')\r\n                }\r\n\r\n                // if (this._status === 'send' && (stat === 'complete' || stat ==='send')) {\r\n                //     if (this.debug) warn(`cannot update status if already complete, id:${this.id}`)\r\n                //     return false\r\n                // }\r\n\r\n                switch (stat) {\r\n                    case 'open':\r\n                        if (this._status === 'updated') {\r\n                            if (this.debug) warn(`cannot set status back to open once set to updated`)\r\n                            break\r\n                        }\r\n                        this._status = stat\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.onOpenStatus(v) // emit probe when status opens\r\n                        this.setStatusAsync = stat\r\n                        this.dispatchChange('status')\r\n                        break\r\n\r\n                    case 'updated':\r\n                        if (this._status === 'complete') {\r\n                            if (this.debug) warn(`cannot update status to 'updated' then previously set to 'complete'`)\r\n                            break\r\n                        }\r\n\r\n                        if (this._dataIndex > 0) {\r\n                            this._status = stat\r\n                            this.statusStackOrder[stat].set = true\r\n                            this.setStatusAsync = stat\r\n                            this.dispatchChange('status')\r\n                            if (this.debug) log(`id:${this.id}, data updated`)\r\n                        }\r\n\r\n                        break\r\n\r\n                    case 'complete':\r\n                        if (this.data === null && this.completeOnNull !== true) {\r\n                            if (this.debug) warn(`[status] cannot complete status because data is null, to complete you set data prop to false`)\r\n                            break\r\n                        }\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        // setTimeout(()=>{\r\n                        this._status = stat\r\n                        this.dispatchChange('status')\r\n                        this.onComplete(v) // resolve probe when status complete\r\n                        //  })\r\n                       \r\n                        break\r\n\r\n                    case 'send':\r\n                        if (this._status !== 'complete') {\r\n                            if (this.debug) warn(`cannot update status to 'send' then previously not set to 'complete'`)\r\n                            break\r\n                        }\r\n                        this._status = stat\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        this._completeAsync.resolve({ status: this._status, id: this.id })\r\n                        this.dispatchChange('status')\r\n                        break\r\n\r\n                    case 'error':\r\n                        if (this._status === 'complete') return\r\n                        // when we have error we need to inform what happen, and close the Probe\r\n\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        this.dispatchChange('status')\r\n                        this.onComplete(v) // resolve probe when status complete                     \r\n                        break\r\n\r\n                    default:\r\n                        if (this.debug) warn(`id:${this.id},  you set invalid status: ${stat}, nothing changed`)\r\n                }\r\n            })(v)\r\n        }\r\n\r\n        /**\r\n         * - works with `statusAsync`\r\n         * - (1.) setter creates our new sq() promise every time, and allows use or resolve \r\n         * - to use example: setStatusAsync.resolve()\r\n         */\r\n        set setStatusAsync(v) {\r\n            // 'v'  set to anything to initiate setter\r\n            const timestamp = new Date().getTime()\r\n            const p = { timestamp, p: sq() }\r\n            this._statusAsync.push(p)\r\n        }\r\n\r\n        get setStatusAsync() {\r\n            const lastPromise = last(this._statusAsync.sort((a, b) => a.timestamp - b.timestamp).map(z => z['p']))\r\n            lastPromise.resolve(copy(this.status)) // << we are unly returning\r\n            return lastPromise\r\n        }\r\n\r\n        /**\r\n         * ### statusAsync\r\n         * - dynamic promise resolver with `Simple Q` from `eaglex.net`\r\n         * - works with `setStatusAsync` setter/getter\r\n         * - return last 'resolve' status from last `timestamp` setting\r\n         */\r\n        get getStatusAsync() {\r\n            return this.setStatusAsync.promise()\r\n        }\r\n\r\n        /**\r\n         * - when status is set to complete or send, the promise will then be resolved\r\n         * @returns {status, id}\r\n         */\r\n        get completeAsync() {\r\n            return this._completeAsync.promise()\r\n        }\r\n\r\n        /**\r\n         * - alias of `getStatusAsync`\r\n         * @readonly\r\n         */\r\n        get statusAsync() {\r\n            return this.getStatusAsync\r\n        }\r\n\r\n        all() {\r\n            return { error: this.error, ref: this.ref, campaign: this.campaign, data: this.data, id: this.id, task: this.task, status: this.status }\r\n        }\r\n\r\n        /**\r\n         * - can be used when `opts.onChange=true` is set\r\n         * - changes are observed for `[ data,status,ref,error,campaign]`\r\n         * @param {*} cb(data,id) callback returns updated value in real time\r\n         * @returns self\r\n         */\r\n        onChange(cb, watch = 'all') {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn(`[onChange] to use need to set opts.onChange=true`)\r\n                return this\r\n            }\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) warn(`[onChange] cb must be a function`)\r\n                return this\r\n            }\r\n            const availableWatch = ['all', 'data', 'status', 'ref', 'error', 'campaign']\r\n            if (!availableWatch.includes(watch)) {\r\n                if (this.debug) warn(`[onChange] no watch available for ${watch}`)\r\n                return this\r\n            }\r\n\r\n            const self = this\r\n\r\n            if (!this.onchangeDispatch) {\r\n                if (this.debug) warn(`[onChange] onchangeDispatch no longer active`)\r\n                return this\r\n            }\r\n\r\n            this.onchangeDispatch.initListener().subscribe(function (data, id) {\r\n                // NOTE data['changed'] // returned in dispatch only provided name of asset changed\r\n                // no point to carry data if we can access it direct\r\n                if (data['changed'] && watch === 'all') {\r\n                    cb.bind(self)(copy(self.all()), id)\r\n                    return\r\n                }\r\n\r\n                if (data['changed'] === watch && self[watch] !== undefined) {\r\n                    cb.bind(self)(copy(self[watch]), id)\r\n                    \r\n                }          \r\n            })\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - works with onchangeDispatch, onChange \r\n         * - emmits next value to `onchangeDispatch` listener\r\n         * @param {*} changedName required, provide name of Probe prop to alert dispatcher what has changed\r\n         * @returns self\r\n         */\r\n        dispatchChange(changedName) {\r\n            if (!this._onChange) {\r\n                return null\r\n            }\r\n            if (!this.onchangeDispatch) {\r\n                return null\r\n            }\r\n            this.onchangeDispatch.initListener().next({ changed: changedName })\r\n            return true\r\n        }\r\n\r\n        /**\r\n         * initiates dispatcher to handle on change value of [data,status,ref,error,campaign]\r\n         * @returns dispatcher instance\r\n         */\r\n        get onchangeDispatch() {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn(`[onchangeDispatch] to use need to set opts.onChange=true`)\r\n                return null\r\n            }\r\n\r\n            if (this._onchangeDispatch) {\r\n                return this._onchangeDispatch\r\n            }\r\n\r\n            this._onchangeDispatch = require('../libs/dispatcher')(this.id)\r\n            return this._onchangeDispatch\r\n        }\r\n\r\n        /**\r\n         * status watch, when current status changes execute send\r\n         * @param {*} status\r\n         */\r\n        onComplete(status) {\r\n            if ((status === 'complete' || status === 'error') && this._status !== 'send' && (this._dataIndex > 0 || this.completeOnNull === true)) {\r\n\r\n                if (this.emitter) {\r\n                    setTimeout(() => {\r\n                        this.emitter({ probe: this, status })\r\n                    })\r\n                }\r\n                this._status = 'send'\r\n                this.sq.resolve({ probe: this.all() })  \r\n\r\n                setTimeout(() => {\r\n                // in case delete listener when data complete     \r\n                    if (this.onchangeDispatch) this.onchangeDispatch.del()\r\n                })\r\n            }\r\n        }\r\n\r\n        /**\r\n         * do something on open task, this means we start request for data\r\n         * @param {*} status\r\n         */\r\n        onOpenStatus(status) {\r\n            if (status === 'open') {\r\n                // return this probe and update it when its complete\r\n                if (this.emitter) {\r\n                    setTimeout(() => {\r\n                        this.emitter({ probe: this, status: 'open' })\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","\r\n/** \r\n    * ### Architect\r\n    * a more in depth project architecture setup, allowing more robust configuration, munipulation and data flows\r\n*/\r\nmodule.exports = (Pocket) => {\r\n    const { objectSize, isFunction, onerror, warn, log, isString } = require('./utils')\r\n\r\n    // work with \r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\r\n\r\n    /**\r\n     * protected prototype exluded from `Architect`\r\n     */\r\n    function ArchitectModel() {\r\n        this._architectVal = null\r\n        this.architect = Object.create(ArchitectModel.prototype, {\r\n            value: {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => {\r\n                    return this._architectVal\r\n                },\r\n                set: (v) => {\r\n                    if (!objectSize(v)) return\r\n                    this._architectVal = v\r\n                    log(`[architect] updated`)\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return class Architect extends Pocket {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n\r\n            this.architectConfig = {}\r\n            const archModel = new ArchitectModel()\r\n            this.architectMod = archModel.architect\r\n        }\r\n\r\n        setArchitect(projectID, val) {\r\n            if (this.architectConfig[projectID] === undefined) this.architectConfig[projectID] = this.architectMod\r\n            this.architectConfig[projectID]['value'] = Object.assign({}, this.architectConfig[projectID]['value'], val)\r\n            return this\r\n        }\r\n\r\n        getArchitect(projectID) {\r\n            return (this.architectConfig[projectID] || {})['value']\r\n        }\r\n\r\n        /** \r\n       * @param assetName string, specify the name you chose in your `$architect(...)` declaration,\r\n       * @param asCallback when exists, return asset as callback\r\n       * @param projectID optional, update selector and return desired asset\r\n       * @returns if callback is returned the same value is returned\r\n      */\r\n        asset(assetName, asCallback, projectID) {\r\n            if (!isFunction(asCallback)) {\r\n                if (this.debug) warn(`[$asset] asCallback must be a function`)\r\n                return null\r\n            }\r\n            // reserved names\r\n            if (assetName === 'project' || assetName === 'cache') {\r\n                if (this.debug) warn(`[$asset] 'project, cache' are  restricted`)\r\n                return undefined\r\n            }\r\n            const lastProject = this.lastProjectID(projectID) // in case we are calling `$architect` on existing project\r\n            projectID = this.validProjectID(lastProject || projectID)\r\n\r\n            if (this.getArchitect(projectID)) {\r\n                if (this.getArchitect(projectID)[assetName] !== undefined) {\r\n                    return asCallback.call(this, this.getArchitect(projectID)[assetName])\r\n                } else {\r\n                    if (this.debug) warn(`[$asset] assetName for architect doesnt exist`)\r\n                    return null\r\n                }\r\n            } else {\r\n                if (this.debug) warn(`[$asset] architectConfig for assetName doesnt exist`)\r\n                return null\r\n            }\r\n        }\r\n\r\n        /** \r\n          * - can be used as a project setter same as `$payload` or `$project`, but with additional configuration\r\n          * \r\n          * @param cb required, must return project settings: `{project:{payloadData}, asset:{value, name}, cache:{project, asset}}\r\n          * @param projectID optional\r\n          * @returns self\r\n         */\r\n        architect(cb, projectID) {\r\n\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) onerror(`[$architect] callback must be set`)\r\n                return this\r\n            }\r\n\r\n            const config = cb.call(this/** ,?? */)\r\n\r\n            if (!objectSize(config)) {\r\n                if (this.debug) onerror(`[architect] must return a valid object settings {project, asset}, at least 1 is required`)\r\n                return this\r\n            }\r\n\r\n            const configProjectID = (config['project'] || {}).id\r\n            const lastProject = this.lastProjectID(projectID) // in case we are calling `$architect` on existing project\r\n            projectID = this.validProjectID(lastProject || projectID || configProjectID)\r\n\r\n            if (!projectID) {\r\n                if (this.debug) onerror(`[$architect] if this is a new project, you must specify projectID`)\r\n                return this\r\n            }\r\n            const validConfig = Object.entries(config).reduce((n, [k, value]) => {\r\n                if (['project', 'asset', 'cache'].indexOf(k) !== -1) n[k] = value\r\n                return n\r\n            }, {})\r\n\r\n            // default setting for `architect.cache` if getArchitect not stored\r\n            if (!(this.getArchitect(projectID) || {})['cache']) {\r\n                const defaults = { project: false, asset: false }\r\n                if (!validConfig['cache']) validConfig['cache'] = defaults\r\n\r\n                this.setArchitect(projectID, {\r\n                    'cache': validConfig['cache']\r\n                })\r\n\r\n            } else validConfig['cache'] = this.getArchitect(projectID)['cache']\r\n\r\n            for (let k in validConfig) {\r\n                const item = validConfig[k]\r\n                // get last cache overide\r\n                const cached = validConfig['cache'][k] === true && (k === 'project' || k === 'asset')\r\n\r\n                if (k === 'project') {\r\n                    // item['async'] item['type'] .. can include `async` and `type` \r\n                    try {\r\n                        if (cached && this.getArchitect(projectID)[k]) continue\r\n                    } catch (err) {\r\n                        // \r\n                    }\r\n\r\n                    this.setArchitect(projectID,\r\n                        { project: this.$payload(item, item['async'], item['type']).d }\r\n                    )\r\n                }\r\n\r\n                if (k === 'asset') {\r\n                    if (!isString(item['name']) || item['value'] === undefined) {\r\n                        if (this.debug) warn(`[$architect] asset must include {value, name}`)\r\n                        return this\r\n                    }\r\n                    if (item['name'] === 'project' || item['name'] === 'cache') {\r\n                        if (this.debug) warn(`[$architect] asset props, \"project, cache\" are reserved`)\r\n                        return this\r\n                    }\r\n                    try {\r\n                        if (cached && this.getArchitect(projectID)[item['name']]) continue\r\n                    } catch (err) {\r\n                        // \r\n                    }\r\n\r\n                    // if already exists, same assets will be overriten and new will be created\r\n                    this.setArchitect(projectID, {\r\n                        [item['name']]: item['value']\r\n                    })\r\n                }\r\n            }\r\n            return this\r\n        }\r\n\r\n    }\r\n}\r\n","\r\n/**\r\n * ### PocketSelectors\r\n * - Extends PocketModule using selectors for better access to Probes\r\n * - allow selecttion to refference by, example:  `taskName`, `::taskName` and `${projectID}::taskName`, thanks to `selectByTask()` method\r\n */\r\nmodule.exports = (PocketModule) => {\r\n    const { copy, warn, isArray, onerror, objectSize, isString, uniq, isFunction } = require('./utils')\r\n\r\n    return class PocketSelectors extends PocketModule {\r\n\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n        }\r\n\r\n        /** \r\n         * - can be used as a project setter same as `$payload` or `$project`, but with additional configuration\r\n         * @extends Architect\r\n         * @param cb required, must return project settings: `{project:{payloadData}, asset:{value, name}}\r\n         * @param projectID optional\r\n         * @returns self\r\n        */\r\n        $architect(...args) {     \r\n            return this.architect(...args)\r\n        }\r\n\r\n        /** \r\n         * @param assetName string, specify the name you chose in your `$architect(...)` declaration\r\n         * @param projectID optional, update selector and return desired asset\r\n         * @returns asset by name or null\r\n         * @extends Architect\r\n        */\r\n        $asset(...args) {\r\n            return this.asset(...args)\r\n        }\r\n\r\n        /**\r\n         * - check is probe exists on PocketModule\r\n         * @param {*} probeID required, can specify `::taskName` or full id `{projectID}::{probeID}`\r\n         * @returns boolean\r\n         */\r\n        $exists(probeID) {\r\n            return !!this.selectByTask(probeID)\r\n        }\r\n\r\n        /**\r\n         * @param projectID required\r\n         * @returns boolean `true/false/null`, determined by project completion\r\n         */\r\n        $projectComplete(projectID) {\r\n            if (!this.projectsCache[projectID]) return null\r\n            return this.projectsCache[projectID] === 'complete'\r\n        }\r\n\r\n        /**\r\n         * ### $projectSet\r\n         * - use it to check if project already available, it is similar to `$projectSetAsync` but not a promise, returns current status, not in future\r\n         * @param {*} projectID required\r\n         */\r\n        $projectSet(projectID = '') {\r\n            projectID = this.validProjectID(projectID)\r\n            if (this.payloadData[projectID]) return true\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * - run conditional statement within callback, so we can keep chaining in the same block\r\n         * @param cb required, inside callback access to self for PocketModule, or for Probe{}, depending on `projectID/probeID` id specified\r\n         * @param `projectID/probeID` optional, specify either `projectID` or `probeID`, defaults to last `projectID`\r\n         * @returns by default eturns Pocket/self, or any true value passed inside callback\r\n         */\r\n        $condition(cb, id) {\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) warn(`[$condition] must provide callback`)\r\n                return this\r\n            }\r\n            id = !isString(id) ? '' : id\r\n            let selfType = 'PocketSelf'// `ProbeSelf`\r\n            let self = null\r\n            if (id.indexOf(`::`) === 0) { // if specified id is `probeID`\r\n                id = this.selectByTask(id, true)\r\n                id = this.lastProbeID(id)\r\n                selfType = `ProbeSelf`\r\n                if (!id) {\r\n                    if (this.debug) warn(`[$condition] probeID not found`)\r\n                    return this\r\n                }\r\n                // also updates last selector reference\r\n            } else if (this.lastProjectID(id)) selfType = 'PocketSelf' // if specified id is `projectID`\r\n            else {\r\n                if (this.debug) warn(`[$condition] projectID not found`)\r\n                return this \r\n            }\r\n\r\n            if (selfType === 'PocketSelf') self = this\r\n            if (selfType === 'ProbeSelf') self = this.$get(id)\r\n\r\n            if (!self) {\r\n                if (this.debug) warn(`[$condition] no valid self value`)\r\n                return this\r\n            }\r\n            \r\n            const cbDATA = cb.call(self, self) // when using arrow function pass `(self)=>` in callback as well\r\n            if (cbDATA) return cbDATA // if callback has any true data return it, \r\n            else return this // else return self\r\n        }\r\n\r\n        /**\r\n         * @returns last selected projectID\r\n         */\r\n        get $projectID() {\r\n            return this._lastProjectID\r\n        }\r\n\r\n        /**\r\n         * - return last probe status, this is a dynamic Promise, creates new promise every time status is changed, so then it needs to bu called again to get latest update\r\n         * @param {*} probeID \r\n         * @extends probeStatusAsync\r\n         */\r\n        $probeStatusAsync(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this.probeStatusAsync(lastProbeID)\r\n        }\r\n        \r\n        /**\r\n         * ### $get\r\n          * - `get probe by 'id::taskName'`\r\n          * - `returns instance`\r\n          *  methods:`{get,all}` props: `{id,data,tasks,status}`\r\n          * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n          * @param {*} self = false optional, in case you want to chain, and access `Probe{}` through `...).d`\r\n          * @extends _get\r\n         */\r\n        $get(probeID, self) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this._get(lastProbeID, self)\r\n        }\r\n\r\n        /**\r\n         * - return array of Probes matched by ref\r\n         * @param {*} probeRef, required\r\n         * @returns [Probe{},...] array\r\n         */\r\n        $getByRef(probeRef = '') {\r\n            return Object.assign(this.pocket).filter(([id, probe], inx) => probe.ref === probeRef)\r\n        }\r\n       \r\n        /**\r\n         * - as name suggest sets up new new data for Probe/task, it derives from `$update` \r\n         * @param {*} dataFrom required, must specify what to set on Probe{}, example: `dataFrom:{data:'coke',status:'complete',campaign:'cocacola'}`\r\n         * - we should only use `$set` for initialization, this action also calls `clearStoreTransfers`\r\n         * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n         * @extends _set\r\n         */\r\n        $set(dataFrom, probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this._set(dataFrom, lastProbeID)\r\n        }\r\n\r\n        /**\r\n         * ### $probe\r\n         * - return me as Probe{}, similar as $get(...), although does additional check for instanceOf Probe{}\r\n         * @param {*} probeID \r\n         */\r\n        $probe(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            if (!this.pocket[lastProbeID]) {\r\n                if (this.debug) warn(`[$probe] not found for probeID: ${probeID}`)\r\n                return undefined\r\n            }\r\n\r\n            if (this.pocket[lastProbeID].constructor.name !== 'Probe') {\r\n                if (this.debug) onerror(`[$probe] probeID: ${probeID} is not an instance of Probe{}`)\r\n                return undefined\r\n            }\r\n\r\n            return this.pocket[lastProbeID]\r\n        } \r\n        \r\n        /**\r\n         * update Probe/task, for convenience, so we dont have do this, example: `pc.$get('abc123::grab').status='complete'`\r\n         * @param {*} dataFrom required, must specify what to update on Probe{}, example: `dataFrom:{data:'coke',status:'complete',campaign:'cocacola'}`\r\n         * @param {*} mergeData optional if `true` will merge: `Object.assing({},probe[id].data,mergeData['data'])`\r\n         * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n         * @extends update\r\n         */\r\n        $update(dataFrom, mergeData, probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return this.update(dataFrom, mergeData, lastProbeID)\r\n        }\r\n\r\n        /**\r\n         * ### $select\r\n         * - select current payloadID/project/job by id you are working on\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         */\r\n        $select(projectID = '') {\r\n            projectID = !isString(projectID) ? '' : projectID\r\n            this.lastProjectID(projectID) // also updates last selector reference\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $filter\r\n         * - filter works together with `$compute` or standalone when specified `.d` to return filtered `list`\r\n         * @param {*} cb \r\n         * @param {*} projectID \r\n         */\r\n        $filter(cb, projectID) {\r\n            projectID = this.lastProjectID(projectID) // also updates last selector reference\r\n            const returnAs = (val) => {\r\n                this.d = (val || []).filter(z => z.isNONE === undefined)\r\n                return this\r\n            }\r\n\r\n            if (!isFunction(cb)) return returnAs([])\r\n\r\n            if (!this.payloadData[projectID]) {\r\n                if (this.debug) warn(`[$filter] no projectID found`)\r\n                return returnAs(null)\r\n            }\r\n            // when narrowing down $filter.$filter process, lets remember last action\r\n            let probeList = []\r\n            if ((this._lastFilterList[projectID] || []).length) probeList = this._lastFilterList[projectID]\r\n            else {\r\n                this._lastFilterList[projectID] = []\r\n                probeList = this.projectProbeList(projectID)\r\n            }\r\n            probeList.forEach((probe, inx) => {\r\n                if (probe.isNONE) {\r\n                    return\r\n                }\r\n                const matchFound = cb.call(probe, probe)\r\n                if (!matchFound) {\r\n                    this._lastFilterList[projectID] = this._lastFilterList[projectID].filter(z => z.id !== probe.id)\r\n                    this._lastFilterList[projectID].push({ id: probe.id, isNONE: true })\r\n                    return\r\n                }\r\n\r\n                if (matchFound !== undefined && (matchFound === true || matchFound === 1)) {\r\n                    // dont re-add same probe\r\n                    const isNew = this._lastFilterList[projectID].filter((z, i) => (z || {}).id === probe.id).length\r\n\r\n                    if (!isNew) this._lastFilterList[projectID].push(probe)\r\n                    \r\n                } else this._lastFilterList[projectID].push({ id: probe.id, isNONE: true })\r\n            })\r\n            return returnAs(this._lastFilterList[projectID])\r\n        }\r\n\r\n        /**\r\n         * ### $compute\r\n         * - iterate thru each Probe{}/ instance in a callback, and make changes to it\r\n         * - note: you can only compute thru items that are not `complete`\r\n         * @param {*} cb((probe, probeID)=>this/self.data) required\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         */\r\n        $compute(cb, projectID = '') {\r\n            projectID = this.lastProjectID(projectID)\r\n            const returnAs = (val) => {\r\n                // delete last filtered list after it was consumed\r\n                if (val) delete this._lastFilterList[projectID]\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            if (!isFunction(cb)) {\r\n                if (this.debug) warn(`[$compute] cb must be a function`)\r\n                return returnAs(null)\r\n            }\r\n\r\n            if (!this.payloadData[projectID]) {\r\n                if (this.debug) warn(`[$compute] no project found fo your/last id projectID:${projectID}`)\r\n                return returnAs(null)\r\n            }\r\n\r\n            let lastFilter = (this._lastFilterList[projectID] || [])\r\n            if (lastFilter.length) {\r\n\r\n                // uniq\r\n                this._lastFilterList[projectID] = lastFilter = lastFilter.filter(z => z.isNONE === undefined)\r\n                    .filter(({ id }, i, all) => {\r\n                        return all.filter(_probe => id === _probe.id).length === 1\r\n                    })\r\n                lastFilter.forEach(probe => {\r\n                    // compute method is designed to allow access to each Probe, but we do not want to allow looping thru assets that are already complete           \r\n                    if (probe.status !== 'complete' && probe.status !== 'send') cb.call(probe, probe)\r\n                })\r\n                // finally only return not none list on probes, then clear _lastFilterList\r\n                return returnAs(this._lastFilterList[projectID])\r\n            } else {\r\n              \r\n                this.projectProbeList(projectID).forEach(probe => {\r\n                    // compute method is designed to allow access to each Probe, but we do not want to allow looping thru assets that are already complete           \r\n                    \r\n                    if (probe.status !== 'complete' && probe.status !== 'send') cb.call(probe, probe)\r\n                })\r\n                return returnAs(this.projectProbeList(projectID))\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $list\r\n         * - list active Probes{} by project id, should return all assigned probe/tasks regardless of status\r\n         * - returns array[] of active Probe{}/tasks or []\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         * @param {*} cb((probe, probeID)=>) optional, when set will loop thru each Probe{} in callback\r\n         * @param {*} type optional, set to `list`, will return latest Probes, that includes if initiated cb and made a few changes\r\n         */\r\n        $list(projectID = '', cb = null, type = 'self') {\r\n            projectID = this.lastProjectID(projectID)\r\n            if (!this.payloadData[projectID]) return []\r\n            const list = () => {\r\n                return Object.entries(this.pocket).reduce((n, [key, val], inx) => {\r\n                    if (val.id.includes(projectID)) n.push(val)\r\n                    return n\r\n                }, [])\r\n            }\r\n            if (isFunction(cb)) {\r\n                this.projectProbeList(projectID).forEach(probe => {\r\n                    cb(probe.all()) // no access to Probe/instance only copy\r\n                })\r\n                if (type === 'self' || !type) return this\r\n                if (type === 'list') return list()\r\n            } else {\r\n                return list()\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $transfer\r\n         * - select data from `fromProbeID` and hold it in `_transferCache`, until `$to(probeID)` is called\r\n         * - warning, action removes `Probe[fromProbeID].data` and overrides it on Probe[probeID].data, only when `$to(probeID)` is called, simple as that!\r\n         * @param {*} fromProbeID optional/sensitive, selects new point of reference.\r\n         */\r\n        $transfer(fromProbeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            fromProbeID = this.selectByTask(fromProbeID, true)\r\n            fromProbeID = this.lastProbeID(fromProbeID)\r\n            if (!this.pocket[fromProbeID]) {\r\n                if (this.debug) warn(`[$transfer] no Probe{} found for this id fromProbeID:${fromProbeID}`)\r\n                return this\r\n            }\r\n            this.storeTransfers(fromProbeID, copy(this.pocket[fromProbeID]['data']))\r\n            // NOTE needed for extra security to make sure it was called before we can update `$to()`\r\n            this.$transfer_lastID = fromProbeID\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $to\r\n         * - works together with `$transfer`, will transfer `data` from one Probe{} to another\r\n         * if `_transferCache` is set, the cache is cleared.\r\n         * @param {*} toProbeID optional/sensitive, points to Probe{} `data` will be packed, it is not previous reference pointer, but the next.\r\n         * - will only work if `toProbeID` is not yet complete\r\n         * @param {*} pointToThisProbe to stay on the current pointer reference\r\n         * @param {*} maxDelay, keep at minimum! Time between transaction can take place, relates to `fromAverageTimeHasPast` found in `accessLastValidTransfer()`\r\n         */\r\n        $to(toProbeID = '', pointToThisProbe = true, maxDelay = 100) {\r\n\r\n            // allow use of short ref names example: `::cocalola`\r\n            toProbeID = this.selectByTask(toProbeID, pointToThisProbe)\r\n            // if (!keepLastPointerReference) toProbeID = this.lastProbeID(toProbeID)\r\n            if (pointToThisProbe) toProbeID = this.validProbe(toProbeID)\r\n            if (!toProbeID) {\r\n                if (this.debug) warn(`[$to] toProbeID is invalid`)\r\n                return this\r\n            }\r\n            if (!this.pocket[toProbeID]) {\r\n                if (this.debug) warn(`[$to] no Probe{} found for this id toProbeID:${toProbeID}`)\r\n                return this\r\n            }\r\n            if (this.$transfer_lastID) {\r\n                // please note because this can be a delayed transaction, if you send `status=complete`\r\n                // the data will not be updated\r\n                const lastValidTransfer = this.accessLastValidTransfer(maxDelay)\r\n                if (objectSize(lastValidTransfer)) {\r\n                    const { fromProbeID, data } = lastValidTransfer\r\n                    if (this.$transfer_lastID === fromProbeID) {\r\n                        if (this.pocket[toProbeID].status === 'complete' || this.pocket[toProbeID].status === 'send') {\r\n                            if (this.debug) warn(`[$to] cannot transfer since toProbeID: ${toProbeID} is already complete`)\r\n                            this.$transfer_lastID = ''\r\n                            return this\r\n                        }\r\n                        this.pocket[fromProbeID]['data'] = null // from $transfer \r\n                        this.pocket[toProbeID]['data'] = data // $to \r\n                    }\r\n                } else {\r\n                    if (this.debug) warn(`[$to] no last valid transfer found`)\r\n                }\r\n                this.$transfer_lastID = ''\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $of\r\n         * - points to Probe{} be reference\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $of(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            this.selectByTask(probeID, true)\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $data\r\n         * - returns Object copy of `Probe['data']`\r\n         * @param {*} dataProp optional, if you know what you are asking for example: `{assets:true}`,or `array['assets]`, it has catch error exception, so you wont receive any errors just `null`\r\n         * will return all available matched within our `Probe{}['data]`. Multiples of `dataProp{}/([])/(',')` will return an object, if only one specified, only value will be retured\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         * @param {*} self optional,if you want to $cached() last data enquiry and return `self` to keep chaining, nice!\r\n         */\r\n        $data(dataProp = null/** {}||[] */, probeID = '', self = false) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return self ? this : undefined\r\n\r\n            // NOTE can provide as an array\r\n            if (isArray(dataProp) && (dataProp || []).length) {\r\n                dataProp = uniq(dataProp).reduce((n, el) => {\r\n                    if (el !== undefined) n[el.trim()] = true\r\n                    return n\r\n                }, {})\r\n            }\r\n\r\n            if (!dataProp || !objectSize(dataProp)) {\r\n                this._$cached_data[probeID] = copy(this.pocket[probeID]['data'])\r\n                return self ? this : this._$cached_data[probeID]\r\n            }\r\n            return this.dataPropSelector(\"data()\", probeID, dataProp, self, copy(this.pocket[probeID]['data']))\r\n        }\r\n\r\n        /**\r\n         * ### cached\r\n         * - grabs last cached `$data(...)` from Probe{}\r\n         * @param {*} dataProp{}/String optional, know what you are asking for example: ` {assets:true}/ or > 'assets,values,somethingElse'`, it has catch error exception, so you wont receive any errors just `null`\r\n         * will return all available matched within our `_$cached_data[probeID]`. Multiples of `dataProp{}/([])/(',')` will return an object, if only one specified, only value will be retured\r\n         * @param {*} probeID \r\n         */\r\n        $cached(dataProp = {}, probeID = '') {\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return undefined\r\n            const hasValue = this._$cached_data[probeID] !== undefined && this._$cached_data[probeID] !== null\r\n            if (!hasValue) return undefined\r\n            // if you provided a string make it an object\r\n            if (isString(dataProp) && (dataProp || '').length) {\r\n                dataProp = uniq(dataProp.trim().replace(/ /gi, '').split(',')).reduce((n, el) => {\r\n                    if (el !== undefined) n[el] = true\r\n                    return n\r\n                }, {})\r\n            }\r\n            // return cached data if its not an object, or undefined\r\n            if (!objectSize(this._$cached_data[probeID]) && hasValue) {\r\n                if (objectSize(dataProp)) return undefined // our cache not an object, but we are asking for dataProp reference, so should return undefined\r\n                else return this._$cached_data[probeID]\r\n            }\r\n            // no selection at all, so just return whats available\r\n            if (!dataProp || !objectSize(dataProp)) {\r\n                return this._$cached_data[probeID] === undefined ? undefined : this._$cached_data[probeID]\r\n            } else return this.dataPropSelector(\"cached()\", probeID, dataProp, false, this._$cached_data[probeID])\r\n        }\r\n\r\n        /**\r\n         * ### $campaign\r\n         * - returns Object copy of `Probe['campaign']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $campaign(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['campaign'])\r\n        }\r\n\r\n        /**\r\n         * ### $ref\r\n         * - returns Probe{}.ref\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $ref(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['ref'])\r\n        }\r\n\r\n        /**\r\n        * ### $status\r\n        * - returns Object copy of `Probe['status']` \r\n        * @param {*} probeID optional/sensitive, select new point of reference\r\n        */\r\n        $status(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['status'])\r\n        }\r\n\r\n        /**\r\n         * ### $task\r\n         * - returns Object copy of `Probe['task']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $task(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['task'])\r\n        }\r\n\r\n        /**\r\n         * ### $task\r\n         * - returns Object copy of `Probe['task']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $error(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['error'])\r\n        }\r\n\r\n        /**\r\n         * ### $all\r\n         * - return Object copy of all setters: `{id,status,campaign,task,data}` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $all(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID].all())\r\n        }\r\n\r\n        /**\r\n         * - changes are observed for `[data,status,ref,error,campaign]`\r\n         * @param watchProp specify what property to watch, defaults to `all`\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         * @extends Probe.onChange\r\n         */\r\n        $onChange(cb, watchProp, probeID) {\r\n            if (!this._onChange) {\r\n                if (this.debug) warn(`[$onChange] opts.onChange=true must be enabled to use this feature`)\r\n                return this\r\n            }\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            this.pocket[probeID].onChange(cb, watchProp)\r\n            return this\r\n        }\r\n\r\n    }\r\n}\r\n"],"sourceRoot":""}