{"version":3,"sources":["webpack://Pocket/webpack/bootstrap","webpack://Pocket/./Pocket/utils.js","webpack://Pocket/./Pocket/Pocket.module.js","webpack://Pocket/./Pocket/Pocket.libs.js","webpack://Pocket/./libs/dispatcher.js","webpack://Pocket/./Pocket/Probe.js","webpack://Pocket/./Pocket/Pocket.selectors.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","util","require","color","uniq","arr","filter","v","all","indexOf","objectSize","obj","__proto__","entries","last","Array","copyBy","refs","reduce","el","undefined","validID","id","toString","toLowerCase","isNumber","Number","isPromise","defer","Promise","isObject","isArray","isString","str","String","isFunction","log","args","concat","map","z","inspect","console","warn","cyan","onerror","red","error","copy","JSON","parse","stringify","err","errorMessages","messages","msgs","k","message","code","sq","PocketLibs","newProbe","PocketModuleExt","opts","debug","async","returnAs","val","asAsync","this","then","reject","$payload","payloadID","deletePocketSet","dispatcher","initListener","subscribe","probe","status","keys","every","validProjectID","payloadData","values","idRegexValid","timestamp","Date","getTime","task","lastPocketTimestamp","lastProjectID","distributor","setDefer","probeID","self","lastProbeID","pocket","getStatusAsync","dataFrom","mergeData","_setUpdate","tasks","_ready","promise","type","updated","pos","probeProps","inx","assign","clearStoreTransfers","$transfer_lastID","_$cached_data","msg","pocketSet","output","pock","prop","userOutput","resolve","pl","setProbe","uid","Probe","next","poc","includes","_lastProjectID","_lastProbeID","_transferCached","projectID","cleared","forEach","element","fromProbeID","fromAverageTimeHasPast","sort","a","b","transferCachedCopy","coundCache","currentOffset","taskOrProbeID","updateLastProbeID","split","dynamicProbeID","newProbeID","validProbe","selectedData","dataProp","probeData","RegExp","test","plugin","cbQueue","dispatchInstance","Dispatch","cb","del","_id","_task","_status","_data","_compaign","_dataIndex","_statusIndex","_statusAsync","compaign","merge","setTimeout","_emit","pat","replace","open","set","complete","send","stat","statusStackOrder","onOpenStatus","setStatusAsync","onComplete","lastPromise","PocketModule","selectByTask","constructor","storeTransfers","toProbeID","pointToThisProbe","maxDelay","lastValidTransfer","accessLastValidTransfer","trim","dataPropSelector","hasValue"],"mappings":"0BACE,SAASA,EAAqBC,GAQ7B,IAPA,IAMIC,EAAUC,EANVC,EAAWH,EAAK,GAChBI,EAAcJ,EAAK,GACnBK,EAAiBL,EAAK,GAIHM,EAAI,EAAGC,EAAW,GACpCD,EAAIH,EAASK,OAAQF,IACzBJ,EAAUC,EAASG,GAChBG,OAAOC,UAAUC,eAAeC,KAAKC,EAAiBX,IAAYW,EAAgBX,IACpFK,EAASO,KAAKD,EAAgBX,GAAS,IAExCW,EAAgBX,GAAW,EAE5B,IAAID,KAAYG,EACZK,OAAOC,UAAUC,eAAeC,KAAKR,EAAaH,KACpDc,EAAQd,GAAYG,EAAYH,IAKlC,IAFGe,GAAqBA,EAAoBhB,GAEtCO,EAASC,QACdD,EAASU,OAATV,GAOD,OAHAW,EAAgBJ,KAAKK,MAAMD,EAAiBb,GAAkB,IAGvDe,IAER,SAASA,IAER,IADA,IAAIC,EACIf,EAAI,EAAGA,EAAIY,EAAgBV,OAAQF,IAAK,CAG/C,IAFA,IAAIgB,EAAiBJ,EAAgBZ,GACjCiB,GAAY,EACRC,EAAI,EAAGA,EAAIF,EAAed,OAAQgB,IAAK,CAC9C,IAAIC,EAAQH,EAAeE,GACG,IAA3BX,EAAgBY,KAAcF,GAAY,GAE3CA,IACFL,EAAgBQ,OAAOpB,IAAK,GAC5Be,EAASM,EAAoBA,EAAoBC,EAAIN,EAAe,KAItE,OAAOD,EAIR,IAAIQ,EAAmB,GAKnBhB,EAAkB,CACrBiB,EAAG,GAGAZ,EAAkB,GAGtB,SAASS,EAAoB1B,GAG5B,GAAG4B,EAAiB5B,GACnB,OAAO4B,EAAiB5B,GAAU8B,QAGnC,IAAIC,EAASH,EAAiB5B,GAAY,CACzCK,EAAGL,EACHgC,GAAG,EACHF,QAAS,IAUV,OANAhB,EAAQd,GAAUW,KAAKoB,EAAOD,QAASC,EAAQA,EAAOD,QAASJ,GAG/DK,EAAOC,GAAI,EAGJD,EAAOD,QAKfJ,EAAoBO,EAAInB,EAGxBY,EAAoBQ,EAAIN,EAGxBF,EAAoBS,EAAI,SAASL,EAASM,EAAMC,GAC3CX,EAAoBY,EAAER,EAASM,IAClC5B,OAAO+B,eAAeT,EAASM,EAAM,CAAEI,YAAY,EAAMC,IAAKJ,KAKhEX,EAAoBgB,EAAI,SAASZ,GACX,oBAAXa,QAA0BA,OAAOC,aAC1CpC,OAAO+B,eAAeT,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DrC,OAAO+B,eAAeT,EAAS,aAAc,CAAEe,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKzC,OAAO0C,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBzC,OAAO+B,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBS,EAAEc,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAStB,GAChC,IAAIM,EAASN,GAAUA,EAAOiB,WAC7B,WAAwB,OAAOjB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAL,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASgB,EAAQC,GAAY,OAAO/C,OAAOC,UAAUC,eAAeC,KAAK2C,EAAQC,IAGzG7B,EAAoB8B,EAAI,GAExB,IAAIC,EAAaC,OAA2B,mBAAIA,OAA2B,oBAAK,GAC5EC,EAAmBF,EAAW5C,KAAKuC,KAAKK,GAC5CA,EAAW5C,KAAOf,EAClB2D,EAAaA,EAAWG,QACxB,IAAI,IAAIvD,EAAI,EAAGA,EAAIoD,EAAWlD,OAAQF,IAAKP,EAAqB2D,EAAWpD,IAC3E,IAAIU,EAAsB4C,EAM1B,OAFA1C,EAAgBJ,KAAK,CAAC,EAAE,IAEjBM,I,4HCtJT,IAAM0C,EAAOC,EAAQ,GACfC,EAAQD,EAAQ,GAMtBhC,EAAQkC,KAAO,SAACC,GAAD,OAASA,EAAIC,QAAO,SAACC,EAAG9D,EAAG+D,GAAP,OAAeA,EAAIC,QAAQF,KAAO9D,MACrEyB,EAAQwC,WAAa,SAACC,GAAD,OAAUA,GAAQ/D,OAAOC,YAAe8D,EAAKC,UAAchE,OAAOiE,QAAQF,GAAKhE,OAAS,GAC7GuB,EAAQ4C,KAAO,SAACT,GAAD,OAAUA,GAAOU,MAAMlE,YAAewD,EAAKO,UAAaP,EAAIA,EAAI1D,OAAS,GAAK,MAC7FuB,EAAQ8C,OAAS,SAACL,EAAKM,GAAN,OAAeA,EAAKC,QAAO,SAACzB,EAAG0B,EAAI1E,GAEhD,YADgB2E,IAAZT,EAAIQ,KAAmB1B,EAAE0B,GAAMR,EAAIQ,IAChC1B,IACR,KACHvB,EAAQmD,QAAU,SAACC,GAAD,OAAUA,GAAoBA,GAAM,IAAIC,WAAWC,cAA7B,MACxCtD,EAAQuD,SAAW,SAAChC,GAAD,YAAa2B,IAAN3B,GAAmBA,EAAGmB,YAAcc,OAAO7E,WACrEqB,EAAQyD,UAAY,SAACC,GAAD,OAAWC,QAAQhF,aAAe+E,GAAS,IAAIhB,WACnE1C,EAAQkC,KAAO,SAACC,GAAD,OAASA,EAAIC,QAAO,SAACa,EAAI1E,EAAG+D,GAAR,OAAgBA,EAAIC,QAAQU,KAAQ1E,MACvEyB,EAAQ4D,SAAW,SAACnB,GAAD,QAAUA,IAAe/D,OAAOC,YAAe8D,EAAKC,WAAcD,aAAgB/D,SACrGsB,EAAQ6D,QAAU,SAAC1B,GAAD,QAAUA,GAAcU,MAAMlE,YAAewD,EAAKO,WACpE1C,EAAQ8D,SAAW,SAACC,GAAD,QAAUA,GAAcC,OAAOrF,YAAeoF,EAAKrB,WACtE1C,EAAQiE,WAAa,SAAChB,GAAD,MAAsB,mBAAPA,GACpCjD,EAAQkE,IAAM,WAAmB,2BAANC,EAAM,yBAANA,EAAM,gBAE7BA,GADAA,EAAO,GAAGC,OAAO,WAAYD,IACjBE,KAAI,SAAAC,GAAC,OAAIvC,EAAKwC,QAAQD,GAAG,EAAO,GAAG,MAC/CE,QAAQN,IAAI9E,MAAM,KAAM+E,IAE5BnE,EAAQyE,KAAO,WAAmB,2BAANN,EAAM,yBAANA,EAAM,gBAE9BA,GADAA,EAAO,GAAGC,OAAO,YAAaD,IAClBE,KAAI,SAAAC,GAAC,OAAIrC,EAAMyC,KAAK3C,EAAKwC,QAAQD,GAAG,EAAO,GAAG,IAAQ,MAClEE,QAAQC,KAAKrF,MAAM,KAAM+E,IAE7BnE,EAAQ2E,QAAU,WAAmB,2BAANR,EAAM,yBAANA,EAAM,gBAEjCA,GADAA,EAAO,GAAGC,OAAO,UAAWD,IAChBE,KAAI,SAAAC,GAAC,OAAIrC,EAAM2C,IAAI7C,EAAKwC,QAAQD,GAAG,EAAO,GAAG,IAAQ,MACjEE,QAAQN,IAAI,MACZM,QAAQK,MAAMzF,MAAM,KAAM+E,GAC1BK,QAAQN,IAAI,OAEhBlE,EAAQ8E,KAAO,SAAC7G,GACZ,IAAKA,EAAM,OAAOA,EAClB,IACI,OAAO8G,KAAKC,MAAMD,KAAKE,UAAUhH,IACnC,MAAOiH,GACL,OAAOA,EAAI7B,aAQnBrD,EAAQmF,cAAgB,SAACC,GAErB,IADA,IAAMC,EAAO,GACb,MAAmB3G,OAAOiE,QAAQyC,GAAlC,eAA6C,Q,EAAA,K,EAAA,E,kzBAAnCE,EAAmC,KAAhCjD,EAAgC,KACzCgD,EAAKC,GAAK,CAAEC,QAASlD,EAAE,GAAImD,KAAMF,G,QAErC,OAAOD,I,0iIC1DXpF,EAAOD,QAAU,WAAM,MAE+DgC,EAAQ,GAAlFQ,EAFW,EAEXA,WAAY0B,EAFD,EAECA,IAAKS,EAFN,EAEMA,QAASF,EAFf,EAEeA,KAAMZ,EAFrB,EAEqBA,QAASD,EAF9B,EAE8BA,SAAUH,EAFxC,EAEwCA,UAAWN,EAFnD,EAEmDA,QAChEsC,EAAKzD,EAAQ,GACb0D,EAAa1D,EAAQ,EAARA,GACb2D,EAAW3D,EAAQ,IAkanB4D,EAvaa,8BAwaf,WAAYC,EAAMC,GAAO,6BACfD,EAAMC,GAzaD,2CA+aN7H,EAAM8H,GAAO,WAEZC,EAAW,SAACC,GAEd,OADA,EAAK5F,EAAI4F,EACF,GAELC,OAAoBhD,IAAV6C,EAAsBA,EAAQI,KAAKJ,MACnD,OAAIG,GAAWzC,EAAUxF,GAAc+H,EAAS/H,EAAKmI,MAAK,SAAA9B,GAAC,6CAAmBA,MAAI,SAAAY,GAAG,OAAIA,MACpFiB,KAAKJ,OAAUtC,EAAUxF,IAEtBkI,KAAKL,OAAOnB,EAAQ,kGACJqB,IAAhBE,GAAyBvC,QAAQ0C,WAHGL,EAAS,EAAD,0CAAgB/H,MAvbzD,iCAocG,2BAANkG,EAAM,yBAANA,EAAM,gBACd,OAAOgC,KAAKG,SAASlH,MAAM+G,KAAMhC,KArctB,6BAwcRoC,GAAW,IAEIN,EAFJ,OAYd,OAVkBA,EAKR,0CAAaM,GAAWH,MAAK,SAAA9B,GAEnC,OADA,EAAKkC,gBAAgBD,GACdjC,KACR,SAAAY,GAAG,OAAIvB,QAAQ0C,OAAOnB,MAPrB,EAAK7E,EAAI4F,EACF,MA5cA,iCAYf,WAAYJ,EAAMC,GAAO,wBACrB,cAAMD,EAAMC,IACHW,YACL,EAAKA,WAAWC,eAAeC,WAAU,SAAArC,GAAK,MAChBA,GAAK,GAAvBsC,EADkC,EAClCA,MAAOC,EAD2B,EAC3BA,OAEA,UAAXA,GAEI,EAAKf,OAAO5B,EAAI,yBAAD,OAA0B0C,EAAMxD,GAAhC,WAGR,SAAXyD,GACI,EAAKf,OAAO5B,EAAI,yBAAD,OAA0B0C,EAAMxD,GAAhC,aAGR,aAAXyD,GAEI,EAAKf,OAAO5B,EAAI,yBAAD,OAA0B0C,EAAMxD,GAAhC,kBAjBV,EAZV,6CAsDY,WAAlBnF,EAAkB,uDAAX,GAIZ,GAHAkI,KAAK9F,EAAI,MAGJuD,EAAS3F,GAAO,OAAO,EAE5B,IAAM6I,EAAOpI,OAAOoI,KAAK7I,GAEzB,GAAI6I,EAAKC,OAAM,SAAA9D,GAAE,OAAqC,IAAjC,CAAC,KAAM,SAASV,QAAQU,MAEzC,OADIkD,KAAKL,OAAOnB,EAAQ,yCACjB,EAEX,IAAKd,EAAQ5F,EAAI,OAEb,OADIkI,KAAKL,OAAOnB,EAAQ,2CACjB,EAKX,GAFA1G,EAAKmF,GAAK+C,KAAKa,eAAe/I,EAAKmF,KAE9BnF,EAAKmF,GAEN,OADI+C,KAAKL,OAAOnB,EAAQ,+BACjB,EAGX,GAAIwB,KAAKc,YAAYhJ,EAAKmF,IAEtB,OADI+C,KAAKL,OAAOrB,EAAK,8CACd,EA1BY,UA8BPxG,EAAI,MAAUiJ,UA9BP,yBA8BdjB,EA9Bc,QA+BnB,OAAKA,EAAG,KAKH,EAAKkB,aAAalB,EAAG,QAA4C,IAA/BA,EAAG,KAAS1D,QAAQ,OAKtD,EAAK0E,YAAYhJ,EAAKmF,MAAK,EAAK6D,YAAYhJ,EAAKmF,IAAM,CAAErC,MAAO,GAAI8F,OAAQ,OAAQO,WAAW,IAAIC,MAAOC,YAChG,EAAKL,YAAYhJ,EAAKmF,IAAtB,MAAmChB,QAAO,SAAAkC,GAAC,OAAkC,IAA9BA,EAAEiD,KAAKhF,QAAQ0D,EAAIsB,SACtE9I,QACH,EAAKqH,OAAOrB,EAAK,kBAAD,OAAmBwB,EAAIsB,KAAvB,0DACpB,aAEJ,EAAKN,YAAYhJ,EAAKmF,IAAtB,MAAmCrE,KAAKkH,QACxC,EAAKuB,oBAAsB,EAAKP,YAAYhJ,EAAKmF,IAAtB,cAXnB,EAAK0C,OAAOrB,EAAK,+DACrB,aANI,EAAKqB,OAAOrB,EAAK,8CACrB,aAHR,2BAAwC,IA9BjB,8BAkDvB,QAAI0B,KAAKc,YAAYhJ,EAAKmF,MACtB+C,KAAKsB,cAAcxJ,EAAKmF,IACxB+C,KAAKuB,cACAC,SAAS1J,EAAKmF,KAEZ,KA7GA,6BAyHkB,WAA5BwE,EAA4B,uDAAlB,GAAIC,EAAc,wDACvB7B,EAAW,SAACC,GAEd,OADA,EAAK5F,EAAI4F,EACF4B,EAAO,EAAO,EAAKxH,GAK9B,OAFA8F,KAAK9F,EAAI,KAGG2F,GAFZ4B,EAAUzB,KAAK2B,YAAYF,IAENzB,KAAK4B,OAAOH,GADH,QAjInB,0CA0IiB,WAAdA,EAAc,uDAAJ,GAClB5B,EAAW,SAACC,GAEd,OADA,EAAK5F,EAAI4F,EACF,GAIX,OACOD,GAFP4B,EAAUzB,KAAK2B,YAAYF,IAEXzB,KAAK4B,OAAOH,GAASI,eADP,QAjJnB,8BA4JPC,GAA0C,IAAhCC,EAAgC,uDAApB,KAAMN,EAAc,uDAAJ,GAC1C,OAAOzB,KAAKgC,WAAWF,EAAUC,EAAWN,EAAS,YA7J1C,2BAuKVK,GAAwB,IAAdL,EAAc,uDAAJ,GACrB,OAAOzB,KAAKgC,WAAWF,EAAU,KAAML,EAAS,SAxKrC,qCAgLc,WAAhBrB,EAAgB,uDAAJ,GACfP,EAAW,SAACC,GAEd,OADA,EAAK5F,EAAI4F,EACF,GAIX,GADAM,EAAYJ,KAAKsB,cAAclB,IAC1B/D,EAAW2D,KAAK4B,QAAS,OAAO/B,EAAS,IAC9C,IAAIoC,EAAQ1J,OAAOiE,QAAQwD,KAAK4B,QAAQ/E,QAAO,SAACzB,EAAD,GAAyB,aAApBqG,EAAoB,KAAXhB,EAAW,KAGpE,OAFyC,IAArCgB,EAAQrF,QAAQgE,GAAa,KAAaA,GAAa,EAAKU,YAAYV,GAAYhF,EAAExC,KAAK6H,EAAK,MAC1FL,GAAWhF,EAAExC,KAAK6H,EAAK,MAC1BrF,IACR,IACH,OAAOyE,EAASoC,KA7LL,+BAsMQ,IAAhB7B,EAAgB,uDAAJ,GAIf,GAHAJ,KAAK9F,EAAI,OAETkG,EAAYJ,KAAKsB,cAAclB,IACf,KAAM,wBAEtB,IAAKJ,KAAKkC,OAAO9B,GAAY,KAAM,qEACnC,OAAOJ,KAAKkC,OAAO9B,GAAW+B,YA7MnB,iCAsNJL,GAA2D,WAAjDC,EAAiD,uDAArC,KAAMN,EAA+B,uDAArB,GAAIW,EAAiB,uDAAV,SAClDvC,EAAW,SAACC,GAEd,OADA,EAAK5F,EAAI4F,EACF,GAGP7C,EAAK+C,KAAK2B,YAAYF,GAC1B,IAAKxE,EAED,OADI+C,KAAKL,OAAOnB,EAAQ,6BACjBqB,GAAS,GAGpB,IAAKpC,EAASqE,GAEV,OADI9B,KAAKL,OAAOrB,EAAK,kCACduB,GAAS,GAGpB,IAAKG,KAAK4B,OAAO3E,GAEb,OADI+C,KAAKL,OAAOnB,EAAQ,iCAAD,OAAkCvB,EAAlC,eAChB4C,GAAS,GAGpB,IAAIwC,GAAU,EAIdP,EAAWvJ,OAAOiE,QAAQsF,GAAUjF,QAAO,SAACzB,EAAD,GAAqB,aAAhBF,EAAgB,KAAXN,EAAW,KACtD0H,EAAM,EAAKC,WAAWnG,QAAQlB,GAEpC,OADI,EAAKqH,WAAWD,KAASpH,GAAKE,EAAExC,KAAK,CAAE4J,IAAKF,EAAKxK,KAAM,EAAF,GAAKoD,EAAMN,KAC7DQ,IACR,IAEH,IAAK,IAAIoH,EAAM,EAAGA,EAAMV,EAASxJ,OAAQkK,IACrC,QAAsCzF,KAAjC+E,EAASU,IAAQ,IAAlB,KAAJ,CAD4C,QAEvBjK,OAAOiE,QAAQsF,EAASU,GAAT,MAAuB,GAFf,GAErCtH,EAFqC,KAEhCN,EAFgC,KAG/B,OAARM,GAAwB,SAARA,QAA4C6B,IAAzBiD,KAAK4B,OAAO3E,GAAI/B,GAShD8E,KAAKL,OAAOrB,EAAK,mCAAD,OAAoCpD,KAP5B8E,KAAK4B,OAAO3E,GAAI/B,GADhC,SAARA,IACkB,IAAd6G,EAA2CxJ,OAAOkK,OAAO,GAAIzC,KAAK4B,OAAO3E,GAAI/B,GAAMN,GAE7DA,EAE9ByH,GAAU,GAelB,OARIA,GAAoB,QAATD,IACXpC,KAAK0C,oBAAoBzF,GACrB+C,KAAK2C,mBAAqB1F,IAAI+C,KAAK2C,iBAAmB,IACtD3C,KAAK4C,cAAc3F,WAAY+C,KAAK4C,cAAc3F,IAKnD4C,EAASwC,KA9QL,+BAqRNpF,GAAI,WAET,KADAA,EAAKD,EAAQC,IACJ,KAAM,iBAIf,GAFK+C,KAAKkC,OAAOjF,KAAK+C,KAAKkC,OAAOjF,GAAMqC,MAEnCjD,EAAW2D,KAAK4B,QAAS,CAC1B,IAAMiB,EAAM,iDAAH,OAAoD5F,GAG7D,OAFI+C,KAAKL,OAAOnB,EAAQqE,GACxB7C,KAAKkC,OAAOjF,GAAIiD,OAAO2C,GAChB,KAGX,IAAMC,EAAYvK,OAAOwI,OAAOf,KAAK4B,QAAQ3F,QAAO,SAAAkC,GAAC,OAA0B,IAAtBA,EAAElB,GAAGb,QAAQa,MACtE,IAAK6F,EAAUxK,OAAQ,CACnB,IAAMuK,EAAM,wCAAH,OAA2C5F,EAA3C,KAGT,OAFI+C,KAAKL,OAAOnB,EAAQqE,GACxB7C,KAAKkC,OAAOjF,GAAIiD,OAAO2C,GAChB,KAGX,IAuBI,OARArF,QAAQrB,IAAI2G,EAAU5E,KAAI,SAAAC,GAAC,OAAIA,EAAEmB,GAAG6C,cAAYlC,MAAK,SAAA9B,GACjD,IAAM4E,EAAS5E,EAAED,KAAI,SAAA3C,GAAC,OAfP,SAACyH,GAChB,IAAMD,EAAS,GACf,IAAKtF,EAASuF,GAAO,OAAO,KAC5B,IAAK,IAAI5K,EAAI,EAAGA,EAAI,EAAKmK,WAAWjK,OAAQF,IAAK,CAC7C,IAAM6K,EAAO,EAAKV,WAAWnK,GACzB4K,EAAKC,KAAOF,EAAOE,GAAQD,EAAKC,IAExC,OAAOF,EAQmBG,CAAW3H,EAAEkF,UAAQxE,QAAO,SAAAb,GAAC,QAAMA,KAC7D,EAAK8G,OAAOjF,GAAIkG,QAAQJ,MACzB,SAAAhE,GAECP,EAAQ,yBAA0BO,OAG/B,EACT,MAAOA,GACLP,EAAQ,aAAcO,GAG1B,OAAO,IAtUI,oCA6UX,cAAsBxG,OAAOiE,QAAQwD,KAAKc,aAA1C,eAAwD,iBAA9C5F,EAA8C,KAAzC4B,EAAyC,KACpD,KAAIkD,KAAKqB,oBAAsBvE,EAAE,YAGf,aAAdA,EAAG4D,QAAuC,SAAd5D,EAAG4D,QAAmC,UAAd5D,EAAG4D,OAA3D,CAJoD,UAMlC5D,EAAGlC,MAAMmG,UANyB,IAMpD,2BAAqC,KAC3BqC,EAAK,EAAH,CAAKnG,GAAI/B,GADgB,SAEf8E,KAAKqD,SAASD,IAChB5E,EAAQ,gBAAD,OAAiBtD,EAAjB,qBATyB,gCAYxD,OAAO8E,OAzVI,iCAkWK,IAAXN,EAAW,uDAAJ,GACZ,IAAKA,EAAKzC,KAAOyC,EAAK0B,KAAM,KAAO,+BACnC,IAAKpE,EAAQ0C,EAAKzC,IAAK,KAAO,oBAE9B,IAAMqG,EAAM,GAAH,OAAM5D,EAAKzC,GAAX,aAAkByC,EAAK0B,MAChC,GAAIpB,KAAK4B,OAAO0B,GAEZ,OADItD,KAAKL,OAAO5B,EAAI,qBAAD,OAAsBuF,EAAtB,iBACZ,KAEX,IACI5D,EAAKzC,GAAKqG,EACV,IAAM/H,EAAI,IAAIyE,KAAKuD,MAAM7D,EAAMM,KAAKL,OACpCK,KAAK4B,OAAO0B,GAAO/H,EACrB,MAAOwD,GAEL,OADAP,EAAQO,GACD,KAEX,OAAOiB,KAAK4B,OAAO0B,KAnXR,4BAyYThH,GACF,IAAKA,EAAK,OAAO,KACjB,IAAK0D,KAAKM,WAAY,OAAO,KAC7B,IAEI,OADAN,KAAKM,WAAWC,eAAeiD,KAAKlH,IAC7B,EACT,MAAOyC,GAEL,OADAP,EAAQ,mCACD,QAjZA,sCAwZCvB,GACZ,GAAI1E,OAAOwI,OAAOf,KAAK4B,QAAQtJ,OAC3B,cAAgBC,OAAOwI,OAAOf,KAAK4B,QAAnC,eAA4C,CAAvC,IAAI6B,EAAG,KACJzD,KAAK4C,cAAca,EAAIxG,YAAY+C,KAAK4C,cAAca,EAAIxG,IAC1DwG,EAAIxG,GAAGyG,SAASzG,WAAY+C,KAAK4B,OAAO6B,EAAIxG,IAGpD+C,KAAKc,YAAY7D,WAAY+C,KAAKc,YAAY7D,GAC9C+C,KAAKkC,OAAOjF,WAAY+C,KAAKkC,OAAOjF,GAGxC+C,KAAK0C,oBAAoBzF,KAnad,4BAkYX,OAAOuC,EAASQ,UAlYL,GAWQT,IA8c3B,OADwB1D,EAAQ,GAARA,CAA8B4D,K,4sCCpd1D3F,EAAOD,QAAU,WAAM,MACwCgC,EAAQ,GAA3DQ,EADW,EACXA,WAAYiC,EADD,EACCA,KAAMtB,EADP,EACOA,QAAS2B,EADhB,EACgBA,KAAMZ,EADtB,EACsBA,IAAKJ,EAD3B,EAC2BA,SAC9C,kBAMI,aAA8B,IAAlB+B,EAAkB,uDAAX,GAAIC,EAAO,iDAC1BK,KAAKL,MAAQA,IAAS,EACtBK,KAAKJ,OAASF,GAAQ,IAAIE,OAAS,KAEnCI,KAAKM,YAAcZ,GAAQ,IAAIY,WAAazE,EAAQ,GAARA,GAAkC,KAC9EmE,KAAK4B,OAAS,GACd5B,KAAKc,YAAc,GACnBd,KAAKqB,oBAAsB,EAC3BrB,KAAK2D,eAAiB,KACtB3D,KAAK4D,aAAe,KACpB5D,KAAK4C,cAAgB,GACrB5C,KAAK2C,iBAAmB,GACxB3C,KAAKkC,OAAS,GACdlC,KAAK9F,OAAI6C,EACTiD,KAAK6D,gBAAkB,G,QApB/B,O,EAAA,G,EAAA,6CA4BwC,WAAhBC,EAAgB,uDAAJ,GAC5B,GAAKA,EAAL,CACA,IAAIC,GAAU,EAYd,OAXI/D,KAAK6D,gBAAgBvL,QACrB0H,KAAK6D,gBAAgBG,SAAQ,SAACC,EAAS7L,GAAM,IACjC8L,GAAgBD,GAAW,IAA3BC,YACHA,IACmC,IAApCA,EAAY9H,QAAQ0H,KACpB,EAAKD,gBAAgBrK,OAAOpB,EAAG,GAC/B2L,GAAU,EACN,EAAKpE,OAAO5B,EAAI,qDAAD,OAAsDmG,EAAtD,0BAIxBH,KA1Cf,qCAmDmBG,EAAapM,GAExB,OADAkI,KAAK6D,gBAAgBjL,KAAK,CAAEqI,WAAW,IAAIC,MAAOC,UAAW+C,cAAapM,SACnEkI,KAAK6D,kBArDpB,gDA6D0D,WAA9BM,EAA8B,uDAAL,IAC7C,IAAKnE,KAAK6D,gBAAgBvL,OAAQ,MAAO,GAEzC0H,KAAK6D,gBAAgBO,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEpD,UAAYqD,EAAErD,aACpD,IAAMsD,EAAqB5F,EAAKqB,KAAK6D,iBAE/BW,EAAaD,EAAmB1H,QAAO,SAACzB,EAAG0B,EAAI1E,GAAM,IAC/C6I,EAAcnE,EAAdmE,UAGFwD,GAAgB,IAAIvD,MAAOC,UAAYgD,EAQ7C,OANqBM,EAAgBxD,GADvBwD,EAAgBxD,EAAakD,GACgBA,IAEvD/I,EAAI0B,EAEJ,EAAK+G,gBAAgBrK,OAAOpB,EAAG,IAE5BgD,IACR,IAEH,OAAKiB,EAAWmI,GACJA,EADwB,KAlF5C,qCA4F+D,WAA9CE,EAA8C,uDAA9B,GAAIC,EAA0B,uDAAN,KAEjD,GADAD,EAAiB/G,EAAS+G,GAAsBA,EAAL,IACtC1E,KAAKgB,aAAa0D,IAAkBA,EAAe,OAAO,KAE/D,GADArG,QAAQN,IAAI,wBAAyB2G,GACjCA,EAActI,QAAQ,KAAO,IAAM4D,KAAK4B,OAAO8C,GAE/C,OADI1E,KAAKL,OAAOrB,EAAK,6EACd,KAGX,GAAIoG,EAAcE,MAAM,KAAKtM,OAAS,GAAyC,IAApCoM,EAAcE,MAAM,KAAKtM,OAEhE,OADI0H,KAAKL,OAAOrB,EAAK,kCAAD,OAAmCoG,EAAnC,qCACb,KAIX,GADIC,GAAmB3E,KAAK2B,YAAY+C,GAAe,GACnD1E,KAAK4B,OAAO8C,GAEZ,OADIC,GAAmB3E,KAAK2B,YAAY+C,GACjCA,EAMX,IAAMG,EAAiB,SAAC1K,GACpB,IAAMiB,EAAIjB,EAAKyK,MAAM,MAAM,IAAMzK,EAEjC,OADwB,EAAKyJ,cAAgB,IAAIxH,QAAQhB,GAAK,GACxCA,EAAU,EAAKwI,aAC5B,EAAKD,gBAAkBvI,EAAU,EAAKuI,eAAL,KAA6BvI,EAChE,EAAKwI,cAGVkB,EAAaD,EAAeH,GAIlC,OAHKI,EAEMH,GAAmB3E,KAAK2B,YAAYmD,GADvC9E,KAAKL,OAAOrB,EAAK,+DAAD,OAAgEoG,IAEjFI,IA/Hf,sCAsIgD,IAA9BhB,EAA8B,uDAAlB,GAAInE,EAAc,uDAAN,KAGlC,OAFKmE,GAAa9D,KAAK4D,eAAcE,EAAY9D,KAAK2D,iBACtDG,EAAY9D,KAAKa,eAAeiD,EAAWnE,KAEvCK,KAAKc,YAAYgD,KAAY9D,KAAK2D,eAAiBG,GAChDA,GAFgB,OAzI/B,oCAoJ4C,IAA5BrC,EAA4B,uDAAlB,GAAI9B,EAAc,uDAAN,KAI9B,OAHK8B,GAAWzB,KAAK4D,eAAcnC,EAAUzB,KAAK4D,eAClDnC,EAAUzB,KAAK+E,WAAWtD,EAAS9B,KAG/BK,KAAK4B,OAAOH,KAAUzB,KAAK4D,aAAenC,GACvCA,GAFc,OAxJ7B,qCAmKmBxE,GAEX,OADAA,EAAKD,EAAQC,KAERA,GAAM,IAAI2H,MAAM,KAAKtM,OAAS,EAAU,KACxC0H,KAAKgB,aAAa/D,GAChBA,EAD4B,KAFnB,OArKxB,yCAoLiG,IACrF+H,EADS5C,EAA4E,uDAArE,SAAUX,EAA2D,uDAAjD,GAAIwD,EAA6C,uDAAlC,GAAIvD,EAA8B,wDAAhBwD,EAAgB,uDAAJ,GAKrF,IAmBI,OAZAF,EAAezM,OAAOiE,QAAQyI,GAAUpI,QAAO,SAACzB,EAAD,EAAchD,GAAM,aAAf+G,EAAe,KAE/D,OAF+D,UAC1CpC,IAAjBmI,EAAU/F,KAAkB/D,EAAE+D,GAAK+F,EAAU/F,IAC1C/D,IACR,IAEEiB,EAAW2I,KAAeA,OAAejI,GAG1CV,EAAW2I,GAAgB3I,EAAW4I,KAAc,IAAGD,EAAezM,OAAOwI,OAAOiE,GAAcjM,SAGzF,WAATqJ,IAAmBpC,KAAK4C,cAAcnB,GAAWuD,GAC9CtD,EAAO1B,KAAOgF,EACvB,MAAOjG,GAGL,OAFIiB,KAAKL,OAAOrB,EAAK,yCAAD,OAA0CmD,IACjD,WAATW,IAAmBpC,KAAK4C,cAAcnB,GAAWuD,GAC9CtD,EAAO1B,KAAOgF,KAhNjC,mCAoNiBpH,GAGT,OADa,IAAIuH,OADL,yCACiB,MACpBC,KAAKxH,IAGH,OA1NnB,iCAoOe6D,GAAuB,IAAd9B,EAAc,uDAAN,KAExB,OADA8B,EAAUzE,EAAQyE,IAEbzB,KAAKgB,aAAaS,IACQ,IAA3BA,EAAQrF,QAAR,MAAqC,KACpC4D,KAAK4B,OAAOH,GAIVA,GAHCzB,KAAKL,OAAmB,OAAVA,GAAgBrB,EAAK,yCAAD,OAA0CmD,IACzE,WAJX,EADqB,OAtO7B,iCAuPQ,MAAO,CAAC,WAAY,OAAQ,OAAQ,KAAM,e,iBAvPlD,O,cCFJ3H,EAAOD,QAAU,SAAUyJ,GAAmB,IAAd3D,EAAc,uDAAN,KACpC,OAAQ,IAAI,WAAY,WACd0F,EAAS,eACfrF,KAAKsD,KAAOA,GAAO,IAAIpG,aAAc,IAAIgE,MAAOC,UAChDnB,KAAKL,MAAQA,EACbK,KAAKsF,QAAU,GACftF,KAAKuF,iBAAmB,GAExBvF,KAAKO,aAAe,WAEhB,OADA,EAAKiF,WACE,GAOXxF,KAAKwD,KAAO,WAAiB,IAAhB1L,EAAgB,uDAAT,KAKhB,OAJI,EAAKyN,iBAAiB,EAAKjC,KAAM,EAAKiC,iBAAiB,EAAKjC,KAAKE,KAAK1L,GAElE,EAAK6H,OAAOtB,QAAQN,IAAI,CAAEqB,QAAS,GAAF,OAAKiG,EAAL,0BAAqC/B,IAAK,EAAKA,MAEjF,GAQXtD,KAAKwF,SAAW,WACZ,GAAI,EAAKD,iBAAiB,EAAKjC,KAAM,OAAO,EAC5C,IAAM5B,EAAO,EAiCb,OADK,EAAK6D,iBAAiB,EAAKjC,OAAM,EAAKiC,iBAAiB,EAAKjC,KAAO,IA/B9D,WAAY,WAClBtD,KAAKsD,IAAM5B,EAAK4B,IAChBtD,KAAKlI,KAAO,KAEZkI,KAAKwD,KAAO,SAAC1L,GACiB,QAArBA,GAAQ,IAAIsK,OAAe,EAAKtK,KAAOA,GAKlB,QAArBA,GAAQ,IAAIsK,KAWb,EAAKtK,KACiC,mBAA3B4J,EAAK4D,QAAQ5D,EAAK4B,MACzB5B,EAAK4D,QAAQ5D,EAAK4B,KAAK,EAAKxL,KAAM4J,EAAK4B,KAGvC,EAAK3D,OAAOtB,QAAQN,IAAR,UAAesH,EAAf,sBAfO,mBAAZvN,EAAK2N,KAGP/D,EAAK4D,QAAQ5D,EAAK4B,OAAM5B,EAAK4D,QAAQ5D,EAAK4B,KAAOxL,EAAK2N,IACvD,EAAK3N,MAAMA,EAAK2N,GAAG,EAAK3N,KAAM4J,EAAK4B,SAiBhD,GAGXtD,KAAK0F,IAAM,WAOP,cANO,EAAKJ,QAAQ,EAAKhC,YAClB,EAAKiC,iBAAiB,EAAKjC,MAE7B,EAAKgC,QAAQ,EAAKhC,MAAS,EAAKiC,iBAAiB,EAAKjC,KAGpD,GASXtD,KAAKQ,UAAY,SAACiF,GAEd,MAD2B,mBAAPA,GAKf,EAAKF,iBAAiB,EAAKjC,MAG5B,EAAKkC,WAEL,EAAKD,iBAAiB,EAAKjC,MAAM,EAAKiC,iBAAiB,EAAKjC,KAAKE,KAAK,CAAEpB,KAAM,KAAMqD,OACjF,IATC,EAAK9F,OAAOtB,QAAQN,IAAR,UAAesH,EAAf,gCACT,IAvFX,CAiGN/B,EAAK3D,K,oRCjGX7F,EAAOD,QAAU,SAACyG,GAAe,MAE4CzE,EAAQ,GAAzE8B,EAFqB,EAErBA,SAAUW,EAFW,EAEXA,KAAMP,EAFK,EAELA,IAAKX,EAFA,EAEAA,SAAUoB,EAFV,EAEUA,QAAS/B,EAFnB,EAEmBA,KAAMkC,EAFzB,EAEyBA,KAAMlB,EAF/B,EAE+BA,SACtD6B,EAAKzD,EAAQ,GACnB,kBASI,aAA8B,IAAlB6D,EAAkB,uDAAX,GAAIC,EAAO,uCAG1B,GAH0B,UAC1BK,KAAKL,MAAQA,IAAS,GAClBvC,EAASsC,EAAKzC,KAAOyC,EAAKzC,MAAIyC,EAAKzC,GAAKyC,EAAKzC,GAAGC,aAC/CwC,EAAK0B,OAASzD,EAAS+B,EAAK0B,MAAO,KAAO,6BAE/CpB,KAAK2F,IAAM,KACX3F,KAAK4F,MAAQ,KACb5F,KAAK6F,QAAU,KACf7F,KAAK8F,MAAQ,KACb9F,KAAK+F,UAAY,KACjB/F,KAAKgG,WAAa,EAClBhG,KAAKiG,aAAe,EACpBjG,KAAKkG,aAAe,GAEpBlG,KAAKoB,KAAO1B,EAAK0B,KACjBpB,KAAK/C,GAAKyC,EAAKzC,GACf+C,KAAKU,OAAS,OAGVhB,EAAK5H,OAASkI,KAAK8F,QAAO9F,KAAKlI,KAAO4H,EAAK5H,MAC3C4H,EAAKyG,WAAUnG,KAAKmG,SAAWzG,EAAKyG,U,QA7BhD,O,EAAA,G,EAAA,8BAqIWrO,GAAoB,IAAdsO,EAAc,uDAAN,KACjB,MAAoB,aAAhBpG,KAAKU,QAAyC,SAAhBV,KAAKU,QAC/BV,KAAKL,OAAOrB,EAAK,yDACd0B,OAENvC,EAAS3F,IAASsO,GACfpG,KAAKL,OAAOrB,EAAK,iFACd0B,OAEPvC,EAAS3F,IAASsO,EAAOpG,KAAKlI,KAAOS,OAAOkK,OAAO,GAAIzC,KAAKlI,KAAMA,QACpDiF,IAATjF,IAAoBkI,KAAKlI,KAAOA,GAClCkI,QAhJf,4BA8RQ,MAAO,CAAEmG,SAAUnG,KAAKmG,SAAUrO,KAAMkI,KAAKlI,KAAMmF,GAAI+C,KAAK/C,GAAImE,KAAMpB,KAAKoB,KAAMV,OAAQV,KAAKU,UA9RtG,iCAqSeA,GAAQ,YACC,aAAXA,GAAoC,UAAXA,IAAwC,SAAjBV,KAAK6F,SAAsB7F,KAAKgG,WAAa,IAE1F1F,GACA+F,YAAW,WACH/F,GAAYA,EAAWgG,MAAM,CAAE7F,MAAO,EAAMC,cAIxDV,KAAKV,GAAG6D,QAAQ,CAAE1C,MAAOT,KAAK7D,QAC9B6D,KAAK6F,QAAU,UA/S3B,mCAuTiBnF,GAAQ,WACF,SAAXA,GAEA2F,YAAW,WACH/F,GAAYA,EAAWgG,MAAM,CAAE7F,MAAO,EAAMC,OAAQ,cA3TxE,yBAoCQ,OAAIV,KAAA,MACJA,KAAA,IAAcV,KADUU,KAAA,MApChC,uBAyCW9D,GACH,GAAI8D,KAAK2F,IACD3F,KAAKL,OAAOrB,EAAK,iCAAD,OAAkC0B,KAAK2F,UAD/D,CAIA,IAAKzJ,EAAG,KAAO,iBACf,GAAIA,EAAE0I,MAAM,KAAKtM,OAAS,EAAG,KAAO,6BACpC,IAAyB,IAArB4D,EAAEE,QAAF,MAAwB,KAAO,yCACnC,IAA0B,IAAtBF,EAAEE,QAAF,OAAyB,KAAO,yCAGpC,IAAMmK,EAAM,yCAEZ,GADa,IAAIpB,OAAOoB,EAAK,MACpBnB,KAAKlJ,GAAI,KAAM,sCAAN,OAA6CqK,GAI/D,IAA+B,KAF/BrK,EAAIA,EAAEsK,QAAQ,MAAO,KAAKrJ,eAEpBf,QAAQ4D,KAAK4F,OACf,2FAGJ5F,KAAK2F,IAAMzJ,IA9DnB,eAkEQ,OAAO8D,KAAK2F,MAlEpB,+BAsEQ,OAAO3F,KAAK+F,WAtEpB,aAyEiB7J,GACL8D,KAAK+F,UACD/F,KAAKL,OAAOrB,EAAK,sCAAD,OAAuC0B,KAAK+F,YAG/D7J,IACAyB,EAASzB,GAKd8D,KAAK+F,UAAY7J,EAJT8D,KAAKL,OAAOrB,EAAK,4BAA6BpC,MAhF9D,yBAuFaA,GACL,GAAI8D,KAAK4F,MACD5F,KAAKL,OAAOrB,EAAK,uCAIzB,GAAKpC,EACL,GAAKyB,EAASzB,GAAd,CAIA,IAAyB,IAArBA,EAAEE,QAAQ,MAAc,KAAO,kCACnC,GAAIF,EAAE0I,MAAM,KAAKtM,OAAS,EAAG,KAAO,8CACpC,IAAMiO,EAAM,yCAEZ,GADa,IAAIpB,OAAOoB,EAAK,MACpBnB,KAAKlJ,GAAI,KAAM,wCAAN,OAA+CqK,GAEjEvG,KAAK4F,MAAQ1J,EAAEsK,QAAQ,MAAO,KAAKrJ,mBAT3B6C,KAAKL,OAAOrB,EAAK,0BA/FjC,eA4GQ,OAAO0B,KAAK4F,QA5GpB,yBA+Ga1J,GAKL,GADiC,aAAhB8D,KAAKU,QAAyC,SAAhBV,KAAKU,OAIhD,OADIV,KAAKL,OAAOrB,EAAK,8DACd,KAGX0B,KAAKgG,aACe,SAAhBhG,KAAKU,QAAoC,OAAfV,KAAK8F,OAAkB9F,KAAKgG,WAAa,IAAGhG,KAAKU,OAAS,WACxFV,KAAK8F,MAAQ5J,GA5HrB,eAoJQ,OAAO8D,KAAK8F,QApJpB,uCA6JQ,MAAO,CACHW,KAAM,CAAE7L,MAAO,EAAG8L,KAAK,GACvBrE,QAAS,CAAEzH,MAAO,EAAG8L,KAAK,GAC1BC,SAAU,CAAE/L,MAAO,EAAG8L,KAAK,GAC3BE,KAAM,CAAEhM,MAAO,EAAG8L,KAAK,GACvBhI,MAAO,CAAE9D,MAAO,EAAG8L,KAAK,MAlKpC,6BAgLQ,OAAO1G,KAAK6F,SAhLpB,aAmLe3J,GAAG,YAEV,SAAE2K,GACE,IAEI,GAAI,EAAKC,iBAAiBD,GAAMjM,MAAQ,IAAyC,IAApC,EAAKkM,iBAAiBD,GAAMH,IAAc,OAAO,EAChG,MAAO3H,GACLP,EAAQ,mCAGZ,GAAqB,aAAjB,EAAKqH,SAA2C,SAAjB,EAAKA,QAEpC,OADI,EAAKlG,OAAOrB,EAAK,gDAAD,OAAiD,EAAKrB,MACnE,EAGX,OAAQ4J,GACJ,IAAK,OACD,GAAqB,YAAjB,EAAKhB,QAAuB,CACxB,EAAKlG,OAAOrB,EAAK,sDACrB,MAEJ,EAAKuH,QAAUgB,EACf,EAAKC,iBAAiBD,GAAMH,KAAM,EAClC,EAAKK,aAAa7K,GAClB,EAAK8K,eAAiBH,EACtB,MAEJ,IAAK,UACD,GAAqB,aAAjB,EAAKhB,QAAwB,CACzB,EAAKlG,OAAOrB,EAAK,uEACrB,MAGA,EAAK0H,WAAa,IAClB,EAAKH,QAAUgB,EACf,EAAKC,iBAAiBD,GAAMH,KAAM,EAClC,EAAKM,eAAiBH,EAClB,EAAKlH,OAAO5B,EAAI,MAAD,OAAO,EAAKd,GAAZ,oBAGvB,MAEJ,IAAK,WAED,EAAK6J,iBAAiBD,GAAMH,KAAM,EAClC,EAAKM,eAAiBH,EAEtB,EAAKhB,QAAUgB,EACf,EAAKI,WAAW/K,GAGhB,MAEJ,IAAK,OACD,GAAqB,aAAjB,EAAK2J,QAAwB,CACzB,EAAKlG,OAAOrB,EAAK,wEACrB,MAEJ,EAAKuH,QAAUgB,EACf,EAAKC,iBAAiBD,GAAMH,KAAM,EAClC,EAAKM,eAAiBH,EACtB,MAEJ,IAAK,QACD,GAAqB,aAAjB,EAAKhB,QAAwB,OAGjC,EAAKiB,iBAAiBD,GAAMH,KAAM,EAClC,EAAKM,eAAiBH,EACtB,EAAKI,WAAW/K,GAChB,MAEJ,QACQ,EAAKyD,OAAOrB,EAAK,MAAD,OAAO,EAAKrB,GAAZ,sCAA4C4J,EAA5C,uBAvEhC,CAyEG3K,KA9PX,mCAsQuBA,GAEf,IACMX,EAAI,CAAE0F,WADM,IAAIC,MAAOC,UACN5F,EAAG+D,KAC1BU,KAAKkG,aAAatN,KAAK2C,IA1Q/B,eA8QQ,IAAM2L,EAAczK,EAAKuD,KAAKkG,aAAa9B,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEpD,UAAYqD,EAAErD,aAAW/C,KAAI,SAAAC,GAAC,OAAIA,EAAC,MAE/F,OADA+I,EAAY/D,QAAQxE,EAAKqB,KAAKU,SACvBwG,IAhRf,qCA0RQ,OAAOlH,KAAKgH,eAAe7E,e,iBA1RnC,O,8lCCHJrI,EAAOD,QAAU,SAACsN,GAAiB,MACsCtL,EAAQ,GAArE8C,EADuB,EACvBA,KAAML,EADiB,EACjBA,KAAMZ,EADW,EACXA,QAASc,EADE,EACFA,QAASnC,EADP,EACOA,WAAYsB,EADnB,EACmBA,SAAU5B,EAD7B,EAC6BA,KAC5D,oB,kOAAA,U,QAAA,G,EAAA,E,0YACI,WAAY2D,EAAMC,GAAO,O,4FAAA,qBACfD,EAAMC,GAFpB,O,EAAA,G,EAAA,2CAMoC,IAAd8B,EAAc,uDAAJ,GAExBA,EAAUzB,KAAKoH,aAAa3F,GAAS,GACrC,IAAIE,EAAc3B,KAAK2B,YAAYF,GACnC,4DAA+BE,KAVvC,2BAcSF,EAASC,GAEVD,EAAUzB,KAAKoH,aAAa3F,GAAS,GACrC,IAAIE,EAAc3B,KAAK2B,YAAYF,GACnC,+CAAkBE,EAAaD,KAlBvC,2BAsBSI,EAAUL,GAEXA,EAAUzB,KAAKoH,aAAa3F,GAAS,GACrC,IAAIE,EAAc3B,KAAK2B,YAAYF,GACnC,+CAAkBK,EAAUH,KA1BpC,+BAkCyB,IAAdF,EAAc,uDAAJ,GAEbA,EAAUzB,KAAKoH,aAAa3F,GAAS,GACrC,IAAIE,EAAc3B,KAAK2B,YAAYF,GACnC,GAAKzB,KAAK4B,OAAOD,GAAjB,CAKA,GAAkD,UAA9C3B,KAAK4B,OAAOD,GAAa0F,YAAYlN,KAKzC,OAAO6F,KAAK4B,OAAOD,GAJX3B,KAAKL,OAAOnB,EAAQ,qBAAD,OAAsBiD,EAAtB,wCALnBzB,KAAKL,OAAOrB,EAAK,mCAAD,OAAoCmD,MAvCpE,8BAoDYK,EAAUC,EAAWN,GAEzBA,EAAUzB,KAAKoH,aAAa3F,GAAS,GACrC,IAAIE,EAAc3B,KAAK2B,YAAYF,GACnC,kDAAqBK,EAAUC,EAAWJ,KAxDlD,gCAgE4B,IAAhBmC,EAAgB,uDAAJ,GAGhB,OAFAA,EAAanG,EAASmG,GAAkBA,EAAL,GACnC9D,KAAKsB,cAAcwC,GACZ9D,OAnEf,kCA4EgC,IAAlBkE,EAAkB,uDAAJ,GAIpB,OAFAA,EAAclE,KAAKoH,aAAalD,GAAa,GAC7CA,EAAclE,KAAK2B,YAAYuC,GAC1BlE,KAAK4B,OAAOsC,IAIjBlE,KAAKsH,eAAepD,EAAavF,EAAKqB,KAAK4B,OAAOsC,GAAZ,OAEtClE,KAAK2C,iBAAmBuB,EACjBlE,OANCA,KAAKL,OAAOrB,EAAK,wDAAD,OAAyD4F,IACtElE,QAlFnB,4BAkGiE,IAAzDuH,EAAyD,uDAA7C,GAAIC,IAAyC,yDAAhBC,EAAgB,uDAAL,IAMpD,GAHAF,EAAYvH,KAAKoH,aAAaG,EAAWC,GAErCA,IAAkBD,EAAYvH,KAAK+E,WAAWwC,KAC7CA,EAED,OADIvH,KAAKL,OAAOrB,EAAK,8BACd0B,KAEX,IAAKA,KAAK4B,OAAO2F,GAEb,OADIvH,KAAKL,OAAOrB,EAAK,gDAAD,OAAiDiJ,IAC9DvH,KAEX,GAAIA,KAAK2C,iBAAkB,CAGvB,IAAM+E,EAAoB1H,KAAK2H,wBAAwBF,GACvD,GAAIpL,EAAWqL,GAAoB,KACvBxD,EAAsBwD,EAAtBxD,YAAapM,EAAS4P,EAAT5P,KACjBkI,KAAK2C,mBAAqBuB,IAC1BlE,KAAK4B,OAAOsC,GAAZ,KAAmC,KACnClE,KAAK4B,OAAO2F,GAAZ,KAAiCzP,QAGjCkI,KAAKL,OAAOrB,EAAK,sCAEzB0B,KAAK2C,iBAAmB,GAE5B,OAAO3C,OA/Hf,4BAuIsB,IAAdyB,EAAc,uDAAJ,GAGV,OADAzB,KAAKoH,aAAa3F,GAAS,GACpBzB,OA1If,8BAqJoE,IAA1DiF,EAA0D,uDAA/C,KAAmBxD,EAA4B,uDAAlB,GAAIC,EAAc,wDAG5D,OADAD,EAAUzB,KAAKoH,aAAa3F,GAAS,GAChCzB,KAAK4B,OAAOH,IAGb/D,EAAQuH,KAAcA,GAAY,IAAI3M,SACtC2M,EAAWlJ,EAAKkJ,GAAUpI,QAAO,SAACzB,EAAG0B,GAEjC,YADWC,IAAPD,IAAkB1B,EAAE0B,EAAG8K,SAAU,GAC9BxM,IACR,KAGF6J,GAAa5I,EAAW4I,GAItBjF,KAAK6H,iBAAiB,SAAUpG,EAASwD,EAAUvD,EAAM/C,EAAKqB,KAAK4B,OAAOH,GAAZ,QAHjEzB,KAAK4C,cAAcnB,GAAW9C,EAAKqB,KAAK4B,OAAOH,GAAZ,MAC5BC,EAAO1B,KAAOA,KAAK4C,cAAcnB,KAZVC,EAAO1B,UAAOjD,IAxJxD,gCAgLmD,IAAvCkI,EAAuC,uDAA5B,GAAcxD,EAAc,uDAAJ,GAEvC,GADAA,EAAUzB,KAAKoH,aAAa3F,GAAS,GAChCzB,KAAK4B,OAAOH,GAAjB,CACA,IAAMqG,OAA2C/K,IAAhCiD,KAAK4C,cAAcnB,IAA0D,OAAhCzB,KAAK4C,cAAcnB,GACjF,GAAKqG,EASL,OAPInK,EAASsH,KAAcA,GAAY,IAAI3M,SACvC2M,EAAWlJ,EAAKkJ,EAAS2C,OAAOpB,QAAQ,MAAO,IAAI5B,MAAM,MAAM/H,QAAO,SAACzB,EAAG0B,GAEtE,YADWC,IAAPD,IAAkB1B,EAAE0B,IAAM,GACvB1B,IACR,MAGFiB,EAAW2D,KAAK4C,cAAcnB,KAAaqG,EACxCzL,EAAW4I,QAAW,EACdjF,KAAK4C,cAAcnB,GAG9BwD,GAAa5I,EAAW4I,GAEfjF,KAAK6H,iBAAiB,WAAYpG,EAASwD,GAAU,EAAOjF,KAAK4C,cAAcnB,SADlD1E,IAAhCiD,KAAK4C,cAAcnB,QAAyB1E,EAAYiD,KAAK4C,cAAcnB,MAnM9F,gCA4McA,GAGN,OADAA,EAAUzB,KAAKoH,aAAa3F,GAAS,GAChCzB,KAAK4B,OAAOH,GACV9C,EAAKqB,KAAK4B,OAAOH,GAAZ,UADsB,OA/M1C,8BAwNYA,GAGJ,OADAA,EAAUzB,KAAKoH,aAAa3F,GAAS,GAChCzB,KAAK4B,OAAOH,GACV9C,EAAKqB,KAAK4B,OAAOH,GAAZ,QADsB,OA3N1C,4BAoOUA,GAGF,OADAA,EAAUzB,KAAKoH,aAAa3F,GAAS,GAChCzB,KAAK4B,OAAOH,GACV9C,EAAKqB,KAAK4B,OAAOH,GAAZ,MADsB,OAvO1C,2BAgPSA,GAGD,OADAA,EAAUzB,KAAKoH,aAAa3F,GAAS,GAChCzB,KAAK4B,OAAOH,GACV9C,EAAKqB,KAAK4B,OAAOH,GAAStF,OADC,U,iBAnP1C,GAAqCgL","file":"js/app.31263e02.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonpPocket\"] = window[\"webpackJsonpPocket\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([2,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","/* eslint-disable no-proto */\r\nconst util = require('util')\r\nconst color = require('bash-color')\r\n/**\r\n * @Utils\r\n * my own lodash/like `Utils`\r\n */\r\n\r\nexports.uniq = (arr) => arr.filter((v, i, all) => all.indexOf(v) === i)\r\nexports.objectSize = (obj) => (obj && (Object.prototype === (obj).__proto__)) ? Object.entries(obj).length : 0\r\nexports.last = (arr) => (arr && Array.prototype === (arr).__proto__) ? arr[arr.length - 1] : null\r\nexports.copyBy = (obj, refs) => refs.reduce((n, el, i) => {\r\n    if (obj[el] !== undefined) n[el] = obj[el]\r\n    return n\r\n}, {})\r\nexports.validID = (id) => !(id || '') ? null : (id || '').toString().toLowerCase()\r\nexports.isNumber = (n) => n !== undefined ? (n).__proto__ === Number.prototype : false\r\nexports.isPromise = (defer) => Promise.prototype === (defer || {}).__proto__\r\nexports.uniq = (arr) => arr.filter((el, i, all) => all.indexOf(el) === i)\r\nexports.isObject = (obj) => !obj ? false : (Object.prototype === (obj).__proto__ || (obj) instanceof Object)\r\nexports.isArray = (arr) => !arr ? false : Array.prototype === (arr).__proto__\r\nexports.isString = (str) => !str ? false : String.prototype === (str).__proto__\r\nexports.isFunction = (el) => typeof el === 'function'\r\nexports.log = function (...args) {\r\n    args = [].concat('[Pocket]', args)\r\n    args = args.map(z => util.inspect(z, false, 3, true))\r\n    console.log.apply(null, args)\r\n}\r\nexports.warn = function (...args) {\r\n    args = [].concat('[warning]', args)\r\n    args = args.map(z => color.cyan(util.inspect(z, false, 2, false), true))\r\n    console.warn.apply(null, args)\r\n}\r\nexports.onerror = function (...args) {\r\n    args = [].concat('[error]', args)\r\n    args = args.map(z => color.red(util.inspect(z, false, 2, false), true))\r\n    console.log('  ')\r\n    console.error.apply(null, args)\r\n    console.log('  ')\r\n}\r\nexports.copy = (data) => {\r\n    if (!data) return data\r\n    try {\r\n        return JSON.parse(JSON.stringify(data))\r\n    } catch (err) {\r\n        return err.toString()\r\n    }\r\n}\r\n\r\n/**\r\n* - accepting object of messages, example: `{'001':['my message',001],...}`\r\n* - returns : {'001':{message,code},...}\r\n*/\r\nexports.errorMessages = (messages) => {\r\n    const msgs = {}\r\n    for (let [k, v] of Object.entries(messages)) {\r\n        msgs[k] = { message: v[0], code: k }\r\n    }\r\n    return msgs\r\n}\r\n","module.exports = () => {\r\n    // const messageCODE = require('./errors') // DISPLAY MESSAGES WITH CODE\r\n    const { objectSize, log, onerror, warn, isArray, isObject, isPromise, validID } = require('./utils')\r\n    const sq = require('simple-q') // nice and simple promise/defer by `eaglex.net`\r\n    const PocketLibs = require('./Pocket.libs')()\r\n    const newProbe = require('./Probe')\r\n\r\n    /**\r\n     * TODO ADD to $update `// action/[merge], action/+-*` using regEx\r\n     */\r\n\r\n    class PocketModule extends PocketLibs {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n            if (this.dispatcher) {\r\n                this.dispatcher.initListener().subscribe(z => {\r\n                    const { probe, status } = z || {}\r\n\r\n                    if (status === 'error') {\r\n                        // NOTE dispatch data out\r\n                        if (this.debug) log(`[dispatcher] probe id:${probe.id} error`)\r\n                    }\r\n\r\n                    if (status === 'open') {\r\n                        if (this.debug) log(`[dispatcher] probe id:${probe.id} created`)\r\n                    }\r\n\r\n                    if (status === 'complete') {\r\n                        // NOTE dispatch data out\r\n                        if (this.debug) log(`[dispatcher] probe id:${probe.id} completed`)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        // ───────────────────────────────────────────────────────────────────────────────────────\r\n        //   :::::: U S E R   A P P L I C A T I O N   C A L L I N G   M E T H O D S : :  :   :    : \r\n        // ───────────────────────────────────────────────────────────────────────────────────────\r\n        //\r\n\r\n        /**\r\n         * ### $payload\r\n         * @prop {*} data `required`\r\n         * @prop {*} async `override current opts.sync for this payload`\r\n         * \r\n         * - `initialize new payload, for as many tasks`\r\n         * - `sets a multi task with instructions:`\r\n         * - `data = {\r\n                id: '', // 1 id for all tasks\r\n                tasks: [{ taskName: '', data: '', compaign: '' }]\r\n            }`\r\n\r\n         * - `call distributor and setDefer`\r\n         */\r\n        $payload(data = {}, async) {\r\n            this.d = null\r\n\r\n            // validate payload format\r\n            if (!isObject(data)) return false\r\n\r\n            const keys = Object.keys(data)\r\n            // must match all keys\r\n            if (keys.every(el => ['id', 'tasks'].indexOf(el) === -1)) {\r\n                if (this.debug) onerror(`[$payload] id and tasks are required`)\r\n                return false\r\n            }\r\n            if (!isArray(data['tasks'])) {\r\n                if (this.debug) onerror(`[$payload] data.tasks must be an array`)\r\n                return false\r\n            }\r\n\r\n            data.id = this.validProjectID(data.id)\r\n\r\n            if (!data.id) {\r\n                if (this.debug) onerror(`[$payload] data.id invalid`)\r\n                return false\r\n            }\r\n\r\n            if (this.payloadData[data.id]) {\r\n                if (this.debug) warn(`[$payload] this payload.id already exists`)\r\n                return false\r\n            }\r\n\r\n            // NOTE validate our pocket values before generating each `new Probe()`\r\n            for (let val of data['tasks'].values()) {\r\n                if (!val['task']) {\r\n                    if (this.debug) warn('[$payload] task must be set for your tasks')\r\n                    continue\r\n                }\r\n                // validate task \r\n                if (!this.idRegexValid(val['task']) || val['task'].indexOf('::') !== -1) {\r\n                    if (this.debug) warn('[$payload] invalid taskName, failed idRegexValid validation')\r\n                    continue\r\n                }\r\n\r\n                if (!this.payloadData[data.id]) this.payloadData[data.id] = { value: [], status: 'open', timestamp: new Date().getTime() }\r\n                const exists = this.payloadData[data.id]['value'].filter(z => z.task.indexOf(val.task) !== -1)\r\n                if (exists.length) {\r\n                    if (this.debug) warn(`the same task \"${val.task}\" already exists on the payload, you must choose uniq`)\r\n                    continue\r\n                }\r\n                this.payloadData[data.id]['value'].push(val)\r\n                this.lastPocketTimestamp = this.payloadData[data.id]['timestamp']\r\n            }\r\n            if (this.payloadData[data.id]) {\r\n                this.lastProjectID(data.id)\r\n                this.distributor()\r\n                    .setDefer(data.id)\r\n\r\n                return true\r\n            } else return false\r\n        }\r\n\r\n        /**\r\n         * ### $get\r\n          * - `get probe by 'id::taskName'`\r\n          * - `returns instance`\r\n          *  methods:`{get,all}` props: `{id,data,tasks,status}`\r\n          * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n          * @param {*} self = false optional, in case you want to chain, and access `Probe{}` through `...).d`\r\n         */\r\n        $get(probeID = '', self = false) {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return self ? this : this.d\r\n            }\r\n\r\n            this.d = null\r\n            probeID = this.lastProbeID(probeID)\r\n            if (!probeID) return returnAs(null)\r\n            else return returnAs(this.pocket[probeID])\r\n        }\r\n\r\n        /**\r\n         * ### $probeStatusAsync\r\n         * - return last probe status, this is a dynamic Promise, creates new promise every time status is changed, so then it needs to bu called again to get latest update\r\n         * @param {*} probeID \r\n         */\r\n        $probeStatusAsync(probeID = '') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            probeID = this.lastProbeID(probeID)\r\n            if (!probeID) return returnAs(null)\r\n            return returnAs(this.pocket[probeID].getStatusAsync)\r\n        }\r\n\r\n        /**\r\n         * ### $update\r\n         * - update Probe/task, for convenience, so we dont have do this, example: `pc.$get('abc123::grab').status='complete'`\r\n         * @param {*} dataFrom required, must specify what to update on Probe{}, example: `dataFrom:{data:'coke',status:'complete',compaign:'cocacola'}`\r\n         * @prop {*} mergeData optional if `true` will merge: `Object.assing({},probe[id].data,mergeData['data'])`\r\n         * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n         */\r\n        $update(dataFrom, mergeData = null, probeID = '') {\r\n            return this._setUpdate(dataFrom, mergeData, probeID, 'update')\r\n        }\r\n\r\n        /**\r\n         * ### $set\r\n         * - as name suggest sets up new new data for Probe/task, it derives from `$update` \r\n         * @param {*} dataFrom required, must specify what to set on Probe{}, example: `dataFrom:{data:'coke',status:'complete',compaign:'cocacola'}`\r\n         * - we should only use `$set` for initialization, this action also calls `clearStoreTransfers`\r\n         * @param {*} probeID required, example format: `${payload.id}::taskName`\r\n         */\r\n        $set(dataFrom, probeID = '') {\r\n            return this._setUpdate(dataFrom, null, probeID, 'set')\r\n        }\r\n\r\n        /**\r\n         * ### $activeTasks\r\n         * - list any active tasks for assigned Probes\r\n         * @param {*} payloadID optional, when set will only filter thru given job id (NOT Probe{} ID!)\r\n         */\r\n        $activeTasks(payloadID = '') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            payloadID = this.lastProjectID(payloadID)\r\n            if (!objectSize(this.pocket)) return returnAs([])\r\n            let tasks = Object.entries(this.pocket).reduce((n, [probeID, probe]) => {\r\n                if (probeID.indexOf(payloadID || '') === 0 && payloadID && this.payloadData[payloadID]) n.push(probe['task'])\r\n                else if (!payloadID) n.push(probe['task'])\r\n                return n\r\n            }, [])\r\n            return returnAs(tasks)\r\n        }\r\n\r\n        /**\r\n         * ### $ready\r\n         * - resolves currently active `$payload(...)`\r\n         * - `after completion of Pocket, instance data for all Probes is deleted`\r\n         * @param {*} payloadID `required`\r\n         */\r\n        $ready(payloadID = '') {\r\n            this.d = null\r\n\r\n            payloadID = this.lastProjectID(payloadID)\r\n            if (!payloadID) throw (`payloadID must be set`)\r\n\r\n            if (!this._ready[payloadID]) throw (`ready[payloadID] is not set, maybe you called it before $payload()`)\r\n            return this._ready[payloadID].promise()\r\n        }\r\n\r\n        //\r\n        // ──────────────────────────────────────────────────────\r\n        //   :::::: E N D : :  :   :    :     :        :          \r\n        // ──────────────────────────────────────────────────────  \r\n\r\n        // extends  `$update` and `$set`\r\n        _setUpdate(dataFrom, mergeData = null, probeID = '', type = 'update') {\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            let id = this.lastProbeID(probeID)\r\n            if (!id) {\r\n                if (this.debug) onerror(`[$update] must specify id`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            if (!isObject(dataFrom)) {\r\n                if (this.debug) warn(`[$update] dataFrom must be an `)\r\n                return returnAs(false)\r\n            }\r\n\r\n            if (!this.pocket[id]) {\r\n                if (this.debug) onerror(`[$update] this.pocket with id:${id} not found`)\r\n                return returnAs(false)\r\n            }\r\n\r\n            let updated = false\r\n            // reorder dataFrom, make sure if `status` exists, it is shifted to last position, so the Probe{} doent change state before other values got chance to do so, nice!\r\n\r\n            // we need to convert dataFrom{} to dataFrom[]>array to achieve this\r\n            dataFrom = Object.entries(dataFrom).reduce((n, [key, value]) => {\r\n                const pos = this.probeProps.indexOf(key) // new order\r\n                if (this.probeProps[pos] === key) n.push({ inx: pos, data: { [key]: value } })\r\n                return n\r\n            }, [])\r\n\r\n            for (let inx = 0; inx < dataFrom.length; inx++) {\r\n                if ((dataFrom[inx] || {})['data'] === undefined) continue\r\n                const [key, value] = Object.entries(dataFrom[inx]['data'])[0]\r\n                if ((key !== 'id' && key !== 'task') && this.pocket[id][key] !== undefined) {\r\n                    if (key === 'data') {\r\n                        if (mergeData === true) this.pocket[id][key] = Object.assign({}, this.pocket[id][key], value)\r\n                        else this.pocket[id][key] = value\r\n                    } else this.pocket[id][key] = value\r\n\r\n                    updated = true\r\n                    continue\r\n                } else {\r\n                    if (this.debug) warn(`[$update] not a valid propName: ${key}`)\r\n                }\r\n            }\r\n            // when setting new data, using `$set()` we should clear any cached Probes and realated data\r\n            if (updated && type === 'set') {\r\n                this.clearStoreTransfers(id)\r\n                if (this.$transfer_lastID === id) this.$transfer_lastID = ''\r\n                if (this._$cached_data[id]) delete this._$cached_data[id]\r\n            }\r\n\r\n            // if(updated && type==='update') { }\r\n\r\n            return returnAs(updated)\r\n        }\r\n\r\n        /**\r\n         * - sets defer for `$ready()` initially after calling payload \r\n         * @param {*} id required\r\n         */\r\n        setDefer(id) {\r\n            id = validID(id)\r\n            if (!id) throw 'id must be set'\r\n\r\n            if (!this._ready[id]) this._ready[id] = sq()\r\n\r\n            if (!objectSize(this.pocket)) {\r\n                const msg = `[setDefer] probe is empty, so nothing set, id:${id}`\r\n                if (this.debug) onerror(msg)\r\n                this._ready[id].reject(msg)\r\n                return null\r\n            }\r\n\r\n            const pocketSet = Object.values(this.pocket).filter(z => z.id.indexOf(id) !== -1)\r\n            if (!pocketSet.length) {\r\n                const msg = `[setDefer] no pocketSet found for id:${id} `\r\n                if (this.debug) onerror(msg)\r\n                this._ready[id].reject(msg)\r\n                return null\r\n            }\r\n\r\n            try {\r\n                const userOutput = (pock) => {\r\n                    const output = {}\r\n                    if (!isObject(pock)) return null\r\n                    for (let i = 0; i < this.probeProps.length; i++) {\r\n                        const prop = this.probeProps[i]\r\n                        if (pock[prop]) output[prop] = pock[prop]\r\n                    }\r\n                    return output\r\n                }\r\n                /**\r\n                 * IMPORTANT:\r\n                 * when our pocketSet for each this.pocket[id] is marked 'complete'\r\n                 * `Probe().resolve(...)` is called, and Promise.all is waiting for `pocketSet` to complete\r\n                 */\r\n                Promise.all(pocketSet.map(z => z.sq.promise())).then(z => {\r\n                    const output = z.map(p => userOutput(p.probe)).filter(n => !!n)\r\n                    this._ready[id].resolve(output)\r\n                }, err => {\r\n                    // should unlikely happen since we dont have any rejects set\r\n                    onerror(`[setDefer] Promise.all`, err)\r\n                })\r\n\r\n                return true\r\n            } catch (err) {\r\n                onerror(`[setDefer]`, err)\r\n            }\r\n\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * - distribute payloadData, each to `new Probe()`\r\n         */\r\n        distributor() {\r\n            for (let [key, el] of Object.entries(this.payloadData)) {\r\n                if (this.lastPocketTimestamp > el['timestamp']) continue // no new entries\r\n\r\n                // omit done\r\n                if (el.status === 'complete' || el.status === 'send' || el.status === 'error') continue\r\n\r\n                for (let value of el.value.values()) {\r\n                    const pl = { id: key, ...value }\r\n                    const pocketSet = this.setProbe(pl)\r\n                    if (!pocketSet) onerror(`probe for id:${key} already exists`)\r\n                }\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * - every new probe `id` must be: format `id:::taskName`\r\n         * required: `{id,task}`\r\n         * optional: `{compaign}`\r\n         * @param {*} opts\r\n         */\r\n        setProbe(opts = {}) {\r\n            if (!opts.id || !opts.task) throw ('id and task both must be set')\r\n            if (!validID(opts.id)) throw ('opts.id not valid')\r\n\r\n            const uid = `${opts.id}::${opts.task}`\r\n            if (this.pocket[uid]) {\r\n                if (this.debug) log(`[setProbe] probe: ${uid} already set`)\r\n                return null\r\n            }\r\n            try {\r\n                opts.id = uid\r\n                const p = new this.Probe(opts, this.debug)\r\n                this.pocket[uid] = p\r\n            } catch (err) {\r\n                onerror(err)\r\n                return null\r\n            }\r\n            return this.pocket[uid]\r\n        }\r\n\r\n        /**\r\n         * set new probe model\r\n         * - every new task has a set of requirements. Once status is `complete` and data available, probe sends a dispatch with probe information `(if opts.dispatcher===true)`.\r\n         * methods:`{get,all}` props: `{id,data,task,status,compaign}`\r\n         * \r\n         *  @param {*} opts.id required\r\n         *  @param {*} opts.task required\r\n         *  @param {*} opts.compaign optional\r\n         * \r\n         * - `Probe` is resolved once `sq.resolve()` is called, sq => `Simple Q` our plugin\r\n         */\r\n        get Probe() {\r\n            return newProbe(this)\r\n        }\r\n\r\n        /**\r\n         * - emit extends with `Dispatcher` to be used by every new Probe{} as an emitter `(if opts.dispatcher===true)`\r\n         * @param {*} obj required\r\n         */\r\n        _emit(obj) {\r\n            if (!obj) return null\r\n            if (!this.dispatcher) return null\r\n            try {\r\n                this.dispatcher.initListener().next(obj)\r\n                return true\r\n            } catch (err) {\r\n                onerror(`[_emit] dispatcher did not emit`)\r\n                return null\r\n            }\r\n        }\r\n\r\n        /**\r\n         * - delete completed `pocketSet`\r\n         */\r\n        deletePocketSet(id) {\r\n            if (Object.values(this.pocket).length) {\r\n                for (let poc of Object.values(this.pocket)) {\r\n                    if (this._$cached_data[poc.id]) delete this._$cached_data[poc.id]\r\n                    if (poc.id.includes(id)) delete this.pocket[poc.id]\r\n                }\r\n            }\r\n            if (this.payloadData[id]) delete this.payloadData[id]\r\n            if (this._ready[id]) delete this._ready[id]\r\n\r\n            // empty self\r\n            this.clearStoreTransfers(id)\r\n        }\r\n    }\r\n\r\n    class PocketModuleExt extends PocketModule {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n        }\r\n\r\n        /**\r\n         * - extend payload async data handling\r\n         */\r\n        $payload(data, async) {\r\n\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n            const asAsync = async !== undefined ? async : this.async // override if set\r\n            if (asAsync && isPromise(data)) return returnAs(data.then(z => super.$payload(z), err => err))\r\n            if (!this.async && !isPromise(data)) return returnAs(super.$payload(data))\r\n            else {\r\n                if (this.debug) onerror(`[payload] with opts.async=true, data must be a promise, or do not set async when not a promise`)\r\n                if (asAsync) return returnAs(Promise.reject())\r\n                else return returnAs(false)\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ### $project\r\n         * - `an alias on $payload(...), can use either`\r\n         * - refer to `$payload` for specifications :)\r\n         */\r\n        $project(...args) {\r\n            return this.$payload.apply(this, args)\r\n        }\r\n\r\n        $ready(payloadID) {\r\n\r\n            const returnAs = (val) => {\r\n                this.d = val\r\n                return this\r\n            }\r\n\r\n            const p = super.$ready(payloadID).then(z => {\r\n                this.deletePocketSet(payloadID)\r\n                return z\r\n            }, err => Promise.reject(err))\r\n\r\n            return returnAs(p)\r\n        }\r\n    }\r\n\r\n    const PocketSelectors = require('./Pocket.selectors')(PocketModuleExt)\r\n    return PocketSelectors\r\n\r\n}\r\n","/**\r\n * ### PocketLibs\r\n * - Top of the stack class of `PocketModule`, all `opt` initial `properties` are set here\r\n */\r\nmodule.exports = () => {\r\n    const { objectSize, warn, validID, copy, log, isString } = require('./utils')\r\n    return class PocketLibs {\r\n        /**\r\n         * @param {*} opts.async, when set, allow $payload(`data`) to be async object\r\n         * @param {*} opts.dispatcher, when set to true, loads external library `Dispatcher`\r\n         * @param {*} debug optional\r\n         */\r\n        constructor(opts = {}, debug) {\r\n            this.debug = debug || false\r\n            this.async = (opts || {}).async || null\r\n            // when set enables dispatcher to communicate directly with `probe.js`\r\n            this.dispatcher = (opts || {}).dispatcher ? require('../libs/dispatcher')() : null\r\n            this.pocket = {} // example this.pocket[`abc::taskName`] returns Probe{} Instance\r\n            this.payloadData = {}// each payload by id\r\n            this.lastPocketTimestamp = 0\r\n            this._lastProjectID = null // last cached reference\r\n            this._lastProbeID = null // last cached reference\r\n            this._$cached_data = {/** id:{} */ }// stores last captured data when calling `$data(..)`\r\n            this.$transfer_lastID = '' // set when we call `$transfer()` and reset after `$to()`\r\n            this._ready = {} // collect all ready example: `{id:Promise}`\r\n            this.d = undefined // NOTE user reference data, carefull when using selectors from previous target, always access last\r\n            this._transferCached = [ /** {timestamp,fromProbeID,data} */]\r\n        }\r\n\r\n        /**\r\n         * ### clearStoreTransfers\r\n         * - clear any pending transfers\r\n         * @param {*} projectID required\r\n         */\r\n        clearStoreTransfers(projectID = '') {\r\n            if (!projectID) return\r\n            let cleared = false\r\n            if (this._transferCached.length) {\r\n                this._transferCached.forEach((element, i) => {\r\n                    const { fromProbeID } = element || {}\r\n                    if (!fromProbeID) return\r\n                    if (fromProbeID.indexOf(projectID) !== -1) {\r\n                        this._transferCached.splice(i, 1)\r\n                        cleared = true\r\n                        if (this.debug) log(`[clearStoreTransfers] transferCached for probeID: ${fromProbeID} has been removed`)\r\n                    }\r\n                })\r\n            }\r\n            return cleared\r\n        }\r\n        /**\r\n         * ### storeTransfers\r\n         * - caches pending transfers when using `$transfer` with `$to()`\r\n         * - access last data by timestamp\r\n         * @param {*} fromProbeID  required\r\n         * @param {*} data required\r\n         */\r\n        storeTransfers(fromProbeID, data) {\r\n            this._transferCached.push({ timestamp: new Date().getTime(), fromProbeID, data })\r\n            return this._transferCached\r\n        }\r\n\r\n        /**\r\n         * ### accessLastValidTransfer\r\n         * returns latest transfer that is inRange from `fromAverageTimeHasPast` in `ms` vs current Date.getTime\r\n         * - removes _transferCached that was found \r\n         */\r\n        accessLastValidTransfer(fromAverageTimeHasPast = 100) {\r\n            if (!this._transferCached.length) return {}\r\n\r\n            this._transferCached.sort((a, b) => a.timestamp - b.timestamp)\r\n            const transferCachedCopy = copy(this._transferCached)\r\n\r\n            const coundCache = transferCachedCopy.reduce((n, el, i) => {\r\n                const { timestamp } = el\r\n\r\n                // calculate max wait between transfers, so if we have timeout we can only wait as long as `fromAverageTimeHasPast` \r\n                const currentOffset = new Date().getTime() + fromAverageTimeHasPast\r\n                const diff = (currentOffset - timestamp) - fromAverageTimeHasPast\r\n                const timeInRange = (currentOffset > timestamp) && diff <= fromAverageTimeHasPast\r\n                if (timeInRange) {\r\n                    n = el\r\n                    // delete found cache\r\n                    this._transferCached.splice(i, 1)\r\n                }\r\n                return n\r\n            }, {})\r\n\r\n            if (!objectSize(coundCache)) return {}\r\n            else return coundCache\r\n        }\r\n\r\n        /**\r\n         * ### selectByTask\r\n         * - works with `PocketSelectors class`, when `::taskNames, taskName` are specified, extracts full probeID by matching previous pointer reference and updates `lastProbeID()`        \r\n         * - returns valid probeID or null\r\n         * @param {*} probeID {*} required, but optional\r\n         */\r\n        selectByTask(taskOrProbeID = '', updateLastProbeID = null) {\r\n            taskOrProbeID = !isString(taskOrProbeID) ? '' : taskOrProbeID\r\n            if (!this.idRegexValid(taskOrProbeID) && taskOrProbeID) return null\r\n            console.log('what is taskOrProbeID', taskOrProbeID)\r\n            if (taskOrProbeID.indexOf(':') > 0 && !this.pocket[taskOrProbeID]) {\r\n                if (this.debug) warn(`[selectByTask] when using '::' prefix selector, it should come at 0 index`)\r\n                return null\r\n            }\r\n\r\n            if (taskOrProbeID.split(\":\").length > 3 || taskOrProbeID.split(\":\").length === 2) {\r\n                if (this.debug) warn(`[selectByTask] wrong taskName :${taskOrProbeID}, allowed prefix is '::taskName'`)\r\n                return null\r\n            }\r\n\r\n            if (updateLastProbeID) this.lastProbeID(taskOrProbeID, true) // if a match we receive below updated `_lastProbeID` \r\n            if (this.pocket[taskOrProbeID]) {\r\n                if (updateLastProbeID) this.lastProbeID(taskOrProbeID)\r\n                return taskOrProbeID // we have a valid ref so use that\r\n            }\r\n\r\n            /**\r\n             * - generate valid probeID `${projectID}::${probeTaskName}` //\r\n             */\r\n            const dynamicProbeID = (name) => {\r\n                const n = name.split(\"::\")[1] || name // in case we are using prefixed taskName, example \"::cocacola\"\r\n                const matchByProbeID = (this._lastProbeID || '').indexOf(n) > 0\r\n                if (matchByProbeID && n) return this._lastProbeID\r\n                else if (this._lastProjectID && n) return this._lastProjectID + `::` + n\r\n                return this._lastProbeID\r\n            }\r\n\r\n            const newProbeID = dynamicProbeID(taskOrProbeID)\r\n            if (!newProbeID) {\r\n                if (this.debug) warn(`[selectByTask] newProbeID was not found from taskOrProbeID: ${taskOrProbeID}`)\r\n            } else if (updateLastProbeID) this.lastProbeID(newProbeID)\r\n            return newProbeID\r\n        }\r\n\r\n        /**\r\n         * ### lastProjectID\r\n         * - every project is a job initiated by payload, so `payload.id === lastProjectID()`\r\n         */\r\n        lastProjectID(projectID = '', debug = null) {\r\n            if (!projectID && this._lastProbeID) projectID = this._lastProjectID\r\n            projectID = this.validProjectID(projectID, debug)\r\n            if (!projectID) return null\r\n            if (this.payloadData[projectID]) this._lastProjectID = projectID // cache last reference\r\n            return projectID\r\n        }\r\n\r\n        /**\r\n         * ### lastProbeID\r\n         * - return last reference to probeID\r\n         * - cache with `_lastProbeID`\r\n         * @param {*} probeID \r\n         */\r\n        lastProbeID(probeID = '', debug = null) {\r\n            if (!probeID && this._lastProbeID) probeID = this._lastProbeID\r\n            probeID = this.validProbe(probeID, debug)\r\n\r\n            if (!probeID) return null\r\n            if (this.pocket[probeID]) this._lastProbeID = probeID // cache last reference         \r\n            return probeID\r\n        }\r\n\r\n        /**\r\n         * ### validProjectID\r\n         * - `test if projectID is valid`\r\n         * - return valid id\r\n         * @param {*} id required\r\n         */\r\n        validProjectID(id, debug = null) {\r\n            id = validID(id)\r\n            if (!id) return null\r\n            if ((id || '').split(' ').length > 1) return null\r\n            if (!this.idRegexValid(id)) return null\r\n            return id\r\n        }\r\n\r\n        /**\r\n         * ### dataPropSelector\r\n         * - works with `$data()` and `$cached()` user selectors \r\n         * - refer to `PocketSelectors` module\r\n         * @param {*} probeID required\r\n         * @param {*} dataProp optional\r\n         * @param {*} self optional\r\n         * @param {*} probeData{} required our referencing probeData{}\r\n         */\r\n        dataPropSelector(type = 'data()', probeID = '', dataProp = {}, self = false, probeData = {}) {\r\n            let selectedData\r\n            /**\r\n             * NOTE if calling via `$cached()`,  `probeData` already comes as `this._$cached_data` so dont need to cache  it again!\r\n             */\r\n            try {\r\n                /**\r\n                  * NOTE IMPORTANT\r\n                  * assembly order: `dataProp < probeData > selectedData`\r\n                  * if are asking for multiple, example `selectedData:{a,b,value:1111}`, will return those available \r\n                  * as an Object{}. But if asking for only 1 `selectedData:{value:1111}`, will return the value `11111`, only because we know what we asked for initially\r\n                  */\r\n                selectedData = Object.entries(dataProp).reduce((n, [k, val], i) => {\r\n                    if (probeData[k] !== undefined) n[k] = probeData[k]\r\n                    return n\r\n                }, {})\r\n\r\n                if (!objectSize(selectedData)) selectedData = undefined\r\n\r\n                // selct only value if `dataProp` === `selectedData` is size ( 1 + 1 === 2 )\r\n                if (objectSize(selectedData) + objectSize(dataProp) === 2) selectedData = Object.values(selectedData).shift()\r\n\r\n                // if coming from `$data()` we cache our data \r\n                if (type === 'data()') this._$cached_data[probeID] = selectedData\r\n                return self ? this : selectedData\r\n            } catch (err) {\r\n                if (this.debug) warn(`[$data] no dataProp found on probeID: ${probeID}`)\r\n                if (type === 'data()') this._$cached_data[probeID] = selectedData\r\n                return self ? this : selectedData\r\n            }\r\n        }\r\n\r\n        idRegexValid(str) {\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(str)) {\r\n                // NOT ALWAYS NEEDED TO DISPLAY THE ERROR\r\n                // if (this.debug) onerror(`your id is invalid, allowed chars: ${pat}`)\r\n                return null\r\n            }\r\n            return true\r\n        }\r\n\r\n        /**\r\n         * ### validProbe\r\n         * - returns a valid probe\r\n         * @param {*} probeID required\r\n         */\r\n        validProbe(probeID, debug = null) {\r\n            probeID = validID(probeID)\r\n            if (!probeID) return null\r\n            if (!this.idRegexValid(probeID)) return\r\n            if (probeID.indexOf(`::`) === -1) return null\r\n            if (!this.pocket[probeID]) {\r\n                if (this.debug && debug === null) warn(`[get] did not find probe with probeID ${probeID}`)\r\n                return null\r\n            }\r\n            return probeID\r\n        }\r\n\r\n        /**\r\n         * ### probeProps\r\n         * - `each probe props that can be available and send on ready`\r\n         * - `order is important, keep 'status' last`\r\n         * - only updatable props are: `'compaign', 'data', 'status'(limited)`\r\n         */\r\n        get probeProps() {\r\n            return ['compaign', 'data', 'task', 'id', 'status']\r\n        }\r\n    }\r\n}\n","\r\n/**\r\n * requirejs global event handler\r\n */\r\nmodule.exports = function (uid, debug = null) {\r\n    return (new function () {\r\n        const plugin = `[dispatcher]`\r\n        this.uid = (uid || '').toString() || new Date().getTime()\r\n        this.debug = debug\r\n        this.cbQueue = {}\r\n        this.dispatchInstance = {}\r\n\r\n        this.initListener = () => {\r\n            this.Dispatch()\r\n            return this\r\n        }\r\n        /**\r\n         * @next\r\n         * send next data to the `batchReady` callback\r\n         * @param {*} data # optional\r\n         */\r\n        this.next = (data = null) => {\r\n            if (this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid].next(data)\r\n            else {\r\n                if (this.debug) console.log({ message: `${plugin} for uid not available`, uid: this.uid })\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n     * @Dispatch\r\n     * master listener, sends all event callbacks to `batchReady`\r\n     * @param {*} cb\r\n     */\r\n        this.Dispatch = () => {\r\n            if (this.dispatchInstance[this.uid]) return this\r\n            const self = this\r\n            const D = function () {\r\n                this.uid = self.uid\r\n                this.data = null\r\n\r\n                this.next = (data) => {\r\n                    if ((data || {}).type !== 'cb') this.data = data\r\n                    /**\r\n                         * @next\r\n                         * acts as a reverse callback, it sends back the `cb` from `batchReady`\r\n                         */\r\n                    if ((data || {}).type === 'cb') {\r\n                        if (typeof data.cb === 'function') {\r\n                            // when calling next before batchReady is initiated\r\n                            // collect cb from .next\r\n                            if (!self.cbQueue[self.uid]) self.cbQueue[self.uid] = data.cb\r\n                            if (this.data) data.cb(this.data, self.uid)\r\n                        }\r\n\r\n                        return\r\n                    }\r\n\r\n                    if (this.data) {\r\n                        if (typeof self.cbQueue[self.uid] === 'function') {\r\n                            self.cbQueue[self.uid](this.data, self.uid)\r\n                        }\r\n                    } else {\r\n                        if (this.debug) console.log(`${plugin} no callback data`)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid] = new D()\r\n            return this\r\n        }\r\n\r\n        this.del = () => {\r\n            delete this.cbQueue[this.uid]\r\n            delete this.dispatchInstance[this.uid]\r\n\r\n            if (!this.cbQueue[this.uid] && !this.dispatchInstance[this.uid]) {\r\n                // if (this.debug) console.log(`cbQueue and dispatchInstance for uid ${this.uid} deleted`)\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n     * @subscribe\r\n     * wait for callbacks forwarded from Dispatch and returned in callback of this method\r\n     * - Dispatch must be set initially before you call `subscribe`\r\n     * @param {*} cb #required\r\n     */\r\n        this.subscribe = (cb) => {\r\n            const isFN = typeof cb === 'function'\r\n            if (!isFN) {\r\n                if (this.debug) console.log(`${plugin}[batchReady] cb must be set`)\r\n                return this\r\n            }\r\n            if (!this.dispatchInstance[this.uid]) {\r\n                // this means batchReady was executed prior to `Dispatch`, because it has forward with next\r\n                // it will get executed anyway\r\n                this.Dispatch()\r\n            }\r\n            if (this.dispatchInstance[this.uid]) this.dispatchInstance[this.uid].next({ type: 'cb', cb })\r\n            return this\r\n        }\r\n    }(uid, debug))\r\n}\r\n","/**\r\n * Set new probe model\r\n * - every new task has a set of requirements controlled by `statusStackOrder` in status setter. Once status is `complete` and data available, information is send and probe is blocked.\r\n * methods:`{get,all}` props: `{id,data,tasks,status}`\r\n */\r\nmodule.exports = (dispatcher) => {\r\n    // const messageCODE = require('./errors') // DISPLAY MESSAGES WITH CODE\r\n    const { isString, warn, log, isNumber, onerror, last, copy, isObject } = require('./utils')\r\n    const sq = require('simple-q') // nice and simple promise/defer by `eaglex.net`\r\n    return class Probe {\r\n        /**\r\n         * @param {*} opts.id required, case sensitive, all will be toLowerCase() \r\n         * @param {*} opts.task once set cannot be changed\r\n         * @param {*} opts.compaign optional, once set cannot be changed\r\n         * @param {*} opts.data optional any value except undefind, cannot be change once status set to `complete` or send\r\n         * @param {*} opts.status required to control Probe actions\r\n         * @param {*} debug \r\n         */\r\n        constructor(opts = {}, debug) {\r\n            this.debug = debug || false\r\n            if (isNumber(opts.id) || opts.id) opts.id = opts.id.toString()\r\n            if (!opts.task || !isString(opts.task)) throw ('task as string is required')\r\n\r\n            this._id = null\r\n            this._task = null\r\n            this._status = null\r\n            this._data = null\r\n            this._compaign = null\r\n            this._dataIndex = 0\r\n            this._statusIndex = 0\r\n            this._statusAsync = [/** {timestamp:promise} */] // dynamic promise changer\r\n\r\n            this.task = opts.task\r\n            this.id = opts.id\r\n            this.status = 'open'\r\n\r\n            // assign initial data if differs from default\r\n            if (opts.data !== this._data) this.data = opts.data\r\n            if (opts.compaign) this.compaign = opts.compaign\r\n        }\r\n\r\n        /**\r\n         * nice and easy, save some coding, and added security\r\n         */\r\n        get sq() {\r\n            if (this[`_sq`]) return this[`_sq`]\r\n            this[`_sq`] = sq()\r\n            return this[`_sq`]\r\n        }\r\n\r\n        set id(v) {\r\n            if (this._id) {\r\n                if (this.debug) warn(`cannot update already set id: ${this._id}`)\r\n                return\r\n            }\r\n            if (!v) throw ('id is required')\r\n            if (v.split(' ').length > 1) throw ('each id cannot have spaces')\r\n            if (v.indexOf(`::`) === -1) throw ('each id must be of format id::taskName')\r\n            if (v.indexOf(`:::`) !== -1) throw ('each id must be of format id::taskName')\r\n\r\n            // validate chars\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(v)) throw (`your id is invalid, allowed chars: ${pat}`)\r\n\r\n            v = v.replace(/ /gi, '_').toLowerCase()\r\n\r\n            if (v.indexOf(this._task) === -1) {\r\n                throw (`wrong id setup, your id should make up the taks name, example: id='cocacola::drink'`)\r\n            }\r\n\r\n            this._id = v\r\n        }\r\n\r\n        get id() {\r\n            return this._id\r\n        }\r\n\r\n        get compaign() {\r\n            return this._compaign\r\n        }\r\n\r\n        set compaign(v) {\r\n            if (this._compaign) {\r\n                if (this.debug) warn(`cannot update already set compaign ${this._compaign}`)\r\n                return\r\n            }\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                if (this.debug) warn(`compaign must be a string`, v)\r\n                return\r\n            }\r\n\r\n            this._compaign = v\r\n        }\r\n\r\n        set task(v) {\r\n            if (this._task) {\r\n                if (this.debug) warn(`cannot update already set task`)\r\n                return\r\n            }\r\n\r\n            if (!v) return\r\n            if (!isString(v)) {\r\n                if (this.debug) warn(`task must be a string`)\r\n                return\r\n            }\r\n            if (v.indexOf(\"::\") !== -1) throw ('task seperator :: is restricted')\r\n            if (v.split(' ').length > 1) throw ('task cannot have spaces, use seperators: _+')\r\n            const pat = /[`~!@#$%^&*()\\=?;'\",.<>\\{\\}\\[\\]\\\\\\/]/gi\r\n            const regx = new RegExp(pat, 'gi')\r\n            if (regx.test(v)) throw (`your task is invalid, allowed chars: ${pat}`)\r\n\r\n            this._task = v.replace(/ /gi, '_').toLowerCase()// every task must be valid with required \r\n        }\r\n\r\n        get task() {\r\n            return this._task\r\n        }\r\n\r\n        set data(v) {\r\n            /**\r\n            * cannot be updated uppon status is send || complete\r\n            */\r\n            const complete = this.status === 'complete' || this.status === 'send'\r\n            if (complete) {\r\n                // NOTE this can also happen if you are using $transfer().$to from `PocketModule` that is a delayed\r\n                if (this.debug) warn(`you cannot update data once the status is complete or send`)\r\n                return null\r\n            }\r\n\r\n            this._dataIndex++\r\n            if (this.status === 'open' && this._data !== null && this._dataIndex > 1) this.status = 'updated'\r\n            this._data = v\r\n        }\r\n\r\n        /**\r\n         * ### update\r\n         * - update data of current Probe{}.data\r\n         * @param {*} data:any, required\r\n         * @param {*} merge:Boolean, optional for merging object to this.data\r\n         */\r\n        update(data, merge = null) {\r\n            if (this.status === 'complete' || this.status === 'send') {\r\n                if (this.debug) warn(`[Probe][update] cannot update data on complete status`)\r\n                return this\r\n            }\r\n            if (!isObject(data) && merge) {\r\n                if (this.debug) warn(`[Probe][update] cannot update none object 'data' with option 'merge=true' set`)\r\n                return this\r\n            }\r\n            if (isObject(data) && merge) this.data = Object.assign({}, this.data, data)\r\n            else if (data !== undefined) this.data = data\r\n            return this\r\n        }\r\n\r\n        get data() {\r\n            return this._data\r\n        }\r\n\r\n        /**\r\n         * forward motion `status` update is allowed\r\n         * `value`: importance que\r\n         * `set`: if status already set\r\n         */\r\n        get statusStackOrder() {\r\n            return {\r\n                open: { value: 1, set: false },\r\n                updated: { value: 2, set: false },\r\n                complete: { value: 3, set: false },\r\n                send: { value: 4, set: false },\r\n                error: { value: 5, set: false }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * allow status: open | updated | complete | send | error\r\n         * `open`: status is set when pocked is initialized\r\n         * `updated`: status is set when data is updated\r\n         * `complete`: status is set when you want to complete and discard probe\r\n         * `send`: once the status was set `complete` data is resolved first then status is set as `send`.\r\n         * and Probe is locked, cannot be interacted with. Follow the strategic order set by `statusStackOrder`\r\n         * `error` acts like complete, it will resolve() last available data and block the Probe\r\n         */\r\n        get status() {\r\n            return this._status\r\n        }\r\n\r\n        set status(v) {\r\n            // order of status and allowed values\r\n            ((stat) => {\r\n                try {\r\n                    // meaning do not allow any status changes beond `updated`\r\n                    if (this.statusStackOrder[stat].value > 2 && this.statusStackOrder[stat].set === true) return false\r\n                } catch (err) {\r\n                    onerror('statusStackOrder invalid status')\r\n                }\r\n\r\n                if (this._status === 'complete' || this._status === 'send') {\r\n                    if (this.debug) warn(`cannot update status if already complete, id:${this.id}`)\r\n                    return false\r\n                }\r\n\r\n                switch (stat) {\r\n                    case 'open':\r\n                        if (this._status === 'updated') {\r\n                            if (this.debug) warn(`cannot set status back to open once set to updated`)\r\n                            break\r\n                        }\r\n                        this._status = stat\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.onOpenStatus(v) // emit probe when status opens\r\n                        this.setStatusAsync = stat\r\n                        break\r\n\r\n                    case 'updated':\r\n                        if (this._status === 'complete') {\r\n                            if (this.debug) warn(`cannot update status to 'updated' then previously set to 'complete'`)\r\n                            break\r\n                        }\r\n\r\n                        if (this._dataIndex > 0) {\r\n                            this._status = stat\r\n                            this.statusStackOrder[stat].set = true\r\n                            this.setStatusAsync = stat\r\n                            if (this.debug) log(`id:${this.id}, data updated`)\r\n                        }\r\n\r\n                        break\r\n\r\n                    case 'complete':\r\n                        \r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        // setTimeout(()=>{\r\n                        this._status = stat\r\n                        this.onComplete(v) // resolve probe when status complete\r\n                        //  })\r\n                       \r\n                        break\r\n\r\n                    case 'send':\r\n                        if (this._status !== 'complete') {\r\n                            if (this.debug) warn(`cannot update status to 'send' then previously not set to 'complete'`)\r\n                            break\r\n                        }\r\n                        this._status = stat\r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        break\r\n\r\n                    case 'error':\r\n                        if (this._status === 'complete') return\r\n                        // when we have error we need to inform what happen, and close the Probe\r\n                        \r\n                        this.statusStackOrder[stat].set = true\r\n                        this.setStatusAsync = stat\r\n                        this.onComplete(v) // resolve probe when status complete                     \r\n                        break\r\n\r\n                    default:\r\n                        if (this.debug) warn(`id:${this.id},  you set invalid status: ${stat}, nothing changed`)\r\n                }\r\n            })(v)\r\n        }\r\n\r\n        /**\r\n         * - works with `statusAsync`\r\n         * - (1.) setter creates our new sq() promise every time, and allows use or resolve \r\n         * - to use example: setStatusAsync.resolve()\r\n         */\r\n        set setStatusAsync(v) {\r\n            // 'v'  set to anything to initiate setter\r\n            const timestamp = new Date().getTime()\r\n            const p = { timestamp, p: sq() }\r\n            this._statusAsync.push(p)\r\n        }\r\n\r\n        get setStatusAsync() {\r\n            const lastPromise = last(this._statusAsync.sort((a, b) => a.timestamp - b.timestamp).map(z => z['p']))\r\n            lastPromise.resolve(copy(this.status)) // << we are unly returning\r\n            return lastPromise\r\n        }\r\n\r\n        /**\r\n         * ### statusAsync\r\n         * - dynamic promise resolver with `Simple Q` from `eaglex.net`\r\n         * - works with `setStatusAsync` setter/getter\r\n         * - return last 'resolve' status from last `timestamp` setting\r\n         */\r\n        get getStatusAsync() {\r\n            return this.setStatusAsync.promise()\r\n        }\r\n\r\n        all() {\r\n            return { compaign: this.compaign, data: this.data, id: this.id, task: this.task, status: this.status }\r\n        }\r\n\r\n        /**\r\n         * status watch, when current status changes execute send\r\n         * @param {*} status\r\n         */\r\n        onComplete(status) {\r\n            if ((status === 'complete' || status === 'error') && this._status !== 'send' && this._dataIndex > 0) {\r\n               \r\n                if (dispatcher) {\r\n                    setTimeout(() => {\r\n                        if (dispatcher) dispatcher._emit({ probe: this, status })                   \r\n                    })\r\n                }\r\n                \r\n                this.sq.resolve({ probe: this.all() })\r\n                this._status = 'send'\r\n            }\r\n        }\r\n\r\n        /**\r\n         * do something on open task, this means we start request for data\r\n         * @param {*} status\r\n         */\r\n        onOpenStatus(status) {\r\n            if (status === 'open') {\r\n                // return this probe and update it when its complete\r\n                setTimeout(() => {\r\n                    if (dispatcher) dispatcher._emit({ probe: this, status: 'open' })\r\n                })\r\n            }\r\n        }\r\n    }\r\n}\r\n","\r\n/**\r\n * ### PocketSelectors\r\n * - Extends PocketModule using selectors for better access to Probes\r\n * - allow selecttion to refference by, example:  `taskName`, `::taskName` and `${projectID}::taskName`, thanks to `selectByTask()` method\r\n */\r\nmodule.exports = (PocketModule) => {\r\n    const { copy, warn, isArray, onerror, objectSize, isString, uniq } = require('../Pocket/utils')\r\n    return class PocketSelectors extends PocketModule {\r\n        constructor(opts, debug) {\r\n            super(opts, debug)\r\n        }\r\n\r\n        // extending original `$probeStatusAsync`\r\n        $probeStatusAsync(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return super.$probeStatusAsync(lastProbeID)\r\n        }\r\n\r\n        // extending original `$get`\r\n        $get(probeID, self) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return super.$get(lastProbeID, self)\r\n        }\r\n\r\n        // extending original `$set`\r\n        $set(dataFrom, probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return super.$set(dataFrom, lastProbeID)\r\n        }\r\n\r\n        /**\r\n         * ### $probe\r\n         * - return me as Probe{}, similar as $get(...), although does additional check for instanceOf Probe{}\r\n         * @param {*} probeID \r\n         */\r\n        $probe(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            if (!this.pocket[lastProbeID]) {\r\n                if (this.debug) warn(`[$probe] not found for probeID: ${probeID}`)\r\n                return undefined\r\n            }\r\n\r\n            if (this.pocket[lastProbeID].constructor.name !== 'Probe') {\r\n                if (this.debug) onerror(`[$probe] probeID: ${probeID} is not an instance of Probe{}`)\r\n                return undefined\r\n            }\r\n\r\n            return this.pocket[lastProbeID]\r\n        }\r\n\r\n        // extending original `$update`\r\n        $update(dataFrom, mergeData, probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            let lastProbeID = this.lastProbeID(probeID)\r\n            return super.$update(dataFrom, mergeData, lastProbeID)\r\n        }\r\n\r\n        /**\r\n         * ### $select\r\n         * - select current payloadID/project/job by id you are working on\r\n         * @param {*} projectID optional/sensitive, selects new point of reference.\r\n         */\r\n        $select(projectID = '') {\r\n            projectID = !isString(projectID) ? '' : projectID\r\n            this.lastProjectID(projectID) // also updates last selector reference\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $transfer\r\n         * - select data from `fromProbeID` and hold it in `_transferCache`, until `$to(probeID)` is called\r\n         * - warning, action removes `Probe[fromProbeID].data` and overrides it on Probe[probeID].data, only when `$to(probeID)` is called, simple as that!\r\n         * @param {*} fromProbeID optional/sensitive, selects new point of reference.\r\n         */\r\n        $transfer(fromProbeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            fromProbeID = this.selectByTask(fromProbeID, true)\r\n            fromProbeID = this.lastProbeID(fromProbeID)\r\n            if (!this.pocket[fromProbeID]) {\r\n                if (this.debug) warn(`[$transfer] no Probe{} found for this id fromProbeID:${fromProbeID}`)\r\n                return this\r\n            }\r\n            this.storeTransfers(fromProbeID, copy(this.pocket[fromProbeID]['data']))\r\n            // NOTE needed for extra security to make sure it was called before we can update `$to()`\r\n            this.$transfer_lastID = fromProbeID\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $to\r\n         * - works together with `$transfer`, will transfer `data` from one Probe{} to another\r\n         * if `_transferCache` is set, the cache is cleared.\r\n         * @param {*} toProbeID optional/sensitive, points to Probe{} `data` will be packed, it is not previous reference pointer, but the next.\r\n         * @param {*} pointToThisProbe to stay on the current pointer reference\r\n         * @param {*} maxDelay, keep at minimum! Time between transaction can take place, relates to `fromAverageTimeHasPast` found in `accessLastValidTransfer()`\r\n         */\r\n        $to(toProbeID = '', pointToThisProbe = true, maxDelay = 100) {\r\n\r\n            // allow use of short ref names example: `::cocalola`\r\n            toProbeID = this.selectByTask(toProbeID, pointToThisProbe)\r\n            // if (!keepLastPointerReference) toProbeID = this.lastProbeID(toProbeID)\r\n            if (pointToThisProbe) toProbeID = this.validProbe(toProbeID)\r\n            if (!toProbeID) {\r\n                if (this.debug) warn(`[$to] toProbeID is invalid`)\r\n                return this\r\n            }\r\n            if (!this.pocket[toProbeID]) {\r\n                if (this.debug) warn(`[$to] no Probe{} found for this id toProbeID:${toProbeID}`)\r\n                return this\r\n            }\r\n            if (this.$transfer_lastID) {\r\n                // please note because this can be a delayed transaction, if you send `status=complete`\r\n                // the data will not be updated\r\n                const lastValidTransfer = this.accessLastValidTransfer(maxDelay)\r\n                if (objectSize(lastValidTransfer)) {\r\n                    const { fromProbeID, data } = lastValidTransfer\r\n                    if (this.$transfer_lastID === fromProbeID) {\r\n                        this.pocket[fromProbeID]['data'] = null // from $transfer \r\n                        this.pocket[toProbeID]['data'] = data // $to \r\n                    }\r\n                } else {\r\n                    if (this.debug) warn(`[$to] no last valid transfer found`)\r\n                }\r\n                this.$transfer_lastID = ''\r\n            }\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $of\r\n         * - points to Probe{} be reference\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $of(probeID = '') {\r\n            // allow use of short ref names example: `::cocalola`\r\n            this.selectByTask(probeID, true)\r\n            return this\r\n        }\r\n\r\n        /**\r\n         * ### $data\r\n         * - returns Object copy of `Probe['data']`\r\n         * @param {*} dataProp optional, if you know what you are asking for example: `{assets:true}`,or `array['assets]`, it has catch error exception, so you wont receive any errors just `null`\r\n         * will return all available matched within our `Probe{}['data]`. Multiples of `dataProp{}/([])/(',')` will return an object, if only one specified, only value will be retured\r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         * @param {*} self optional,if you want to $cached() last data enquiry and return `self` to keep chaining, nice!\r\n         */\r\n        $data(dataProp = null/** {}||[] */, probeID = '', self = false) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return self ? this : undefined\r\n\r\n            // NOTE can provide as an array\r\n            if (isArray(dataProp) && (dataProp || []).length) {\r\n                dataProp = uniq(dataProp).reduce((n, el) => {\r\n                    if (el !== undefined) n[el.trim()] = true\r\n                    return n\r\n                }, {})\r\n            }\r\n\r\n            if (!dataProp || !objectSize(dataProp)) {\r\n                this._$cached_data[probeID] = copy(this.pocket[probeID]['data'])\r\n                return self ? this : this._$cached_data[probeID]\r\n            }\r\n            return this.dataPropSelector(\"data()\", probeID, dataProp, self, copy(this.pocket[probeID]['data']))\r\n        }\r\n\r\n        /**\r\n         * ### cached\r\n         * - grabs last cached `$data(...)` from Probe{}\r\n         * @param {*} dataProp{}/String optional, know what you are asking for example: ` {assets:true}/ or > 'assets,values,somethingElse'`, it has catch error exception, so you wont receive any errors just `null`\r\n         * will return all available matched within our `_$cached_data[probeID]`. Multiples of `dataProp{}/([])/(',')` will return an object, if only one specified, only value will be retured\r\n         * @param {*} probeID \r\n         */\r\n        $cached(dataProp = {}/** ='' */, probeID = '') {\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return undefined\r\n            const hasValue = this._$cached_data[probeID] !== undefined && this._$cached_data[probeID] !== null\r\n            if (!hasValue) return undefined\r\n            // if you provided a string make it an object\r\n            if (isString(dataProp) && (dataProp || '').length) {\r\n                dataProp = uniq(dataProp.trim().replace(/ /gi, '').split(',')).reduce((n, el) => {\r\n                    if (el !== undefined) n[el] = true\r\n                    return n\r\n                }, {})\r\n            }\r\n            // return cached data if its not an object, or undefined\r\n            if (!objectSize(this._$cached_data[probeID]) && hasValue) {\r\n                if (objectSize(dataProp)) return undefined // our cache not an object, but we are asking for dataProp reference, so should return undefined\r\n                else return this._$cached_data[probeID]\r\n            }\r\n            // no selection at all, so just return whats available\r\n            if (!dataProp || !objectSize(dataProp)) {\r\n                return this._$cached_data[probeID] === undefined ? undefined : this._$cached_data[probeID]\r\n            } else return this.dataPropSelector(\"cached()\", probeID, dataProp, false, this._$cached_data[probeID])\r\n        }\r\n\r\n        /**\r\n         * ### $compaign\r\n         * - returns Object copy of `Probe['compaign']` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $compaign(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['compaign'])\r\n        }\r\n\r\n        /**\r\n        * ### $status\r\n        * - returns Object copy of `Probe['status']` \r\n        * @param {*} probeID optional/sensitive, select new point of reference\r\n        */\r\n        $status(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['status'])\r\n        }\r\n\r\n        /**\r\n       * ### $task\r\n       * - returns Object copy of `Probe['task']` \r\n       * @param {*} probeID optional/sensitive, select new point of reference\r\n       */\r\n        $task(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID]['task'])\r\n        }\r\n\r\n        /**\r\n         * ### $all\r\n         * - return Object copy of all setters: `{id,status,compaign,task,data}` \r\n         * @param {*} probeID optional/sensitive, select new point of reference\r\n         */\r\n        $all(probeID) {\r\n            // allow use of short ref names example: `::cocalola`\r\n            probeID = this.selectByTask(probeID, true)\r\n            if (!this.pocket[probeID]) return null\r\n            return copy(this.pocket[probeID].all())\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}